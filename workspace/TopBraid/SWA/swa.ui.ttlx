# baseURI: http://topbraid.org/swa
# imports: http://topbraid.org/search
# imports: http://topbraid.org/swa.spin
# imports: http://topbraid.org/swafacets
# imports: http://topbraid.org/swamaps
# imports: http://uispin.org/html
# imports: http://uispin.org/swon
# imports: http://www.w3.org/2004/02/skos/core

@prefix afn: <http://jena.hpl.hp.com/ARQ/function#> .
@prefix arg: <http://spinrdf.org/arg#> .
@prefix composite: <http://www.topbraid.org/2007/05/composite.owl#> .
@prefix css: <http://uispin.org/css#> .
@prefix daml: <http://www.daml.org/2001/03/daml+oil#> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix dct: <http://purl.org/dc/terms/> .
@prefix default: <http://uispin.org/default#> .
@prefix email: <http://topbraid.org/email#> .
@prefix fn: <http://www.w3.org/2005/xpath-functions#> .
@prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#> .
@prefix html: <http://uispin.org/html#> .
@prefix let: <http://uispin.org/let#> .
@prefix letrs: <http://uispin.org/letrs#> .
@prefix list: <http://jena.hpl.hp.com/ARQ/list#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix search: <http://topbraid.org/search#> .
@prefix search.spin: <http://topbraid.org/search.spin#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix sm: <http://topbraid.org/sparqlmotion#> .
@prefix smf: <http://topbraid.org/sparqlmotionfunctions#> .
@prefix sml: <http://topbraid.org/sparqlmotionlib#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix sparqlmotionlib-swp: <http://topbraid.org/sparqlmotionlib-swp#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix spr: <http://spinrdf.org/spr#> .
@prefix spra: <http://spinrdf.org/spra#> .
@prefix style: <http://uispin.org/style#> .
@prefix swa: <http://topbraid.org/swa#> .
@prefix swon: <http://uispin.org/swon#> .
@prefix sxml: <http://topbraid.org/sxml#> .
@prefix ui: <http://uispin.org/ui#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

rdf:type
  swa:hiddenProperty "if no object exists"^^xsd:string ;
.
<http://dbpedia.org/ontology/thumbnail>
  rdf:type rdf:Property ;
  rdfs:label "thumbnail"^^xsd:string ;
  rdfs:subPropertyOf swa:thumbnail ;
.
<http://schema.org/image>
  rdf:type rdf:Property ;
  rdfs:label "image"^^xsd:string ;
  rdfs:subPropertyOf swa:thumbnail ;
.
arg:action
  rdf:type rdf:Property ;
  rdfs:label "action"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:allowHistoryMode
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:allowLogMessage
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:allowURIs
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:appName
  rdf:type rdf:Property ;
  rdfs:label "app name"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:argumentName
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:bnode
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:cache
  rdf:type rdf:Property ;
  rdfs:label "cache"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:callback
  rdf:type rdf:Property ;
  rdfs:label "callback"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:changeHandler
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:child
  rdf:type rdf:Property ;
  rdfs:label "child"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:childrenQuery
  rdf:type rdf:Property ;
  rdfs:label "children query"^^xsd:string ;
  rdfs:subPropertyOf ui:query ;
.
arg:class
  rdf:type rdf:Property ;
  rdfs:label "class"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:classSelectedEvent
  rdf:type rdf:Property ;
  rdfs:label "Class Selected Event"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:classTreeDataProvider
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:closable
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:code
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:colWidths
  rdf:type rdf:Property ;
  rdfs:label "col widths"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:condition
  rdf:type rdf:Property ;
  rdfs:label "condition"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:contextResource
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:contextResourceGetter
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:count
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:createHandler
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:data
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:dataGraph
  rdf:type rdf:Property ;
  rdfs:label "data graph"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:dataProvider
  rdf:type rdf:Property ;
  rdfs:label "data provider"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:datatype
  rdf:type rdf:Property ;
  rdfs:label "datatype"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:deepLinkingEvent
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:defaultImage
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:descSorting
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:directInstancesOnly
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:disabled
  rdf:type rdf:Property ;
  rdfs:label "disabled"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:domain
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:draggable
  rdf:type rdf:Property ;
  rdfs:label "draggable"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:eastFixed
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:eastSize
  rdf:type rdf:Property ;
  rdfs:label "east size"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:editWidget
  rdf:type rdf:Property ;
  rdfs:label "edit widget"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:editable
  rdf:type rdf:Property ;
  rdfs:label "editable"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:editing
  rdf:type rdf:Property ;
  rdfs:label "editing"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:elementId
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:event
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:facetClass
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:filter
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:filterFunction
  rdf:type rdf:Property ;
  rdfs:label "filter function"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:filterFunctionArgument
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:fixed
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:footerPlugin
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:formId
  rdf:type rdf:Property ;
  rdfs:label "form id"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:function
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:gadgetLabel
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:gadgetName
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:group
  rdf:type rdf:Property ;
  rdfs:label "group"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:headerLabel
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:height
  rdf:type rdf:Property ;
  rdfs:label "height"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:hiddenColName
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:hideGlobalSearch
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:hideIfEmpty
  rdf:type rdf:Property ;
  rdfs:label "hide if empty"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:hideInModes
  rdf:type rdf:Property ;
  rdfs:label "hide in modes"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:iconClass
  rdf:type rdf:Property ;
  rdfs:label "icon class"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:id
  rdf:type rdf:Property ;
  rdfs:label "id"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:initialValue
  rdf:type rdf:Property ;
  rdfs:label "initial value"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:input
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:inputType
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:instanceSelectedEvent
  rdf:type rdf:Property ;
  rdfs:label "Instance Selected Event"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:inverse
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:key
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:keyProperties
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:keyPropertiesList
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:label
  rdf:type rdf:Property ;
  rdfs:label "label"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:labelProperty
  rdf:type rdf:Property ;
  rdfs:label "label property"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:labelWidth
  rdf:type rdf:Property ;
  rdfs:label "label width"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:layoutPanel
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:leftWidth
  rdf:type rdf:Property ;
  rdfs:label "left width"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:loadId
  rdf:type rdf:Property ;
  rdfs:label "load id"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:loadImmediately
  rdf:type rdf:Property ;
  rdfs:label "load immediately"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:matchIds
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maxLength
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maxResultCount
  rdf:type rdf:Property ;
  rdfs:label "max result count"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maximizable
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:metadata
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:minimizable
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:modeName
  rdf:type rdf:Property ;
  rdfs:label "mode name"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:modeNames
  rdf:type rdf:Property ;
  rdfs:label "mode names"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:noBorder
  rdf:type rdf:Property ;
  rdfs:label "no border"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:northFixed
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:northSize
  rdf:type rdf:Property ;
  rdfs:label "north size"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:object
  rdf:type rdf:Property ;
  rdfs:label "object"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:objectType
  rdf:type rdf:Property ;
  rdfs:label "object type"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:oldElementId
  rdf:type rdf:Property ;
  rdfs:label "old element id"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:onClick
  rdf:type rdf:Property ;
  rdfs:label "on click"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:onDoubleClick
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:onLoaded
  rdf:type rdf:Property ;
  rdfs:label "on loaded"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:onSelect
  rdf:type rdf:Property ;
  rdfs:label "on select"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:open
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:openable
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:ownerId
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:page
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:params
  rdf:type rdf:Property ;
  rdfs:label "params"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:parent
  rdf:type rdf:Property ;
  rdfs:label "parent"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:parentId
  rdf:type rdf:Property ;
  rdfs:label "parent id"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:parentUIElementId
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:predicates
  rdf:type rdf:Property ;
  rdfs:label "predicates"^^xsd:string ;
  rdfs:subPropertyOf ui:resultSet ;
.
arg:property
  rdf:type rdf:Property ;
  rdfs:label "property"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:queryGraph
  rdf:type rdf:Property ;
  rdfs:label "query graph"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:range
  rdf:type rdf:Property ;
  rdfs:label "range"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:readOnly
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:refreshEvent
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceGetter
  rdf:type rdf:Property ;
  rdfs:label "resource getter"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceSelectedEvent
  rdf:type rdf:Property ;
  rdfs:label "resource selected event"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceTypeCode
  rdf:type rdf:Property ;
  rdfs:label "resource type code"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceTypeLabel
  rdf:type rdf:Property ;
  rdfs:label "resource type label"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceURI
  rdf:type rdf:Property ;
  rdfs:label "resource URI"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resourceURIs
  rdf:type rdf:Property ;
  rdfs:label "resource URIs"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:restoreSearch
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resultsId
  rdf:type rdf:Property ;
  rdfs:label "results id"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:root
  rdf:type rdf:Property ;
  rdfs:label "root"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rootClass
  rdf:type rdf:Property ;
  rdfs:label "Root Class"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rootType
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rootsQuery
  rdf:type rdf:Property ;
  rdfs:label "roots query"^^xsd:string ;
  rdfs:subPropertyOf ui:query ;
.
arg:rowIndex
  rdf:type rdf:Property ;
  rdfs:label "row index"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rowNumCookie
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rows
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:script
  rdf:type rdf:Property ;
  rdfs:label "script"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:search
  rdf:type rdf:Property ;
  rdfs:label "search"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchButtonHandler
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchCompletedEvent
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchGraph
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchMemoryModel
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchResultsGeneratedEvent
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchResultsGridHandler
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:searchWidget
  rdf:type rdf:Property ;
  rdfs:label "search widget"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:selectId
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:selectedResource
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:selectedType
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:showFooter
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:showResourceActions
  rdf:type rdf:Property ;
  rdfs:label "show resource actions"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:showSearchResultsActions
  rdf:type rdf:Property ;
  rdfs:label "show search results actions"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:showURI
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sidx
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:single
  rdf:type rdf:Property ;
  rdfs:label "single"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:size
  rdf:type rdf:Property ;
  rdfs:label "size"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sord
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sortByFirstKeyProperty
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sortProperty
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:southFixed
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:southSize
  rdf:type rdf:Property ;
  rdfs:label "south size"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:string
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:style
  rdf:type rdf:Property ;
  rdfs:label "style"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:subClass
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:subject
  rdf:type rdf:Property ;
  rdfs:label "subject"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressActions
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressHeader
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressInitializer
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressKeyPropertiesSelection
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressLabelColumn
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressLanguage
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:suppressTypeSelection
  rdf:type rdf:Property ;
  rdfs:label "suppress type selection"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:tableFactory
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:tabular
  rdf:type rdf:Property ;
  rdfs:label "tabular"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:targetId
  rdf:type rdf:Property ;
  rdfs:label "target id"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:template
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:templateGraph
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:templates
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:term
  rdf:type rdf:Property ;
  rdfs:label "term"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:title
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:toggleFunctionCall
  rdf:type rdf:Property ;
  rdfs:label "toggle function call"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:toolTip
  rdf:type rdf:Property ;
  rdfs:label "tool tip"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:topHeight
  rdf:type rdf:Property ;
  rdfs:label "top height"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treeChildrenTemplate
  rdf:type rdf:Property ;
  rdfs:label "tree children template"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treeDataProvider
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treeId
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treePathTemplate
  rdf:type rdf:Property ;
  rdfs:label "tree path template"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treeRootsTemplate
  rdf:type rdf:Property ;
  rdfs:label "tree roots template"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:type
  rdf:type rdf:Property ;
  rdfs:label "type"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:typeLabel
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:typeSelectable
  rdf:type rdf:Property ;
  rdfs:label "type selectable"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:uiElementId
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:uid
  rdf:type rdf:Property ;
  rdfs:label "uid"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:value
  rdf:type rdf:Property ;
  rdfs:label "value"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:varName
  rdf:type rdf:Property ;
  rdfs:label "var name"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:view
  rdf:type rdf:Property ;
  rdfs:label "view"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:viewModeName
  rdf:type rdf:Property ;
  rdfs:label "view mode name"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:viewWidget
  rdf:type rdf:Property ;
  rdfs:label "view widget"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:westFixed
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:westSize
  rdf:type rdf:Property ;
  rdfs:label "west size"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:width
  rdf:type rdf:Property ;
  rdfs:label "width"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
arg:windowId
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:withInitializer
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:withSelectMenu
  rdf:type rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
spin:Modules
  ui:instanceView """
<swa:ArgumentsFormBody arg:resource=\"{= ?this }\" ui:id=\"form\"/>
"""^^ui:Literal ;
.
search:results
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:count ;
      spl:valueType xsd:integer ;
      rdfs:comment "The number of rows to deliver at most."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:descSorting ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to sort in descending order."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:sortProperty ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property to sort against."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:startIndex ;
      spl:valueType xsd:integer ;
      rdfs:comment "The row index to start with."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:search ;
      spl:valueType search:Search ;
      rdfs:comment "The search:Search to execute."^^xsd:string ;
    ] ;
  rdfs:comment "Executes a given search:Search and executes the child elements with two additional variable bindings: ?totalCount will contain the number of matching rows, and ?results is a SPARQL result set with one column called ?result."^^xsd:string ;
  rdfs:label "results"^^xsd:string ;
  rdfs:subClassOf ui:ControlElement ;
.
sm:source
  swa:hiddenProperty "true"^^xsd:boolean ;
.
sml:swpNote
  swa:hiddenProperty "true"^^xsd:boolean ;
.
<http://topbraid.org/swa>
  rdf:type owl:Ontology ;
  rdfs:comment """A library of reusable components for SWP-based applications. Includes elements to insert forms, trees, grids etc.

This library is under active development, and most elements and functions are declared \"private\" to discourage its direct use. If you need any of the private elements, please let us know. We will make reasonable efforts to keep the non-private elements stable."""^^xsd:string ;
  owl:imports <http://topbraid.org/search> ;
  owl:imports <http://topbraid.org/swa.spin> ;
  owl:imports <http://topbraid.org/swafacets> ;
  owl:imports <http://topbraid.org/swamaps> ;
  owl:imports <http://uispin.org/html> ;
  owl:imports <http://uispin.org/swon> ;
  owl:imports <http://www.w3.org/2004/02/skos/core> ;
  owl:versionInfo "0.9.0"^^xsd:string ;
.
swa:AbstractBorderLayout
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:eastFixed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make the eastern panel not resizable."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:eastSize ;
      spl:valueType xsd:integer ;
      rdfs:comment "The pixel size of the east panel."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:northFixed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make the north panel not resizable."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:northSize ;
      spl:valueType xsd:integer ;
      rdfs:comment "The pixel size of the north panel."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:southFixed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make the south panel not resizable."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:southSize ;
      spl:valueType xsd:integer ;
      rdfs:comment "The pixel size of the south panel."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:westFixed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make the west panel not resizable."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:westSize ;
      spl:valueType xsd:integer ;
      rdfs:comment "The pixel size of the west panel."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Abstract base class that groups together some arguments needed for border layouts."^^xsd:string ;
  rdfs:label "Abstract border layout"^^xsd:string ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:AbstractEnumDropDownEditor
  rdf:type swa:ObjectEditorClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<span let:name=\"new-{= ?uid }\" let:range=\"{= swa:localRangeAtClass(swa:resourceType(?subject), ?predicate) }\">
    <select class=\"{= swa:testClass(?predicate) }\" name=\"{= ?name }\">
        <ui:call arg:resource=\"{= ?range }\" ui:template=\"{= swa:OneOfItems }\">
            <option/>
            <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?rs }\">
                <option selected=\"{= IF((?object = ?item), &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(?item) }\">{= ui:label(?item) }</option>
            </ui:forEach>
        </ui:call>
    </select>
</span>
"""^^ui:Literal ;
  rdfs:label "Abstract enum drop down editor"^^xsd:string ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:AbstractEnumDropDownFacet
  rdf:type swa:ObjectFacetClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<span let:name=\"value{= ?uid }\" let:range=\"{= swa:localRangeAtClass(swa:resourceType(), ?predicate) }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <select class=\"{= swa:testClass(?predicate) }\" let:value=\"{= IF(bound(?restore), spl:object(?restore, search:object), ?none) }\" name=\"{= ?name }\">
        <ui:call arg:resource=\"{= ?range }\" ui:template=\"{= swa:OneOfItems }\">
            <option type=\"radio\">{= ?item }</option>
            <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?rs }\">
                <option selected=\"{= IF((?value = ?item), &quot;selected&quot;, ?none) }\" type=\"radio\" value=\"{= ui:encodeNode(?item) }\">{= ui:label(?item) }</option>
            </ui:forEach>
        </ui:call>
    </select>
</span>
"""^^ui:Literal ;
  rdfs:label "Abstract enum drop down facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:AbstractObject
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "160px"^^xsd:string ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:labelWidth ;
      spl:valueType xsd:string ;
      rdfs:comment "The label width, defaults to 160px. Set to \"inline\" to have the preferred width, i.e. it will occupy exactly the needed space."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:editWidget ;
      spl:valueType swa:ObjectEditorClass ;
      rdfs:comment "The preferred widget if in edit mode."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:hideIfEmpty ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress this if the given subject has no value for the given predicate. Has no effect if we are not in view mode."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:hideInModes ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional comma-separated list of mode names (e.g. \"edit\", \"search\", \"view\") enumerating those views in which this widget shall be hidden."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "A label, overriding the default label."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchWidget ;
      spl:valueType swa:ObjectFacetClass ;
      rdfs:comment "The preferred facet widget."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:tabular ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to use a fixed labelWidth so that all objects show up in a tabular alignment."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:viewWidget ;
      spl:valueType swa:ObjectViewerClass ;
      rdfs:comment "The preferred widget if in view mode."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Base class of swa:Object and swa:Objects, to declare the arguments that the subclasses have in common."^^xsd:string ;
  rdfs:label "Abstract object"^^xsd:string ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:AbstractRadioButtonsEditor
  rdf:type swa:ObjectEditorClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<span let:name=\"new-{= ?uid }\" let:range=\"{= swa:localRangeAtClass(swa:resourceType(?subject), ?predicate) }\">
    <ui:call arg:resource=\"{= ?range }\" ui:template=\"{= swa:OneOfItems }\">
        <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?rs }\">
            <ui:if ui:condition=\"{= ?index &gt; 0 }\">
                <br/>
            </ui:if>
            <input checked=\"{= IF((?item = ?object), &quot;selected&quot;, ?none) }\" name=\"{= ?name }\" type=\"radio\" value=\"{= ui:encodeNode(?item) }\"/>{= ui:label(?item) }</ui:forEach>
    </ui:call>
</span>
"""^^ui:Literal ;
  rdfs:label "Radio buttons editor"^^xsd:string ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:AbstractSubject
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "160px"^^xsd:string ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:labelWidth ;
      spl:valueType xsd:string ;
      rdfs:comment "The label width, defaults to 160px. Set to \"inline\" to have the preferred width, i.e. it will occupy exactly the needed space."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:hideIfEmpty ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress this if the given subject has no value for the given predicate. Has no effect if we are not in view mode."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "A label, overriding the default label."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:tabular ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to set labels to a fixed width so that all subjects appear in a tabular layout."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Similar to swa:AbstractObject but for the other direction."^^xsd:string ;
  rdfs:label "Abstract subject"^^xsd:string ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:AbstractTextFieldEditor
  rdf:type swa:ObjectEditorClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressLanguage ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to disallow editing the language."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:inputType ;
      spl:valueType xsd:string ;
      rdfs:comment "Either \"text\" or \"password\"."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:datatype=\"{= IF(bound(?object), datatype(?object), swa:localRange(?predicate, ?subject)) }\">
    <swa:ObjectEditorHiddenDatatypeField arg:datatype=\"{= ?datatype }\" arg:uid=\"{= ?uid }\"/>
    <div style=\"white-space: nowrap\">
        <input class=\"swa-text-field {= swa:testClass(?predicate) }\" name=\"new-{= ?uid }\" type=\"{= ?inputType }\" value=\"{= ?object }\"/>
        <ui:if ui:condition=\"{= (((?datatype = xsd:string) || (?datatype = rdfs:Literal)) || (?datatype = rdf:langString)) || (bound(?object) &amp;&amp; (lang(?object) != &quot;&quot;)) }\">
            <ui:if ui:condition=\"{= (!bound(?suppressLanguage)) || (!?suppressLanguage) }\">
                <swa:LangSelector arg:initialValue=\"{= lang(?object) }\" arg:uid=\"{= ?uid }\"/>
            </ui:if>
        </ui:if>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Base class to share common functionality of TextFieldEditor and PasswordEditor."^^xsd:string ;
  rdfs:label "Abstract text field editor"^^xsd:string ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:Action
  rdf:type rdfs:Class ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of one or more applications (comma-separated) that this action is applicable for. Can be used to narrow down some actions so that they only show up for applications where the context variable \"swaAppName\" has been set to a given value."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:group ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the group that this belongs to. Actions from the same group will be visually separated from those in other groups (e.g. using dividers in menus). All groups will be ordered alphabetically."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:iconClass ;
      spl:valueType xsd:string ;
      rdfs:comment "The CSS class(es) for icons representing the action."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:condition ;
      spl:valueType xsd:boolean ;
      rdfs:comment "An expression delivering a boolean. Only Actions that return true will be displayed and can be selected. Depending on the context, different variables will be pre-bound when the condition is evaluated. For example, ResourceActions have ?resource pre-bound with the selected resource and SearchResultActions have the variable ?appName pre-bound with the surrounding SWA application name."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "JavaScript code that shall be executed when the Action is executed by the user."^^xsd:string ;
    ] ;
  rdfs:comment """Abstract superclass for objects that represent an executable action. Actions are typically rendered as menu items or buttons and may have a label and/or an icon.

The SWA actions framework supports plug-in development in which available actions are discovered dynamically. The plug-in developer simply needs to create an instance of an Action class in an SWP graph, and the framework can traverse, filter and sort the available actions when needed.

Actions can be grouped by applications, so that not all globally registered actions will be visible everywhere. SWA applications that wish to restrict the actions should set a global context variable \"swaAppName\" globally, using ui:setContext. This may be a comma-separated list of names, e.g. \"EVN,Editor\" for all actions related to EVN and those associated with \"Editor\" (the global Delete resource action is marked like that).

When the user triggers execution, the engine will execute the JavaScript code specified by the onSelect argument. If no onSelect is declared then the Action is expected to be an SWP element class that executes some transaction performing updates to the graph."""^^xsd:string ;
  rdfs:label "Action"^^xsd:string ;
.
swa:AddPropertyBox
  rdf:type ui:NodeClass ;
  ui:prototype """
<ui:if ui:condition=\"{= swa:isSearchMode() }\">
    <ui:group let:id=\"{= ui:uniqueId() }\" let:resourceType=\"{= swa:resourceType() }\" let:restoreSearch=\"{= swa:restoreSearch() }\">
        <ui:if ui:condition=\"{= bound(?restoreSearch) }\">
            <ui:forEach ui:resultSet=\"{#
                    SELECT ?predicate
                    WHERE {
                        ?restoreSearch search:facet/search:property ?predicate .
                        FILTER NOT EXISTS {
                            GRAPH ui:tempGraph {
                                ?restoreSearch swa:used ?predicate .
                            } .
                        } .
                    } }\">
                <swa:Object arg:predicate=\"{= ?predicate }\" arg:tabular=\"{= true }\"/>
            </ui:forEach>
        </ui:if>
        <ui:loadable ui:loadId=\"{= ?id }-object\">
            <ui:if ui:condition=\"{= bound(?addProperty) }\">
                <swa:Object arg:predicate=\"{= ?addProperty }\" arg:tabular=\"{= true }\"/>
            </ui:if>
        </ui:loadable>
        <ui:loadable ui:loadId=\"{= ?id }\">
            <ui:group letrs:properties=\"{#
                    SELECT ?property
                    WHERE {
                        ?property spl:relevantPropertyAtClass ?resourceType .
                        FILTER ((!swa:isHiddenProperty(?property)) &amp;&amp; (?property NOT IN (owl:deprecated, owl:differentFrom, rdfs:isDefinedBy, owl:sameAs, rdfs:seeAlso, rdf:value, owl:versionInfo))) .
                    }
                    ORDER BY (ui:label(?property)) }\">
                <div class=\"swa-add-property-box\" id=\"{= ?id }-div\">
                    <span>Add property: </span>
                    <select autocomplete=\"off\" id=\"{= ?id }-select\" onchange=\"if($('#{= ?id }-select').val()) { swa.addPropertyToSearchForm('{= ?id }', $('#{= ?id }-select').val()); }\">
                        <option selected=\"selected\"/>
                    </select>
                    <script>var select = $('#{= ?id }-select');
					var form = select.closest('form');
					var used = swa.getPropertiesUsedOnForm(form);<ui:forEach ui:resultSet=\"{= ?properties }\">if(!used['{= ?property }']) {
						select.append('&lt;option value=\"{= ?property }\"&gt;{= ui:label(?property) }&lt;/option&gt;');
					}</ui:forEach>if(select.children().length == 1) {
						$('#{= ?id }-div').css('display', 'none');
					}</script>
                </div>
            </ui:group>
        </ui:loadable>
    </ui:group>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A drop down box that can be placed to the end of a form body to allow users to add other properties that are not yet visible."^^xsd:string ;
  rdfs:label "Add property box"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:AllArgumentPredicates
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            rdf:type ui:label ;
            sp:arg1 [
                sp:varName "predicate"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "atClass"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "arg"^^xsd:string ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "atClass"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "arg"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:predicate spl:predicate ;
            sp:subject [
                sp:varName "arg"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the arguments of."^^xsd:string ;
    ] ;
  spin:labelTemplate "All spl:Argument predicates of {?class}"^^xsd:string ;
  rdfs:comment "Gets a list of the properties behind all spl:Arguments declared at a given class and its superclasses, sorted by their ui:labels."^^xsd:string ;
  rdfs:label "All argument predicates"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:AllInstances
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            rdf:type ui:label ;
            sp:arg1 [
                sp:varName "instance"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "instance"^^xsd:string ;
          ]
          [
            sp:varName "uri"^^xsd:string ;
          ]
          [
            sp:varName "type"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "class"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "type"^^xsd:string ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "instance"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type xsd:string ;
                sp:arg1 [
                    sp:varName "instance"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class that the instances must have."^^xsd:string ;
    ] ;
  rdfs:comment "Gets all instances of a given class, and its subclasses, and orders them by label. Note this may (obviously) not scale if a class has too many instances."^^xsd:string ;
  rdfs:label "All instances"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:AnyObjectFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:AnyFacetValue ;
  swa:objectFacetMenuName "any value"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type swa:hasMatchingRestoreFacetValue ;
          arg:facetClass swa:AnyObjectFacet ;
          arg:property [
              sp:varName "predicate"^^xsd:string ;
            ] ;
        ] ;
      swa:weight -5 ;
    ] ;
  ui:prototype """
<div class=\"swa-facet-constant\">
    <input id=\"any{= ?uid }\" name=\"any{= ?uid }\" type=\"hidden\" value=\"true\"/>
    <span>any value</span>
</div>
"""^^ui:Literal ;
  rdfs:comment "A facet representing any value for the given predicate, no matter which specific value."^^xsd:string ;
  rdfs:label "Any object facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:AnyURILiteralViewer
  rdf:type swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:isLiteral ;
              sp:arg1 [
                  sp:varName "object"^^xsd:string ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type sp:eq ;
              sp:arg1 [
                  rdf:type sp:datatype ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 xsd:anyURI ;
            ] ;
        ] ;
      swa:weight 1 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <swa:Link arg:resource=\"{= IRI(str(?object)) }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "The default viewer for xsd:anyURI values: shows a hyperlink to the URI."^^xsd:string ;
  rdfs:label "AnyURI literal viewer"^^xsd:string ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:ApplicationElements
  rdf:type ui:NodeClass ;
  ui:headIncludes """
<ui:group>
    <script src=\"{= ui:lib() }/openajax/js/OpenAjax.js\" type=\"text/javascript\"/>
    <script src=\"{= ui:lib() }/swa/js/swawindows.js\" type=\"text/javascript\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Abstract base class of elements that depend on the event hub mechanism outside of OpenSocial containers. Defines ui:headIncludes that import the relevant JavaScript libraries to set up a local event hub."^^xsd:string ;
  rdfs:label "Application elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:Applications
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:responseType ui:HTML ;
  rdfs:comment "The recommended base class for stand-alone SWA applications."^^xsd:string ;
  rdfs:label "Applications"^^xsd:string ;
  rdfs:subClassOf swa:ApplicationElements ;
.
swa:ArgumentsFormBody
  rdf:type ui:ResourceViewClass ;
  ui:prototype """
<ui:call arg:class=\"{= swa:resourceType(?resource) }\" ui:template=\"{= swa:AllArgumentPredicates }\">
    <swa:ObjectsGroup arg:label=\"Arguments\" arg:predicates=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:comment "A form body that shows all declared spl:Arguments (via spin:constraint) of the resource type. Can be used to edit SWP views, SPIN modules, SPARQLMotion functions etc."^^xsd:string ;
  rdfs:label "Arguments form body"^^xsd:string ;
  rdfs:subClassOf swa:FormBody ;
.
swa:AutoComplete
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:allowURIs ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, users are allowed to enter arbitrary (external) URIs as long as they start with http and are well-formed URIs. Note that this bypasses any testing for type-conformance and should therefore be used with care."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional CSS class that is used for the resulting text field."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional SPARQL function that takes one resource as its argument and returns true if the resource shall be included."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:filterFunctionArgument ;
      rdfs:comment "An optional second argument to the filter function."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:initialValue ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The initial resource to place into the text field."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript snippet that shall be executed when the user selects a resource."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:withSelectMenu ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to show a drop down menu at the right hand side, allowing users to open selection dialogs (e.g., faceted search) as an alternative way of populating the auto-complete."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the HTML input element."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The rdf:type of the matching resources. Will also include subclasses of that type."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:createLink arg:allowURIs=\"{= ?allowURIs }\" arg:filterFunction=\"{= ?filterFunction }\" arg:filterFunctionArgument=\"{= ?filterFunctionArgument }\" arg:type=\"{= ?type }\" ui:sendQueryGraph=\"{= true }\" ui:snippet=\"true\" ui:viewClass=\"{= swa:AutoCompleteCallback }\">
    <input id=\"{= ?id }\" name=\"{= ?id }\" type=\"hidden\" value=\"{= ui:encodeNode(?initialValue) }\"/>
    <ui:group let:displayId=\"{= ?id }-field\">
        <input class=\"swa-auto-complete {= ?class }\" id=\"{= ?displayId }\" value=\"{= ui:label(?initialValue) }\">
            <ui:if ui:condition=\"{= ?withSelectMenu }\">
                <a class=\"swa-auto-complete-select-menu swa-icon ui-icon ui-icon-triangle-1-s\" href=\"javascript:void(0)\" id=\"{= ?id }-menu\" onclick=\"{= ui:functionCall(&quot;swa.openAutoCompleteSelectMenu&quot;, ?id, ?type, swa:appName()) }\"/>
            </ui:if>
        </input>
        <swa:WidgetInitializer arg:script=\"swa.initAutoComplete('{= ?displayId }', '{= ?id }', '{= ?link }', &quot;{= ui:escapeJSON(?onSelect) }&quot;)\"/>
    </ui:group>
</ui:createLink>
"""^^ui:Literal ;
  rdfs:comment "Inserts a text field that automatically suggests matching resources as the user starts typing. Matching resources must be instances of the provided type class."^^xsd:string ;
  rdfs:label "Auto complete"^^xsd:string ;
  rdfs:subClassOf swa:AutoCompleteElements ;
.
swa:AutoCompleteCallback
  rdf:type ui:Service ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:allowURIs ;
      spl:valueType xsd:boolean ;
      rdfs:comment "See comment at swa:AutoComplete."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "The filter function (if specified) from the AutoComplete."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:filterFunctionArgument ;
      rdfs:comment "An optional node that will be passed as second argument to the filter function."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:term ;
      spl:valueType xsd:string ;
      rdfs:comment "The start of the name as entered by the user."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource to get matching instances of."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= (?allowURIs &amp;&amp; bound(?term)) &amp;&amp; spif:isValidURI(?term) }\">
        <swon:Array>
            <swon:Object>
                <swon:Value arg:name=\"editLabel\" arg:value=\"{= ?term }\"/>
                <swon:Value arg:name=\"resource\" arg:value=\"{= ?term }\"/>
                <swon:Value arg:name=\"isURI\" arg:value=\"{= true }\"/>
                <ui:if ui:condition=\"{= spl:hasValue(IRI(?term), rdf:type) }\">
                    <swon:Value arg:name=\"label\" arg:value=\"{= ?term } (typed resource: {= ui:label(IRI(?term)) })\"/>
                    <swon:Value arg:name=\"value\" arg:value=\"{= ?term } (typed resource: {= ui:label(IRI(?term)) })\"/>
                </ui:if>
                <ui:else>
                    <swon:Value arg:name=\"label\" arg:value=\"{= ?term } (untyped resource)\"/>
                    <swon:Value arg:name=\"value\" arg:value=\"{= ?term } (untyped resource)\"/>
                </ui:else>
            </swon:Object>
        </swon:Array>
    </ui:if>
    <ui:else>
        <swon:RSObjectArray arg:resultSet=\"{#
                SELECT ?resource ?label ((?label) AS ?value) ?editLabel
                WHERE {
                    ( ?type ?term ) ui:autoComplete ( ?resource ?label ?editLabel ) .
                    FILTER ((!bound(?filterFunction)) || spif:invoke(?filterFunction, ?resource, ?filterFunctionArgument)) .
                } }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "Internally used by the AutoComplete widget to fetch the matching resources."^^xsd:string ;
  rdfs:label "Auto complete callback"^^xsd:string ;
  rdfs:subClassOf swa:AutoCompleteElements ;
.
swa:AutoCompleteElements
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract base class for auto-complete elements."^^xsd:string ;
  rdfs:label "Auto complete elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:AutoCompleteSelectAction
  rdf:type rdfs:Class ;
  rdfs:comment "Class of actions that show up in the drop down menu behind an auto-complete widget."^^xsd:string ;
  rdfs:label "Auto complete select action"^^xsd:string ;
  rdfs:subClassOf swa:Action ;
.
swa:AutoCompleteSelectActions
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "group"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "actionName"^^xsd:string ;
          ]
          [
            sp:varName "actionLocalName"^^xsd:string ;
          ]
          [
            sp:varName "onSelect"^^xsd:string ;
          ]
          [
            sp:varName "enabled"^^xsd:string ;
          ]
          [
            sp:varName "group"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
          [
            sp:varName "iconClass"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                (
                  [
                    sp:object swa:AutoCompleteSelectAction ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "action"^^xsd:string ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "label"^^xsd:string ;
                      ] ;
                    sp:predicate rdfs:label ;
                    sp:subject [
                        sp:varName "action"^^xsd:string ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "condition"^^xsd:string ;
                      ] ;
                    sp:predicate arg:condition ;
                    sp:subject [
                        sp:varName "action"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type ui:encodeNode ;
                        sp:arg1 [
                            sp:varName "action"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "actionName"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type afn:localname ;
                        sp:arg1 [
                            sp:varName "action"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "actionLocalName"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type spl:object ;
                        sp:arg1 [
                            sp:varName "action"^^xsd:string ;
                          ] ;
                        sp:arg2 arg:onSelect ;
                      ] ;
                    sp:variable [
                        sp:varName "onSelectFunctionName"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:concat ;
                        sp:arg1 [
                            sp:varName "onSelectFunctionName"^^xsd:string ;
                          ] ;
                        sp:arg2 "('" ;
                        sp:arg3 [
                            sp:varName "elementId"^^xsd:string ;
                          ] ;
                        sp:arg4 "', '" ;
                        sp:arg5 [
                            rdf:type xsd:string ;
                            sp:arg1 [
                                sp:varName "type"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg6 "')" ;
                      ] ;
                    sp:variable [
                        sp:varName "onSelect"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:coalesce ;
                        sp:arg1 [
                            rdf:type spl:object ;
                            sp:arg1 [
                                sp:varName "action"^^xsd:string ;
                              ] ;
                            sp:arg2 arg:group ;
                          ] ;
                        sp:arg2 "" ;
                      ] ;
                    sp:variable [
                        sp:varName "group"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type spl:object ;
                        sp:arg1 [
                            sp:varName "action"^^xsd:string ;
                          ] ;
                        sp:arg2 arg:iconClass ;
                      ] ;
                    sp:variable [
                        sp:varName "iconClass"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type spl:object ;
                        sp:arg1 [
                            sp:varName "action"^^xsd:string ;
                          ] ;
                        sp:arg2 arg:appName ;
                      ] ;
                    sp:variable [
                        sp:varName "actionAppName"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:if ;
                        sp:arg1 [
                            rdf:type sp:bound ;
                            sp:arg1 [
                                sp:varName "actionAppName"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type swa:hasAppName ;
                            sp:arg1 [
                                sp:varName "appName"^^xsd:string ;
                              ] ;
                            sp:arg2 [
                                sp:varName "actionAppName"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg3 [
                            rdf:type sp:or ;
                            sp:arg1 [
                                rdf:type sp:not ;
                                sp:arg1 [
                                    rdf:type sp:bound ;
                                    sp:arg1 [
                                        sp:varName "appName"^^xsd:string ;
                                      ] ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                rdf:type sp:eq ;
                                sp:arg1 [
                                    sp:varName "appName"^^xsd:string ;
                                  ] ;
                                sp:arg2 "" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spin:eval ;
                      sp:arg1 [
                          sp:varName "condition"^^xsd:string ;
                        ] ;
                      sp:arg2 arg:type ;
                      sp:arg3 [
                          sp:varName "type"^^xsd:string ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "enabled"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:bound ;
                      sp:arg1 [
                          sp:varName "enabled"^^xsd:string ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The current app name."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the auto-complete element."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resources to insert."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:label "Auto-complete select actions"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:AutoCompleteSelectMenuCallback
  rdf:type ui:JSONService ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the div holding the current widget."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resources allowed"^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:call arg:elementId=\"{= ?elementId }\" arg:type=\"{= ?type }\" ui:template=\"{= swa:AutoCompleteSelectActions }\">
    <swon:RSObjectArray arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:label "Auto-complete select menu callback"^^xsd:string ;
  rdfs:subClassOf swa:MenuElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:BNodeViewer
  rdf:type swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:isBlank ;
          sp:arg1 [
              sp:varName "object"^^xsd:string ;
            ] ;
        ] ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <ui:resourceView ui:matchIds=\"label\" ui:resource=\"{= ?object }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "The default object viewer for blank nodes."^^xsd:string ;
  rdfs:label "BNode viewer"^^xsd:string ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:BNodeViewerEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:isBlank ;
          sp:arg1 [
              sp:varName "object"^^xsd:string ;
            ] ;
        ] ;
      swa:weight -10 ;
    ] ;
  ui:prototype """
<ui:setContext ui:varName=\"mode\" ui:varValue=\"view\">
    <swa:ObjectViewer ui:args=\"*\"/>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "The default editor for bnodes: a read-only display. This serves as fall-back so that users can at least delete the entry."^^xsd:string ;
  rdfs:label "BNode viewer editor"^^xsd:string ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:BooleanEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:eq ;
          sp:arg1 [
              rdf:type sp:datatype ;
              sp:arg1 [
                  sp:varName "object"^^xsd:string ;
                ] ;
            ] ;
          sp:arg2 xsd:boolean ;
        ] ;
      swa:weight 4 ;
    ] ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:eq ;
          sp:arg1 [
              sp:varName "range"^^xsd:string ;
            ] ;
          sp:arg2 xsd:boolean ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<select class=\"{= swa:testClass(?predicate) }\" name=\"new-{= ?uid }\">
    <option value=\"\"/>
    <option selected=\"{= IF((?object = false), &quot;selected&quot;, ?nothing) }\" value=\"false\">false</option>
    <option selected=\"{= IF((?object = true), &quot;selected&quot;, ?nothing) }\" value=\"true\">true</option>
</select>
"""^^ui:Literal ;
  rdfs:comment "A combo box with options empty, true, and false."^^xsd:string ;
  rdfs:label "Boolean editor"^^xsd:string ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:BooleanFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:objectFacetMenuName "boolean"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type sp:eq ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                  sp:arg2 xsd:boolean ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:hasMatchingRestoreFacetValue ;
              arg:facetClass swa:BooleanFacet ;
              arg:property [
                  sp:varName "predicate"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight 5 ;
    ] ;
  ui:prototype """
<span let:name=\"value{= ?uid }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <select class=\"{= swa:testClass(?predicate) }\" let:value=\"{= IF(bound(?restore), spl:object(?restore, search:object), ?none) }\" name=\"{= ?name }\">
        <option/>
        <option selected=\"{= IF((!?value), &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(false) }\">false</option>
        <option selected=\"{= IF(?value, &quot;selected&quot;, ?none) }\" value=\"{= ui:encodeNode(true) }\">true</option>
    </select>
</span>
"""^^ui:Literal ;
  rdfs:label "Boolean facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:BorderLayout
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "The CSS class of this element."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The HTML id of this element."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:layoutPanel ;
      spl:valueType xsd:string ;
      rdfs:comment "The position within the surrounding BorderLayout: one of \"east\", \"north\", \"west\", \"south\" or \"center\"."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:style ;
      spl:valueType xsd:string ;
      rdfs:comment "Additional CSS styles for the surrounding div element. This can be used to specify the height if this is used outside of a parent BorderLayout."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:uid=\"{= COALESCE(?id, ui:uniqueId()) }\">
    <div class=\"{= ?class }{= IF(bound(?layoutPanel), CONCAT(&quot; ui-layout-&quot;, ?layoutPanel), ?none) }\" id=\"{= ?uid }\" style=\"{= ?style }\">
        <ui:insertionPoint ui:pointId=\"1\"/>
        <ui:insertionPoint ui:pointId=\"2\"/>
        <ui:insertionPoint ui:pointId=\"3\"/>
        <ui:insertionPoint ui:pointId=\"4\"/>
        <ui:insertionPoint ui:pointId=\"5\"/>
        <script>function {= ?uid }LayoutInitHandler() {
$('#{= ?uid }').layout({
  defaults: {
applyDefaultStyles: true
  }<swa:BorderLayoutOptions arg:fixed=\"{= ?westFixed }\" arg:name=\"west\" arg:size=\"{= ?westSize }\"/>
            <swa:BorderLayoutOptions arg:fixed=\"{= ?eastFixed }\" arg:name=\"east\" arg:size=\"{= ?eastSize }\"/>
            <swa:BorderLayoutOptions arg:fixed=\"{= ?northFixed }\" arg:name=\"north\" arg:size=\"{= ?northSize }\"/>
            <swa:BorderLayoutOptions arg:fixed=\"{= ?southFixed }\" arg:name=\"south\" arg:size=\"{= ?southSize }\"/>})
};
$(document).ready(function() {
  if (!!$.prototype.layout) {
{= ?uid }LayoutInitHandler();
  }
	      });</script>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A convenience wrapper around the jQuery UI Layout for usage inside of other containers, such as the panels of a FullScreenBorderLayout."^^xsd:string ;
  rdfs:label "Border layout"^^xsd:string ;
  rdfs:subClassOf swa:AbstractBorderLayout ;
.
swa:BorderLayoutOptions
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:fixed ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make this panel not resizable."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:size ;
      spl:valueType xsd:integer ;
      rdfs:comment "The size value."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:name ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the pane, e.g. \"west\"."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?size) || bound(?fixed) }\">, {= ?name }: {<ui:if ui:condition=\"{= bound(?size) }\">size: {= ?size }</ui:if>
    <ui:if ui:condition=\"{= bound(?fixed) }\">
        <ui:if ui:condition=\"{= bound(?size) }\">,</ui:if>closable: false, pane_spacing: 0, slidable: false, spacing_open: 0, resizable: false</ui:if>
	}</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A helper to BorderLayout to conveniently set JavaScript options."^^xsd:string ;
  rdfs:label "Border layout options"^^xsd:string ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:Button
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "An extra CSS class for the button."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:disabled ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to disable the button."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:iconClass ;
      spl:valueType xsd:string ;
      rdfs:comment "The CSS class of the icon to display on the button (if any)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The HTML id of the button."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The text on the button. Optional if an icon is set."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:style ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional CSS style for the button."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "A tool tip text to appear over the button."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:onClick ;
      spl:valueType xsd:string ;
      rdfs:comment "The JavaScript code that shall be executed when clicked on."^^xsd:string ;
    ] ;
  ui:prototype """
<button class=\"swa-button {= ?class }\" disabled=\"{= IF(?disabled, &quot;disabled&quot;, ?none) }\" id=\"{= ?id }\" onclick=\"{= ?onClick }\" style=\"{= ?style }\" title=\"{= ?toolTip }\">
    <ui:if ui:condition=\"{= bound(?iconClass) }\">
        <div class=\"swa-icon swa-button-icon {= ?iconClass }\"/>
        <ui:if ui:condition=\"{= bound(?label) }\">
            <span style=\"padding-left: 20px;\">{= ?label }</span>
        </ui:if>
        <ui:else>
            <span style=\"padding-left: 11px;\">&nbsp;</span>
        </ui:else>
    </ui:if>
    <ui:else>{= ?label }</ui:else>
</button>
"""^^ui:Literal ;
  rdfs:comment "A Button with a label and an optional icon, calling some JS when clicked. It is recommended to use this for buttons in SWA applications to ensure unified look and feel."^^xsd:string ;
  rdfs:label "Button"^^xsd:string ;
  rdfs:subClassOf swa:ButtonElements ;
.
swa:ButtonElements
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Abstract base class of elements related to buttons."^^xsd:string ;
  rdfs:label "Button elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:CancelProgressCallback
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the progress cancel."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group>{= ui:cancelProgress(?id) }</ui:group>
"""^^ui:Literal ;
  rdfs:label "Cancel progress callback"^^xsd:string ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:ClassDestructor
  rdf:type swa:Destructor ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <!-- Mark all subclasses to be deletable -->
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:delete ?child .
                } .
            }
            WHERE {
                ?child (rdfs:subClassOf)* ?resource .
            } }\"/>
    <!-- Mark all superclasses to be not deletable -->
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:keep ?parent .
                } .
            }
            WHERE {
                ?resource (rdfs:subClassOf)+ ?parent .
            } }\"/>
    <!-- Unmark all deletable classes that have a surviving parent -->
    <ui:update ui:updateQuery=\"{!
            DELETE {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:delete ?child .
                } .
            }
            WHERE {
                ?child (rdfs:subClassOf)+ ?resource .
                ?child (rdfs:subClassOf)+ ?other .
                FILTER NOT EXISTS {
                    GRAPH ui:tempGraph {
                        swa:DestructorMetadata ?either ?other .
                    } .
                } .
            } }\"/>
    <!-- Delete all instances of deletable classes unless they have other types -->
    <ui:forEach ui:resultSet=\"{#
            SELECT ?instance
            WHERE {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:delete ?class .
                } .
                ?instance a ?class .
                FILTER NOT EXISTS {
                    ?instance a ?otherType .
                    FILTER NOT EXISTS {
                        GRAPH ui:tempGraph {
                            swa:DestructorMetadata swa:delete ?otherType .
                        } .
                    } .
                } .
            } }\">
        <swa:ResourceDestructor arg:resource=\"{= ?instance }\"/>
    </ui:forEach>
    <!-- Delete subject triples -->
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    ?s ?p ?o .
                } .
            }
            WHERE {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:delete ?c .
                } .
                ( ?s ?p ?o ) &lt;http://www.topbraid.org/tops#dependsOn&gt; ?c .
            } }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Deletes all triples related to the class itself, its subclasses that do not have any other surviving parents, and all instances of those classes."^^xsd:string ;
  rdfs:label "Class destructor"^^xsd:string ;
  rdfs:subClassOf swa:Destructors ;
.
swa:ClassFormBody
  rdf:type ui:ResourceViewClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group default:subject=\"{= ?resource }\">
    <ui:call arg:subject=\"{= ?resource }\" ui:template=\"{= swa:modeProperty(swa:formObjectPredicateSelectionTemplate) }\">
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isAnnotationProperty }\" arg:label=\"Annotations\" arg:predicates=\"{= ?rs }\"/>
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isClassAxiomProperty }\" arg:label=\"Class Axioms\" arg:predicates=\"{= ?rs }\"/>
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isNonClassAxiomProperty }\" arg:label=\"Properties\" arg:predicates=\"{= ?rs }\"/>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default view for rdfs:Class, with widget groups for Annotation Properties, Class Axioms and Other Properties."^^xsd:string ;
  rdfs:label "Class form body"^^xsd:string ;
  rdfs:subClassOf swa:FormBody ;
.
swa:ClassPropertyTreeChildren
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "nodeType"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "node"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
          [
            sp:varName "leaf"^^xsd:string ;
          ]
          [
            sp:varName "icon"^^xsd:string ;
          ]
          [
            sp:varName "movable"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "parent"^^xsd:string ;
                      ] ;
                    sp:predicate rdfs:subClassOf ;
                    sp:subject [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:and ;
                        sp:arg1 [
                            rdf:type sp:and ;
                            sp:arg1 [
                                rdf:type sp:isIRI ;
                                sp:arg1 [
                                    sp:varName "node"^^xsd:string ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                rdf:type sp:ne ;
                                sp:arg1 [
                                    sp:varName "node"^^xsd:string ;
                                  ] ;
                                sp:arg2 owl:Nothing ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:ne ;
                            sp:arg1 [
                                sp:varName "node"^^xsd:string ;
                              ] ;
                            sp:arg2 owl:NamedIndividual ;
                          ] ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:not ;
                        sp:arg1 [
                            rdf:type swa:classHasSubClassOrDirectRelevantProperty ;
                            arg:class [
                                sp:varName "node"^^xsd:string ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "leaf"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression "swa-icon-class" ;
                    sp:variable [
                        sp:varName "icon"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression "class" ;
                    sp:variable [
                        sp:varName "nodeType"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:not ;
                        sp:arg1 [
                            rdf:type swa:isReadOnlyTriple ;
                            sp:arg1 [
                                sp:varName "node"^^xsd:string ;
                              ] ;
                            sp:arg2 rdfs:subClassOf ;
                            sp:arg3 [
                                sp:varName "parent"^^xsd:string ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "movable"^^xsd:string ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                    sp:predicate swa:directRelevantClassOfProperty ;
                    sp:subject [
                        sp:varName "parent"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:and ;
                        sp:arg1 [
                            rdf:type sp:and ;
                            sp:arg1 [
                                rdf:type sp:and ;
                                sp:arg1 [
                                    rdf:type sp:and ;
                                    sp:arg1 [
                                        rdf:type sp:and ;
                                        sp:arg1 [
                                            rdf:type sp:and ;
                                            sp:arg1 [
                                                rdf:type sp:isIRI ;
                                                sp:arg1 [
                                                    sp:varName "node"^^xsd:string ;
                                                  ] ;
                                              ] ;
                                            sp:arg2 [
                                                rdf:type sp:ne ;
                                                sp:arg1 [
                                                    sp:varName "node"^^xsd:string ;
                                                  ] ;
                                                sp:arg2 owl:bottomDataProperty ;
                                              ] ;
                                          ] ;
                                        sp:arg2 [
                                            rdf:type sp:ne ;
                                            sp:arg1 [
                                                sp:varName "node"^^xsd:string ;
                                              ] ;
                                            sp:arg2 owl:bottomObjectProperty ;
                                          ] ;
                                      ] ;
                                    sp:arg2 [
                                        rdf:type sp:ne ;
                                        sp:arg1 [
                                            sp:varName "node"^^xsd:string ;
                                          ] ;
                                        sp:arg2 owl:differentFrom ;
                                      ] ;
                                  ] ;
                                sp:arg2 [
                                    rdf:type sp:ne ;
                                    sp:arg1 [
                                        sp:varName "node"^^xsd:string ;
                                      ] ;
                                    sp:arg2 owl:sameAs ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                rdf:type sp:ne ;
                                sp:arg1 [
                                    sp:varName "node"^^xsd:string ;
                                  ] ;
                                sp:arg2 owl:topDataProperty ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:ne ;
                            sp:arg1 [
                                sp:varName "node"^^xsd:string ;
                              ] ;
                            sp:arg2 owl:topObjectProperty ;
                          ] ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression "true"^^xsd:boolean ;
                    sp:variable [
                        sp:varName "leaf"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type swa:resourceIcon ;
                        arg:resource [
                            sp:varName "node"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "icon"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression "property" ;
                    sp:variable [
                        sp:varName "nodeType"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression "false"^^xsd:boolean ;
                    sp:variable [
                        sp:varName "movable"^^xsd:string ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "filterFunction"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type spif:invoke ;
                    sp:arg1 [
                        sp:varName "filterFunction"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "node"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers all (named) subclasses of a given parent class, using rdfs:subClassOf and all properties that are directly associated with the class via rdfs:domain."^^xsd:string ;
  rdfs:label "Class-Property tree children"^^xsd:string ;
  rdfs:subClassOf swa:TreeChildrenTemplates ;
.
swa:ClassPropertyTreeDataProvider
  rdf:type swa:TreeDataProvider ;
  arg:changeHandler "swa.handleChangeForClassPropertyTree"^^xsd:string ;
  arg:treeChildrenTemplate swa:ClassPropertyTreeChildren ;
  arg:treePathTemplate swa:ClassPropertyTreePath ;
  arg:treeRootsTemplate swa:ClassPropertyTreeRoots ;
  rdfs:comment "A data provider for a class tree that also shows properties associated with each class."^^xsd:string ;
  rdfs:label "Class-Property tree data provider"^^xsd:string ;
.
swa:ClassPropertyTreeGadget
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have buttons to create classes and properties appear under the tree."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to publish when the selected class has changed."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:rootClass ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The root class of the tree."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:dataProvider=\"{= swa:ClassPropertyTreeDataProvider }\" let:treeId=\"{= COALESCE(?treeId, ui:uniqueId()) }\">
    <div class=\"ui-layout-content\">
        <swa:Tree arg:dataProvider=\"{= ?dataProvider }\" arg:id=\"{= ?treeId }\" arg:onSelect=\"if(swa.treeResourceIsClass(resource, '{= ?treeId }')) { {= swa:publishEvent(?classSelectedEvent, &quot;resource&quot;) } }{= swa:publishEvent(?resourceSelectedEvent, &quot;resource&quot;) }\" arg:root=\"{= ?rootClass }\"/>
    </div>
    <div class=\"swa-form-footer\">
        <swa:AutoComplete arg:filterFunction=\"{= swa:filterSubclassesOfRoot }\" arg:filterFunctionArgument=\"{= ?rootClass }\" arg:id=\"classTreeAutoComplete\" arg:onSelect=\"swa.selectTreeNode('{= ?treeId }', resource, swa.queryGraphURI);\" arg:type=\"{= owl:Class }\"/>
        <ui:if ui:condition=\"{= ?editable }\">
            <div style=\"float: right\">
                <swa:CreateResourceButton arg:contextResourceGetter=\"swa.getSelectedTreeResourceOrError('{= ?treeId }', 'Error: Please select a parent class first.')\" arg:createHandler=\"{= swa:CreateClassHandler }\" arg:iconClass=\"swa-icon-class\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resourceType=\"{= owl:Class }\" arg:suppressTypeSelection=\"{= true }\"/>
                <swa:CreateResourceButton arg:contextResourceGetter=\"swa.getSelectedTreeResourceOrError('{= ?treeId }', 'Error: Please select a parent class first.')\" arg:createHandler=\"{= swa:CreatePropertyHandler }\" arg:iconClass=\"swa-icon-datatype-property\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resourceType=\"{= owl:DatatypeProperty }\" arg:resourceTypeLabel=\"Attribute (Datatype Property)\" arg:suppressTypeSelection=\"{= true }\"/>
                <swa:CreateResourceButton arg:contextResourceGetter=\"swa.getSelectedTreeResourceOrError('{= ?treeId }', 'Error: Please select a parent class first.')\" arg:createHandler=\"{= swa:CreatePropertyHandler }\" arg:iconClass=\"swa-icon-object-property\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resourceType=\"{= owl:ObjectProperty }\" arg:resourceTypeLabel=\"Relationship (Object Property)\" arg:suppressTypeSelection=\"{= true }\"/>
            </div>
        </ui:if>
    </div>
    <swa:Subscribe arg:code=\"{= spl:objectInGraph(?dataProvider, arg:changeHandler, ui:graph) }(data, '{= ?treeId }')\" arg:event=\"org.topbraid.swa.change\"/>
    <swa:Subscribe arg:code=\"swa.selectTreeNode('{= ?treeId }', data)\" arg:event=\"{= ?resourceSelectedEvent }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A gadget displaying a mixed class/property tree. The tree can publish events whenever the user selects a class or property."^^xsd:string ;
  rdfs:label "Class/property tree gadget"^^xsd:string ;
  rdfs:subClassOf swa:TreeGadgets ;
.
swa:ClassPropertyTreePath
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "path"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type spl:instanceOf ;
                    sp:arg1 [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                    sp:arg2 rdf:Property ;
                  ] ;
                sp:arg2 [
                    rdf:type swa:shortestClassPropertyTreePath ;
                    arg:property [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                    arg:root [
                        sp:varName "root"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg3 [
                    rdf:type spif:shortestObjectsPath ;
                    sp:arg1 [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                    sp:arg2 rdfs:subClassOf ;
                    sp:arg3 [
                        sp:varName "root"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "path"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Used by the class-property tree to find the shortest path to a given node."^^xsd:string ;
  rdfs:label "Class-property tree path"^^xsd:string ;
  rdfs:subClassOf swa:TreePathTemplates ;
.
swa:ClassPropertyTreeRoots
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "node"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
          [
            sp:varName "leaf"^^xsd:string ;
          ]
          [
            sp:varName "icon"^^xsd:string ;
          ]
          [
            sp:varName "movable"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    sp:varName "root"^^xsd:string ;
                  ] ;
                sp:arg2 rdfs:Resource ;
              ] ;
            sp:variable [
                sp:varName "node"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "node"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:and ;
                sp:arg1 [
                    rdf:type sp:notExists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "node"^^xsd:string ;
                            ] ;
                          sp:predicate rdfs:subClassOf ;
                          sp:subject [
                              sp:varName "child"^^xsd:string ;
                            ] ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:notExists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "property"^^xsd:string ;
                            ] ;
                          sp:predicate swa:directRelevantClassOfProperty ;
                          sp:subject [
                              sp:varName "node"^^xsd:string ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "leaf"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "swa-icon-class" ;
            sp:variable [
                sp:varName "icon"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "false"^^xsd:boolean ;
            sp:variable [
                sp:varName "movable"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers the roots of an SWA class-property tree. Unless a different root has been specified using arg:root, it will return rdfs:Resource."^^xsd:string ;
  rdfs:label "Class-Property tree roots"^^xsd:string ;
  rdfs:subClassOf swa:TreeRootsTemplates ;
.
swa:ClassTreeChildren
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "label"^^xsd:string ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "node"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
          [
            sp:varName "leaf"^^xsd:string ;
          ]
          [
            sp:varName "icon"^^xsd:string ;
          ]
          [
            sp:varName "movable"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "parent"^^xsd:string ;
              ] ;
            sp:predicate rdfs:subClassOf ;
            sp:subject [
                sp:varName "node"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:and ;
                sp:arg1 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:isIRI ;
                        sp:arg1 [
                            sp:varName "node"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:ne ;
                        sp:arg1 [
                            sp:varName "node"^^xsd:string ;
                          ] ;
                        sp:arg2 owl:Nothing ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:ne ;
                    sp:arg1 [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                    sp:arg2 owl:NamedIndividual ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "filterFunction"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type spif:invoke ;
                    sp:arg1 [
                        sp:varName "filterFunction"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "node"^^xsd:string ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject [
                          sp:varName "child"^^xsd:string ;
                        ] ;
                    ]
                  ) ;
              ] ;
            sp:variable [
                sp:varName "leaf"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "node"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "swa-icon-class" ;
            sp:variable [
                sp:varName "icon"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type swa:isReadOnlyTriple ;
                    sp:arg1 [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                    sp:arg2 rdfs:subClassOf ;
                    sp:arg3 [
                        sp:varName "parent"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "movable"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers all (named) subclasses of a given parent class, using rdfs:subClassOf."^^xsd:string ;
  rdfs:label "Class tree children"^^xsd:string ;
  rdfs:subClassOf swa:TreeChildrenTemplates ;
.
swa:ClassTreeChildrenWithCounts
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "label"^^xsd:string ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "node"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
          [
            sp:varName "leaf"^^xsd:string ;
          ]
          [
            sp:varName "icon"^^xsd:string ;
          ]
          [
            sp:varName "movable"^^xsd:string ;
          ]
          [
            sp:varName "countLabel"^^xsd:string ;
          ]
          [
            sp:varName "count"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "parent"^^xsd:string ;
              ] ;
            sp:predicate rdfs:subClassOf ;
            sp:subject [
                sp:varName "node"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:and ;
                sp:arg1 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:isIRI ;
                        sp:arg1 [
                            sp:varName "node"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:ne ;
                        sp:arg1 [
                            sp:varName "node"^^xsd:string ;
                          ] ;
                        sp:arg2 owl:Nothing ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:ne ;
                    sp:arg1 [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                    sp:arg2 owl:NamedIndividual ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "filterFunction"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type spif:invoke ;
                    sp:arg1 [
                        sp:varName "filterFunction"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "node"^^xsd:string ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject [
                          sp:varName "child"^^xsd:string ;
                        ] ;
                    ]
                  ) ;
              ] ;
            sp:variable [
                sp:varName "leaf"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "node"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type smf:countResults ;
                sp:arg1 "SELECT ?instance	WHERE {?class rdfs:subClassOf* ?node . ?instance a ?class}" ;
              ] ;
            sp:variable [
                sp:varName "count"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type fn:concat ;
                sp:arg1 [
                    sp:varName "label"^^xsd:string ;
                  ] ;
                sp:arg2 " (" ;
                sp:arg3 [
                    sp:varName "count"^^xsd:string ;
                  ] ;
                sp:arg4 ")" ;
              ] ;
            sp:variable [
                sp:varName "countLabel"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "swa-icon-class" ;
            sp:variable [
                sp:varName "icon"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type swa:isReadOnlyTriple ;
                    sp:arg1 [
                        sp:varName "node"^^xsd:string ;
                      ] ;
                    sp:arg2 rdfs:subClassOf ;
                    sp:arg3 [
                        sp:varName "parent"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "movable"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers all (named) subclasses of a given parent class, using rdfs:subClassOf."^^xsd:string ;
  rdfs:label "Class tree children with counts"^^xsd:string ;
  rdfs:subClassOf swa:TreeChildrenTemplates ;
.
swa:ClassTreeDataProvider
  rdf:type swa:TreeDataProvider ;
  arg:changeHandler "swa.handleChangeForClassTree"^^xsd:string ;
  arg:treeChildrenTemplate swa:ClassTreeChildren ;
  arg:treePathTemplate swa:ClassTreePath ;
  arg:treeRootsTemplate swa:ClassTreeRoots ;
  rdfs:comment "A data provider for a class tree starting at rdfs:Resource."^^xsd:string ;
  rdfs:label "Class tree data provider"^^xsd:string ;
.
swa:ClassTreeDataProviderWithCounts
  rdf:type swa:TreeDataProviderWithCounts ;
  arg:changeHandler "swa.handleChangeForClassTree"^^xsd:string ;
  arg:treeChildrenTemplate swa:ClassTreeChildrenWithCounts ;
  arg:treePathTemplate swa:ClassTreePath ;
  arg:treeRootsTemplate swa:ClassTreeRootsWithCounts ;
  rdfs:comment "A data provider for a class tree starting at rdfs:Resource."^^xsd:string ;
  rdfs:label "Class tree data provider with counts"^^xsd:string ;
.
swa:ClassTreeGadget
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a button to create classes appear under the tree."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:refreshEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event that causes the tree to refresh itself."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:uiElementId ;
      spl:valueType xsd:string ;
      rdfs:comment "HTML element ID for a containing element"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to publish when the selected class has changed."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:classTreeDataProvider ;
      spl:valueType swa:TreeDataProvider ;
      rdfs:comment "An optional data provider for the class tree.  If not specified, it will use swa:ClassTreeDataProvider."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:rootClass ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The root class of the tree."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:dataProvider=\"{= COALESCE(?classTreeDataProvider, swa:ClassTreeDataProvider) }\" let:treeId=\"{= COALESCE(?treeId, ui:uniqueId()) }\">
    <div class=\"ui-layout-content\">
        <swa:Tree arg:dataProvider=\"{= ?dataProvider }\" arg:id=\"{= ?treeId }\" arg:onSelect=\"{= swa:publishEvent(?classSelectedEvent, &quot;resource&quot;) }{= swa:publishEvent(?resourceSelectedEvent, &quot;resource&quot;) }\" arg:root=\"{= ?rootClass }\"/>
    </div>
    <div class=\"swa-form-footer\">
        <swa:AutoComplete arg:filterFunction=\"{= swa:filterSubclassesOfRoot }\" arg:filterFunctionArgument=\"{= ?rootClass }\" arg:id=\"classTreeAutoComplete\" arg:onSelect=\"swa.selectTreeNode('{= ?treeId }', resource, swa.queryGraphURI);\" arg:type=\"{= owl:Class }\"/>
        <ui:if ui:condition=\"{= ?editable }\">
            <div style=\"float: right\">
                <swa:CreateResourceButton arg:contextResourceGetter=\"swa.getSelectedTreeResourceOrError('{= ?treeId }', 'Error: Please select a parent class first.')\" arg:createHandler=\"{= swa:CreateClassHandler }\" arg:iconClass=\"swa-icon-class\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resourceType=\"{= owl:Class }\" arg:suppressTypeSelection=\"{= true }\"/>
            </div>
        </ui:if>
    </div>
    <swa:Subscribe arg:code=\"{= spl:objectInGraph(?dataProvider, arg:changeHandler, ui:graph) }(data, '{= ?treeId }')\" arg:event=\"org.topbraid.swa.change\" arg:uiElementId=\"{= ?uiElementId }\"/>
    <swa:Subscribe arg:code=\"swa.selectTreeNode('{= ?treeId }', data)\" arg:event=\"{= ?resourceSelectedEvent }\" arg:uiElementId=\"{= ?uiElementId }\"/>
    <ui:if ui:condition=\"{= bound(?refreshEvent) }\">
        <swa:Subscribe arg:code=\"swa.refreshTree('{= ?treeId }')\" arg:event=\"{= ?refreshEvent }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A gadget displaying a class tree. The tree can publish events whenever the user selects a class."^^xsd:string ;
  rdfs:label "Class tree gadget"^^xsd:string ;
  rdfs:subClassOf swa:TreeGadgets ;
.
swa:ClassTreePath
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "path"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:shortestObjectsPath ;
                sp:arg1 [
                    sp:varName "node"^^xsd:string ;
                  ] ;
                sp:arg2 rdfs:subClassOf ;
                sp:arg3 [
                    sp:varName "root"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "path"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Used by the class tree to find the shortest path to a given node."^^xsd:string ;
  rdfs:label "Class tree path"^^xsd:string ;
  rdfs:subClassOf swa:TreePathTemplates ;
.
swa:ClassTreeRoots
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "node"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
          [
            sp:varName "leaf"^^xsd:string ;
          ]
          [
            sp:varName "icon"^^xsd:string ;
          ]
          [
            sp:varName "movable"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    sp:varName "root"^^xsd:string ;
                  ] ;
                sp:arg2 rdfs:Resource ;
              ] ;
            sp:variable [
                sp:varName "node"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "node"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "node"^^xsd:string ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject [
                          sp:varName "child"^^xsd:string ;
                        ] ;
                    ]
                  ) ;
              ] ;
            sp:variable [
                sp:varName "leaf"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "swa-icon-class" ;
            sp:variable [
                sp:varName "icon"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "false"^^xsd:boolean ;
            sp:variable [
                sp:varName "movable"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers the roots of an SWA class tree. Unless a different root has been specified using arg:root, it will return rdfs:Resource."^^xsd:string ;
  rdfs:label "Class tree roots"^^xsd:string ;
  rdfs:subClassOf swa:TreeRootsTemplates ;
.
swa:ClassTreeRootsWithCounts
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "node"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
          [
            sp:varName "leaf"^^xsd:string ;
          ]
          [
            sp:varName "icon"^^xsd:string ;
          ]
          [
            sp:varName "movable"^^xsd:string ;
          ]
          [
            sp:varName "countLabel"^^xsd:string ;
          ]
          [
            sp:varName "count"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    sp:varName "root"^^xsd:string ;
                  ] ;
                sp:arg2 rdfs:Resource ;
              ] ;
            sp:variable [
                sp:varName "node"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "node"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "node"^^xsd:string ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject [
                          sp:varName "child"^^xsd:string ;
                        ] ;
                    ]
                  ) ;
              ] ;
            sp:variable [
                sp:varName "leaf"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type smf:countResults ;
                sp:arg1 "SELECT ?instance	WHERE {?class rdfs:subClassOf* ?node . ?instance a ?class}" ;
              ] ;
            sp:variable [
                sp:varName "count"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type fn:concat ;
                sp:arg1 [
                    sp:varName "label"^^xsd:string ;
                  ] ;
                sp:arg2 " (" ;
                sp:arg3 [
                    sp:varName "count"^^xsd:string ;
                  ] ;
                sp:arg4 ")" ;
              ] ;
            sp:variable [
                sp:varName "countLabel"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "swa-icon-class" ;
            sp:variable [
                sp:varName "icon"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression "false"^^xsd:boolean ;
            sp:variable [
                sp:varName "movable"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that delivers the roots of an SWA class tree. Unless a different root has been specified using arg:root, it will return rdfs:Resource."^^xsd:string ;
  rdfs:label "Class tree roots with counts"^^xsd:string ;
  rdfs:subClassOf swa:TreeRootsTemplates ;
.
swa:ColumnLayout
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:width ;
      spl:valueType xsd:string ;
      rdfs:comment "The total width of this layout component, e.g. \"600px\"."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:colWidths ;
      spl:valueType xsd:string ;
      rdfs:comment "A comma-separated list of width style values for each column, in CSS notation. For example \"25%,25%,50%\" will create three columns, with the third column covering 50% of the available width."^^xsd:string ;
    ] ;
  ui:prototype """
<table class=\"swa-layout-table\" style=\"{= IF(bound(?width), fn:concat(&quot;width:&quot;, ?width), ?none) }\">
    <tr>
        <ui:forEach ui:indexVar=\"index\" ui:resultSet='{#
                SELECT ?colWidth
                WHERE {
                    ?colWidth spif:split ( ?colWidths \",\" ) .
                } }'>
            <td class=\"swa-layout-td\" style=\"width:{= ?colWidth }\">
                <ui:insertionPoint ui:pointId=\"col{= ?index }\"/>
            </td>
        </ui:forEach>
    </tr>
</table>
"""^^ui:Literal ;
  rdfs:comment "A container that arranges its children into one or more column. The relative widths of each column must be specified using a comma-separated list (arg:colWidths). The immediate children of this element will be used as columns from left to right."^^xsd:string ;
  rdfs:label "Column layout"^^xsd:string ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:ConceptFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:ConceptFacetValue ;
  swa:objectFacetMenuName "equals or sub-concept"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type spl:subClassOf ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                  sp:arg2 skos:Concept ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:hasMatchingRestoreFacetValue ;
              arg:facetClass swa:ConceptFacet ;
              arg:property [
                  sp:varName "predicate"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight -2 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:restore=\"{= swa:restoreFacetValue(?predicate) }\" let:type=\"{= swa:localRangeAtClass(swa:resourceType(), ?predicate) }\">
    <span style=\"font-size: 16px;\" title=\"Equals to value or a sub-concept thereof\">&le;</span>
    <swa:AutoComplete arg:class=\"{= swa:testClass(?predicate) }\" arg:id=\"concept{= ?uid }\" arg:initialValue=\"{= IF(bound(?restore), spl:object(?restore, search:rootConcept), ?none) }\" arg:type=\"{= IF((bound(?type) &amp;&amp; isBlank(?type)), skos:Concept, ?type) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A facet for SKOS concepts, displaying an AutoComplete."^^xsd:string ;
  rdfs:label "Concept facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:ConfirmDeleteResourceHandler
  rdf:type ui:Service ;
  ui:prototype """
<ui:group>
    <swa:ResourceDestructor arg:resource=\"{= ?resource }\"/>
    <swon:RSObject arg:resultSet='{#
            SELECT ?message ?tripleCount
            WHERE {
                {
                    SELECT ((COUNT(?s)) AS ?tripleCount)
                    WHERE {
                        GRAPH ui:tempGraph {
                            ?s ?p ?o .
                            FILTER (?s != swa:DestructorMetadata) .
                        } .
                    }
                } .
                BIND (fn:concat(\"Are you sure you want to delete \", ui:label(?resource), \"?\") AS ?message) .
            } }'/>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment """Called to pre-compute which triples would need to be deleted to delete a given resource. Returns a JSON object such as

{
	\"message\" : \"Are you sure you want to delete XY?\",
	\"tripleCount : 102
}"""^^xsd:string ;
  rdfs:label "Confirm delete resource handler"^^xsd:string ;
  rdfs:subClassOf swa:DestructorElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:CreateCallFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Abstract base class for functions that produce a JavaScript call, e.g. to be used as event handlers."^^xsd:string ;
  rdfs:label "Create call functions"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:CreateClassHandler
  rdf:type ui:NodeClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Create {= ui:label(?resourceType) } with URI {= ?uri }\" ui:metadata=\"{= ?metadata }\">
    <ui:preCondition ui:errorMessage=\"{= COALESCE(swa:labelExistsPreCondition(?label), swa:validURIPreCondition(?uri), swa:unusedURIPreCondition(IRI(str(?uri)))) }\">
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?class a ?resourceType .
                    ?class rdfs:label ?prefLabel .
                    ?class rdfs:subClassOf ?contextResource .
                }
                WHERE {
                    BIND (IRI(str(?uri)) AS ?class) .
                    BIND (IF(bound(?labelLang), STRLANG(?label, ?labelLang), ?label) AS ?prefLabel) .
                } }\"/>
    </ui:preCondition>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:comment "The Updates that need to happen to create a new class."^^xsd:string ;
  rdfs:label "Create class handler"^^xsd:string ;
  rdfs:subClassOf swa:CreateHandlers ;
.
swa:CreateForm
  rdf:type swa:FormClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resourceURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI of the new resource. If left blank then the form will include an edit field for the URI."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the form (needed for the JavaScript form submission)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The rdf:type of the instance to create."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:setContext ui:varName=\"mode\" ui:varValue=\"edit\">
    <form autocomplete=\"off\" class=\"swa-form\" id=\"{= ?formId }\">
        <input name=\"_base\" type=\"hidden\" value=\"{= swa:dataGraph() }\"/>
        <input name=\"resourceType\" type=\"hidden\" value=\"{= ?resourceType }\"/>
        <div class=\"swa-form-body\">
            <ui:if ui:condition=\"{= bound(?resourceURI) }\">
                <input name=\"resourceURI\" type=\"hidden\" value=\"{= ?resourceURI }\"/>
            </ui:if>
            <ui:else>
                <swa:URIField arg:resourceType=\"{= ?resourceType }\" arg:resourceURI=\"{= ?resourceURI }\"/>
            </ui:else>
            <ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= ?resourceType }\">
                <ui:classView ui:class=\"{= ?resourceType }\" ui:matchIds=\"create,edit,form\"/>
            </ui:setContext>
        </div>
    </form>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "A form that can be used to edit a new instance of a given class."^^xsd:string ;
  rdfs:label "Create form"^^xsd:string ;
  rdfs:subClassOf swa:Form ;
.
swa:CreateHandlers
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:contextResource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional context resource that is needed by some CreateHandlers. Examples include the superclass of a class and the parent concept of a skos:Concept."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The preferred label."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:labelLang ;
      spl:valueType xsd:string ;
      rdfs:comment "The language of the label."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:metadata ;
      spl:valueType xsd:string ;
      rdfs:comment "The metadata string to pass into the transaction."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the new resource (e.g. owl:Class)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uri ;
      spl:valueType xsd:string ;
      rdfs:comment "The uri of the new resource."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract superclass of the handlers of create buttons. Use the provided subclasses as examples and note how they wrap the update into a transaction including its metadata."^^xsd:string ;
  rdfs:label "Create handlers"^^xsd:string ;
  rdfs:subClassOf swa:EditHandlers ;
.
swa:CreateLinkFunctions
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI resource to link to."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid of the link element - this can be used to learn more about the neighborhood of the link."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Abstract superclass for functions that take a URI resource and produce a JavaScript snippet that acts like a hyperlink for it. All link creation by widgets should run through one of those functions. If no function is called directly, then swa:createLink should be used which will find the most suitable link function for the given context.

For example, hyperlinks on a view form should replace the view form with a form for the selected resource. The form sets a context variable 'createLinkFunction' that points to a function that will replace the whole form after an ajax request."""^^xsd:string ;
  rdfs:label "Create link functions"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:CreatePropertyHandler
  rdf:type ui:NodeClass ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Create {= ui:label(?resourceType) } with URI {= ?uri }\" ui:metadata=\"{= ?metadata }\">
    <ui:preCondition ui:errorMessage=\"{= COALESCE(swa:labelExistsPreCondition(?label), swa:validURIPreCondition(?uri), swa:unusedURIPreCondition(IRI(str(?uri)))) }\">
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?property a ?resourceType .
                    ?property rdfs:label ?prefLabel .
                    ?property rdfs:domain ?realDomainClass .
                }
                WHERE {
                    BIND (IRI(str(?uri)) AS ?property) .
                    BIND (IF(bound(?labelLang), STRLANG(?label, ?labelLang), ?label) AS ?prefLabel) .
                    BIND (IF(spl:instanceOf(?contextResource, rdfs:Class), ?contextResource, spl:object(?contextResource, rdfs:domain)) AS ?realDomainClass) .
                } }\"/>
    </ui:preCondition>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:comment "Creates a new property. The ?resourceType should be something like owl:DatatypeProperty or owl:ObjectProperty and the ?contextResource must point to either a class or a property that has an rdfs:domain."^^xsd:string ;
  rdfs:label "Create property handler"^^xsd:string ;
  rdfs:subClassOf swa:CreateHandlers ;
.
swa:CreateResourceButton
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:contextResourceGetter ;
      spl:valueType xsd:string ;
      rdfs:comment "A JS expression that delivers the (optional) context resource that will be passed into the create dialog and handler. For example this may be a JavaScript function call that delivers the currently selected class or parent in a tree."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to fire if the new resource has been created."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resourceTypeLabel ;
      spl:valueType xsd:string ;
      rdfs:comment "A label describing the resource that will be created, e.g. \"Concept\" or \"Class\". Will be inserted into the button's tool tip. If left blank, the ui:label of the ?resourceType will be used."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressTypeSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to disallow selecting the subclasses of the resource type (even if a subclass exists)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:createHandler ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "The handler to call for actual creation - must be a subclass of swa:CreateHandlers."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:iconClass ;
      spl:valueType xsd:string ;
      rdfs:comment "The CSS class for the icon."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource to create."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\" let:typeLabel=\"{= COALESCE(?resourceTypeLabel, ui:label(?resourceType)) }\">
    <swa:Button arg:iconClass=\"{= ?iconClass }\" arg:id=\"{= ?id }\" arg:onClick=\"swa.openCreateResourceDialog('create-{= ?id }-dialog', {= COALESCE(?contextResourceGetter, false) })\" arg:toolTip=\"Create {= ?typeLabel }...\"/>
    <ui:group let:loadId=\"create-{= ?id }-dialog\">
        <ui:loadable style=\"float: left\" ui:loadId=\"{= ?loadId }\" ui:loadOnDemand=\"{= true }\">
            <swa:CreateResourceDialog arg:callback=\"swa.createResource\" arg:contextResourceGetter=\"{= ?contextResourceGetter }\" arg:createHandler=\"{= ?createHandler }\" arg:label=\"Create {= ?typeLabel }\" arg:loadId=\"{= ?loadId }\" arg:resourceSelectedEvent=\"{= ?resourceSelectedEvent }\" arg:resourceType=\"{= ?resourceType }\" arg:suppressTypeSelection=\"{= ?suppressTypeSelection }\"/>
        </ui:loadable>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A button that opens a dialog to create a resource. Once the dialog is done, the new resource will be \"selected\" by issuing an event."^^xsd:string ;
  rdfs:label "Create resource button"^^xsd:string ;
  rdfs:subClassOf swa:ButtonElements ;
.
swa:CreateResourceDialog
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:contextResourceGetter ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript expression that delivers the URI of a context resource."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:createHandler ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "A subclass of swa:CreateResourceHandler that shall be called when the dialog completes. This only needs to be specified if the callback is the default function swa.createResource()."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional label to override the default label \"Create <label-of-type>\"."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional event that shall be published after the new resource has been created. The payload of this event will be the new URI."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressTypeSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the type selection box."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:callback ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function that shall be called if the user Oks the dialog. This must take arguments as: function(typeURI, resourceURI, label, labelLang) where label and labelLang are optional."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the resulting ui:loadable."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource to create. If the type has subclasses, then a drop down box is displaying those alternatives."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div id=\"div-{= ?loadId }\" title=\"{= COALESCE(?label, CONCAT(&quot;Create &quot;, ui:label(?resourceType))) }\">
    <swa:LabeledElement arg:label=\"Label:\">
        <input id=\"label-input\" style=\"width: 340px\" type=\"text\"/>
        <script>swa.initCreateResourceLabelField('label-input', 'uri-field')</script>
        <swa:LangSelector arg:uid=\"lang\"/>
    </swa:LabeledElement>
    <swa:URIField arg:resourceType=\"{= ?resourceType }\"/>
    <ui:if ui:condition=\"{= ((!bound(?suppressTypeSelection)) || (!?suppressTypeSelection)) &amp;&amp; spl:hasValue(?any, rdfs:subClassOf, ?resourceType) }\">
        <swa:LabeledElement arg:label=\"Type:\">
            <select autocomplete=\"off\" id=\"type-select\">
                <ui:forEach ui:resultSet=\"{#
                        SELECT DISTINCT ?resourceLabel ?class
                        WHERE {
                            ?class (rdfs:subClassOf)* ?resourceType .
                            BIND (ui:label(?class) AS ?resourceLabel) .
                        }
                        ORDER BY (?resourceLabel) }\">
                    <option selected=\"{= IF((?resourceType = ?class), &quot;selected&quot;, ?none) }\" value=\"{= ?class }\">{= ?resourceLabel }</option>
                </ui:forEach>
            </select>
        </swa:LabeledElement>
    </ui:if>
    <ui:else>
        <input id=\"type-select\" type=\"hidden\" value=\"{= ?resourceType }\"/>
    </ui:else>
    <div class=\"swa-dialog-button-bar\">
        <button id=\"createResourceDialogOkButton\" onclick=\"{= ?callback }($('#type-select').val(), $('#uri-input').val(), $('#label-input').val(), $('#lang-lang').val(), {= COALESCE(?contextResourceGetter, &quot;null&quot;) }, {= IF(bound(?createHandler), CONCAT(&quot;'&quot;, xsd:string(?createHandler), &quot;'&quot;), &quot;null&quot;) }, {= IF(bound(?resourceSelectedEvent), CONCAT(&quot;'&quot;, ?resourceSelectedEvent, &quot;'&quot;), &quot;null&quot;) });swa.closeDialog('{= ?loadId }');\">OK</button>
        <button onclick=\"swa.closeDialog('{= ?loadId }')\">Cancel</button>
    </div>
</div>
"""^^ui:Literal ;
  rdfs:comment "A dialog that can be used to create a new instance of a given class. The dialog presents input fields for the new URI, the label and a select box for the type, if subclasses exist."^^xsd:string ;
  rdfs:label "Create resource dialog"^^xsd:string ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:CreateResourceHandler
  rdf:type ui:NodeClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:transaction ui:logMessage=\"Create {= ui:label(?resourceType) } with URI {= ?uri }\" ui:metadata=\"{= ?metadata }\">
    <ui:preCondition ui:errorMessage=\"{= COALESCE(swa:labelExistsPreCondition(?label), swa:validURIPreCondition(?uri), swa:unusedURIPreCondition(IRI(str(?uri)))) }\">
        <ui:update ui:updateQuery=\"{!
                INSERT {
                    ?class a ?resourceType .
                    ?class rdfs:label ?prefLabel .
                }
                WHERE {
                    BIND (IRI(str(?uri)) AS ?class) .
                    BIND (IF(bound(?labelLang), STRLANG(?label, ?labelLang), ?label) AS ?prefLabel) .
                } }\"/>
    </ui:preCondition>
</ui:transaction>
"""^^ui:Literal ;
  rdfs:comment "The updates that need to happen to create a new resource with a given type."^^xsd:string ;
  rdfs:label "Create resource handler"^^xsd:string ;
  rdfs:subClassOf swa:CreateHandlers ;
.
swa:DataViewsForResource
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "viewLabel"^^xsd:string ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "view"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "type"^^xsd:string ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "class"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "type"^^xsd:string ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "view"^^xsd:string ;
                      ] ;
                    sp:predicate ui:dataView ;
                    sp:subject [
                        sp:varName "class"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type spl:object ;
                        sp:arg1 [
                            sp:varName "view"^^xsd:string ;
                          ] ;
                        sp:arg2 arg:condition ;
                      ] ;
                    sp:variable [
                        sp:varName "condition"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:or ;
                        sp:arg1 [
                            rdf:type sp:not ;
                            sp:arg1 [
                                rdf:type sp:bound ;
                                sp:arg1 [
                                    sp:varName "condition"^^xsd:string ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type spin:eval ;
                            sp:arg1 [
                                sp:varName "condition"^^xsd:string ;
                              ] ;
                            sp:arg2 arg:this ;
                            sp:arg3 [
                                sp:varName "resource"^^xsd:string ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type ui:label ;
                      sp:arg1 [
                          sp:varName "view"^^xsd:string ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "viewLabel"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the reports of."^^xsd:string ;
    ] ;
  rdfs:comment "Gets all SWP views marked with ui:id=\"data\" for a given resource."^^xsd:string ;
  rdfs:label "Data views for resource"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:DataViewsSection
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The title of the section."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display the reports for."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= swa:isViewMode() }\">
    <ui:call arg:resource=\"{= ?resource }\" ui:template=\"{= swa:DataViewsForResource }\">
        <ui:if ui:condition=\"{= !spr:isEmpty(?rs) }\">
            <div class=\"swa-sub-title\">{= COALESCE(?label, \"Data Views\") }</div>
            <ui:forEach ui:resultSet=\"{= ?rs }\">
                <ui:group let:id=\"{= ui:uniqueId() }\">
                    <div class=\"swa-data-view-header\">
                        <ui:setContext ui:queryGraph=\"{= ui:unionGraph }\">
                            <b>{= ui:label(spl:object(?view, arg:dataProvider)) }</b>
                            <swa:Space/>
                            <swa:Space/>
                            <swa:Space/>
                            <a href=\"javascript:void(0)\" id=\"{= ?id }-a\" onclick=\"swa.load('{= ?id }', {load: true});$('#{= ?id }-a').attr('href', null);\">({= ui:label(spl:object(?view, rdf:type)) })</a>
                        </ui:setContext>
                    </div>
                    <ui:loadable class=\"swa-data-view\" ui:loadId=\"{= ?id }\">
                        <ui:if ui:condition=\"{= bound(?load) }\">
                            <ui:dynamicView ui:instance=\"{= ?view }\"/>
                        </ui:if>
                    </ui:loadable>
                </ui:group>
            </ui:forEach>
        </ui:if>
    </ui:call>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A section on a resource form that displays all \"data views\" available for the current resource. A data view is an intance view with ui:id=\"data\". If any such view is found, and the form is in view mode, then the form will provide expandable blocks to quickly open up those views."^^xsd:string ;
  rdfs:label "Data views section"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:DatatypeEnumDropDownEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:bound ;
              sp:arg1 [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:isDatatypeEnumeration ;
              arg:resource [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  ui:prototype """
<swa:AbstractEnumDropDownEditor ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Datatype enum drop down editor"^^xsd:string ;
  rdfs:subClassOf swa:AbstractEnumDropDownEditor ;
.
swa:DatatypeEnumDropDownFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:objectFacetMenuName "drop down list"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:bound ;
              sp:arg1 [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:isDatatypeEnumeration ;
              arg:resource [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight 2 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<swa:AbstractEnumDropDownFacet ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Datatype enum drop down facet"^^xsd:string ;
  rdfs:subClassOf swa:AbstractEnumDropDownFacet ;
.
swa:DatatypeEnumRadioButtonsEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:bound ;
              sp:arg1 [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:isDatatypeEnumeration ;
              arg:resource [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight 2 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<swa:AbstractRadioButtonsEditor ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Datatype enum radio buttons editor"^^xsd:string ;
  rdfs:subClassOf swa:AbstractRadioButtonsEditor ;
.
swa:DateEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:eq ;
          sp:arg1 [
              rdf:type sp:datatype ;
              sp:arg1 [
                  sp:varName "object"^^xsd:string ;
                ] ;
            ] ;
          sp:arg2 xsd:date ;
        ] ;
      swa:weight 5 ;
    ] ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:eq ;
          sp:arg1 [
              sp:varName "range"^^xsd:string ;
            ] ;
          sp:arg2 xsd:date ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <swa:ObjectEditorHiddenDatatypeField arg:datatype=\"{= xsd:date }\" arg:uid=\"{= ?uid }\"/>
    <input id=\"dateEditor{= ?uid }\" size=\"10\" type=\"text\" value=\"{= ?object }\"/>
    <input id=\"new-{= ?uid }\" name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ?object }\"/>
    <swa:WidgetInitializer arg:script=\"swa.initDatePicker('{= ?uid }')\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Date editor"^^xsd:string ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:DateRangeFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:RangeFacetValue ;
  swa:objectFacetMenuName "min/max range"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type sp:or ;
                  sp:arg1 [
                      rdf:type sp:eq ;
                      sp:arg1 [
                          sp:varName "range"^^xsd:string ;
                        ] ;
                      sp:arg2 xsd:date ;
                    ] ;
                  sp:arg2 [
                      rdf:type sp:eq ;
                      sp:arg1 [
                          sp:varName "range"^^xsd:string ;
                        ] ;
                      sp:arg2 xsd:dateTime ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:hasMatchingRestoreFacetValue ;
              arg:facetClass swa:DateRangeFacet ;
              arg:property [
                  sp:varName "predicate"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight 5 ;
    ] ;
  ui:prototype """
<span let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <ui:group let:max=\"{= IF(bound(?restore), spl:object(?restore, search:max), ?none) }\" let:min=\"{= IF(bound(?restore), spl:object(?restore, search:min), ?none) }\">
        <input class=\"{= swa:testClass(?predicate) }-min\" id=\"dateEditor{= ?uid }Min\" size=\"10\" type=\"text\" value=\"{= ?min }\"/>
        <span> - </span>
        <input class=\"{= swa:testClass(?predicate) }-max\" id=\"dateEditor{= ?uid }Max\" size=\"10\" type=\"text\" value=\"{= ?max }\"/>
        <input id=\"min{= ?uid }\" name=\"min{= ?uid }\" type=\"hidden\" value=\"{= ?min }\"/>
        <input id=\"max{= ?uid }\" name=\"max{= ?uid }\" type=\"hidden\" value=\"{= ?max }\"/>
        <input id=\"datatype{= ?uid }\" name=\"datatype{= ?uid }\" type=\"hidden\" value=\"{= xsd:date }\"/>
        <script>swa.initDatePicker('{= ?uid }Min', 'min{= ?uid }');
		swa.initDatePicker('{= ?uid }Max', 'max{= ?uid }');</script>
    </ui:group>
</span>
"""^^ui:Literal ;
  rdfs:label "Date range facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:DefaultDestructor
  rdf:type swa:Destructor ;
  ui:prototype """
<ui:group>
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    ?s ?p ?o .
                } .
            }
            WHERE {
                ( ?s ?p ?o ) &lt;http://www.topbraid.org/tops#dependsOn&gt; ?resource .
            } }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default destructor of a resource deletes all triples that depend on the resource, including depending blank nodes."^^xsd:string ;
  rdfs:label "Default destructor"^^xsd:string ;
  rdfs:subClassOf swa:Destructors ;
.
swa:DefaultHeaderLabelFunction
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    rdf:type swa:resourceType ;
                    arg:resource [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "typeLabel"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 [
                    rdf:type ui:label ;
                    sp:arg1 [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 "  (" ;
                sp:arg3 [
                    sp:varName "typeLabel"^^xsd:string ;
                  ] ;
                sp:arg4 ")" ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "The default header label function, displaying the ui:label of the resource and the label of the rdf:type in parantheses."^^xsd:string ;
  rdfs:label "Default header label function"^^xsd:string ;
  rdfs:subClassOf swa:HeaderLabelFunctions ;
.
swa:DefaultObjectWidgetMiddleColumn
  rdf:type swa:ObjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\">
    <span class=\"swa-icon\" id=\"error-{= ?predicate }\"/>
</td>
"""^^ui:Literal ;
  rdfs:label "Default object widget middle column"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidgetMiddleColumn ;
.
swa:DefaultObjectsBody
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:offset ;
      spl:valueType xsd:integer ;
      rdfs:comment "The offset for the \"next 50\" recursive calls."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= bound(?subject) }\">
        <ui:call arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" let:special=\"{= swa:specialAddButtonFunction(?predicate, ?subject) }\" ui:template=\"{= swa:SortedObjects }\">
            <ui:if ui:condition=\"{= ((spr:isEmpty(?rs) &amp;&amp; (!swa:isViewMode())) &amp;&amp; (!bound(?special))) &amp;&amp; (!swa:isBlankNodeProperty(?predicate)) }\">
                <div class=\"swa-object-row\">
                    <swa:ObjectWidgetRow arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\"/>
                </div>
            </ui:if>
            <ui:else>
                <ui:group let:limit=\"{= 50 }\" let:offset=\"{= COALESCE(?offset, 0) }\">
                    <ui:forEach ui:limit=\"{= ?limit }\" ui:offset=\"{= ?offset }\" ui:resultSet=\"{= ?rs }\">
                        <div class=\"swa-object-row\">
                            <swa:ObjectWidgetRow arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\"/>
                        </div>
                    </ui:forEach>
                    <ui:group let:id=\"{= ui:uniqueId() }\" let:rowCount=\"{= spr:rowCount(?rs) }\">
                        <ui:loadable ui:loadId=\"{= ?id }\">
                            <ui:if ui:condition=\"{= ?rowCount &gt; (?offset + ?limit) }\">
                                <ui:if ui:condition=\"{= bound(?newOffset) }\">
                                    <swa:DefaultObjectsBody arg:offset=\"{= ?newOffset }\" ui:args=\"*\"/>
                                </ui:if>
                                <ui:else>
                                    <div class=\"swa-objects-show-more\">
                                        <a href=\"javascript:void(0)\" onclick=\"swa.load('{= ?id }', { newOffset: {= ?offset + ?limit } })\">Show entries {= (?offset + ?limit) + 1 } to {= spl:min(?rowCount, ((?offset + ?limit) + ?limit)) } of {= ?rowCount }</a>
                                    </div>
                                </ui:else>
                            </ui:if>
                        </ui:loadable>
                    </ui:group>
                </ui:group>
            </ui:else>
        </ui:call>
    </ui:if>
    <ui:else>
        <div class=\"swa-object-row\">
            <swa:ObjectWidgetRow arg:predicate=\"{= ?predicate }\"/>
        </div>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default implementation of swa:ObjectsBody, containing one row for each value."^^xsd:string ;
  rdfs:label "Default objects body"^^xsd:string ;
  rdfs:subClassOf swa:ObjectsBody ;
.
swa:DefaultSubjectWidgetMiddleColumn
  rdf:type swa:SubjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\">
    <span class=\"swa-icon\" id=\"error-{= ?predicate }\"/>
</td>
"""^^ui:Literal ;
  rdfs:label "Default subject widget middle column"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidgetMiddleColumn ;
.
swa:DeleteResourceAction
  rdf:type swa:ResourceAction ;
  arg:appName "Editor"^^xsd:string ;
  arg:condition [
      rdf:type sp:not ;
      sp:arg1 [
          rdf:type swa:hasReadOnlyTripleInCurrentQueryGraph ;
          arg:resource [
              sp:varName "resource"^^xsd:string ;
            ] ;
        ] ;
    ] ;
  arg:group "zzz"^^xsd:string ;
  arg:iconClass "delete"^^xsd:string ;
  arg:onSelect "swa.deleteResource(resourceURI)"^^xsd:string ;
  rdfs:comment "Displays a confirm dialog and then deletes the given resource. This uses a fairly flexible architecture under the hood, to determine which Updates need to be performed when the resource is deleted. If you want to modify the default behavior, use the property swa:deleteResourceHandler to attach a different handler to your class."^^xsd:string ;
  rdfs:label "Delete..."^^xsd:string ;
.
swa:DeleteResourceHandler
  rdf:type swa:EditHandlerClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <swa:ResourceDestructor arg:resource=\"{= ?resource }\"/>
    <ui:transaction ui:logMessage=\"Delete {= ui:label(?resource) }\">
        <ui:update ui:updateQuery=\"{!
                DELETE {
                    ?s ?p ?o .
                }
                WHERE {
                    GRAPH ui:tempGraph {
                        ?s ?p ?o .
                    } .
                    FILTER (?s != swa:DestructorMetadata) .
                } }\"/>
    </ui:transaction>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment "The handler of the Delete button under the Resource form. This is executes collects all triples that need to be deleted using the destructors framework, and then deletes those."^^xsd:string ;
  rdfs:label "Delete resource handler"^^xsd:string ;
  rdfs:subClassOf swa:DestructorElements ;
  rdfs:subClassOf swa:EditHandlers ;
.
swa:DeleteSessionGraphService
  rdf:type ui:Service ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:sessionGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The session graph to delete."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:dummy=\"{= ui:deleteSessionGraph(?sessionGraph) }\"/>
"""^^ui:Literal ;
  ui:responseType ui:TEXT ;
  rdfs:label "Delete session graph service"^^xsd:string ;
  rdfs:subClassOf ui:Services ;
.
swa:Destructor
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass of swa:Destructors."^^xsd:string ;
  rdfs:label "Destructor"^^xsd:string ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:DestructorElements
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to delete."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract superclass to group all elements related to deleting resources."^^xsd:string ;
  rdfs:label "Destructor elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:DestructorMetadata
  rdf:type rdfs:Resource ;
  rdfs:comment "A marker URI used by destructors to distinguish triples that are metadata and not actually deletable triples. Should be used as subject of those triples."^^xsd:string ;
  rdfs:label "Destructor metadata"^^xsd:string ;
.
swa:Destructors
  rdf:type swa:Destructor ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment """Superclass to group all elements that deliver all triples that need to be deleted if a given resource is to be deleted. These destructors should not create any output, but only run ui:updates to add all triples that shall be deleted to ui:tempGraph. While doing so, they may recursively insert other swa:Destructors using the swa:ResourceDestructor element on \"depending\" resources, e.g. if subclasses of a given class shall also be deleted.

The property ui:instanceView and ui:id=\"destructor\" should be used to link a class with its most suitable swa:Destructor. The swa:DefaultDestructor simply deletes all triples that mention the resource as subject, predicate or object.

Destructors can be used by delete operations - to either execute the deletion, to figure out whether a resource can be deleted, or simply to display \"depending\" triples so that the user can see dependencies within a model."""^^xsd:string ;
  rdfs:label "Destructors"^^xsd:string ;
  rdfs:subClassOf swa:DestructorElements ;
.
swa:DialogElements
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:responseType ui:HTML ;
  rdfs:comment "Abstract superclass for dialog-related elements."^^xsd:string ;
  rdfs:label "Dialog elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:EditHandlerClass
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass of swa:EditHandlers. Makes the swa:confirmHandler show up on their forms."^^xsd:string ;
  rdfs:label "Edit handler class"^^xsd:string ;
  rdfs:subClassOf ui:Service ;
.
swa:EditHandlers
  rdf:type swa:EditHandlerClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "An abstract element that should be used to group together edit handlers that are called by the client to perform updates. Those services should create a ui:transaction and within it ui:updates. The EVN/Teamwork platform is currently the only officially supported mode of this, and the JSON response is automatically created by the ui:transaction."^^xsd:string ;
  rdfs:label "Edit handlers"^^xsd:string ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:EditMode
  rdf:type swa:Mode ;
  swa:formObjectPredicateSelectionTemplate swa:SuitableObjectPredicates ;
  swa:isSingleFunction swa:isSingle ;
  swa:modeLabel "Edit&nbsp;"^^xsd:string ;
  swa:modeName "edit"^^xsd:string ;
  swa:objectWidgetClass swa:ObjectEditor ;
  swa:objectWidgetMiddleColumnClass swa:EditWidgetMiddleColumn ;
  swa:objectWidgetRowClass swa:ObjectEditorRow ;
  swa:subjectWidgetMiddleColumnClass swa:SubjectEditWidgetMiddleColumn ;
  swa:subjectWidgetRowClass swa:SubjectEditorRow ;
  rdfs:label "Edit mode"^^xsd:string ;
.
swa:EditSearchResultsAction
  rdf:type swa:SearchResultsAction ;
  arg:condition [
      rdf:type sp:if ;
      sp:arg1 [
          rdf:type swa:hasAppName ;
          sp:arg1 [
              sp:varName "appName"^^xsd:string ;
            ] ;
          sp:arg2 "Editor" ;
        ] ;
      sp:arg2 "true"^^xsd:boolean ;
      sp:arg3 [
          sp:varName "none"^^xsd:string ;
        ] ;
    ] ;
  arg:onSelect "swa.openMultiResourceEditDialog(formId, 'multiResourceEditDialog')"^^xsd:string ;
  rdfs:label "Batch edit search results..."^^xsd:string ;
.
swa:EditWidgetMiddleColumn
  rdf:type swa:ObjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\">
    <div class=\"{= IF(((?single || swa:isSingle(?predicate, ?subject)) &amp;&amp; (!swa:isBlankNodeProperty(?predicate))), &quot;swa-display-none&quot;, &quot; swa-icon&quot;) } swa-add-button-div\" id=\"error-{= ?predicate }\">
        <a class=\"swa-add-row-button\" href=\"javascript:void(0)\" onclick=\"{= ui:functionCall(COALESCE(swa:specialAddButtonFunction(?predicate, ?subject), IF(swa:isBlankNodeProperty(?predicate), &quot;swa.addBlankNodeObjectEditorRow&quot;, &quot;swa.addObjectEditorRow&quot;)), ui:currentQueryGraph(), CONCAT(?uid, &quot;-body&quot;), (?single = true), ?subject, ?predicate, COALESCE(swa:appName(), &quot;&quot;), ?editWidget) }\"/>
    </div>
</td>
"""^^ui:Literal ;
  rdfs:label "Edit widget middle column"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidgetMiddleColumn ;
.
swa:Elements
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:headIncludes """
<ui:group>
    <link href=\"{= ui:lib() }/swa/css/swa.css\" rel=\"stylesheet\" type=\"text/css\"/>
    <link href=\"{= ui:lib() }/jquery/css/smoothness/jquery-ui.css\" rel=\"stylesheet\" type=\"text/css\"/>
    <link href=\"{= ui:lib() }/jquery/css/jquery.contextmenu.css\" rel=\"stylesheet\" type=\"text/css\"/>
    <link href=\"{= ui:lib() }/jquery/css/ui.jqgrid.css\" rel=\"stylesheet\" type=\"text/css\"/>
    <script src=\"{= ui:lib() }/jquery/js/jquery.js\" type=\"text/javascript\"/>
    <script src=\"{= ui:lib() }/jquery/js/jquery-ui.js\" type=\"text/javascript\"/>
    <script src=\"{= ui:lib() }/jquery/js/i18n/grid.locale-en.js\" type=\"text/javascript\"/>
    <script src=\"{= ui:lib() }/jquery/js/jquery.jqGrid.min.js\" type=\"text/javascript\"/>
    <script src=\"{= ui:lib() }/jquery/js/jquery.contextmenu.js\" type=\"text/javascript\"/>
    <script src=\"{= ui:lib() }/jquery/js/jquery.cookie.js\" type=\"text/javascript\"/>
    <script src=\"{= ui:lib() }/jquery/js/jquery.hotkeys.js\" type=\"text/javascript\"/>
    <script src=\"{= ui:lib() }/jquery/js/jquery.layout.js\" type=\"text/javascript\"/>
    <script src=\"{= ui:lib() }/jquery/js/jquery.jstree.js\" type=\"text/javascript\"/>
    <script src=\"{= ui:lib() }/swa/js/swa.js\" type=\"text/javascript\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Abstract superclass of all SWA elements. Makes sure that certain required head includes (JavaScript and CSS files) are present."^^xsd:string ;
  rdfs:label "Elements"^^xsd:string ;
  rdfs:subClassOf ui:ViewElements ;
.
swa:EmptyTemplate
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "dummy"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression "false"^^xsd:boolean ;
          ]
        ) ;
    ] ;
  rdfs:comment "A template that can be used to represent an empty result set with one column but now rows, if a reference to a template is needed."^^xsd:string ;
  rdfs:label "Empty template"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ExactMatchStringFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:objectFacetMenuName "text equals"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:or ;
              sp:arg1 [
                  rdf:type sp:eq ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                  sp:arg2 xsd:string ;
                ] ;
              sp:arg2 [
                  rdf:type sp:eq ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                  sp:arg2 rdfs:Literal ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:hasMatchingRestoreFacetValue ;
              arg:facetClass swa:ExactMatchStringFacet ;
              arg:property [
                  sp:varName "predicate"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight -1 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:datatype=\"{= swa:localRange(?predicate, ?subject) }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <ui:group let:restoreObject=\"{= IF(bound(?restore), spl:object(?restore, search:object), ?none) }\">
        <input class=\"swa-exact-match-input {= swa:testClass(?predicate) }\" id=\"{= ?uid }-text\" onchange=\"swa.updateExactMatchStringFacet('{= ?uid }')\" type=\"text\" value=\"{= ?restoreObject }\"/>
        <swa:LangSelector arg:changeHandler=\"swa.updateExactMatchStringFacet('{= ?uid }')\" arg:initialValue=\"{= lang(?restoreObject) }\" arg:uid=\"{= ?uid }\"/>
        <input id=\"{= ?uid }-hidden\" name=\"value{= ?uid }\" type=\"hidden\" value=\"\"/>
    </ui:group>
    <ui:if ui:condition=\"{= bound(?restore) }\">
        <script>swa.updateExactMatchStringFacet('{= ?uid }')</script>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An ObjectFacet showing a text field. The resulting string will be matched against using equals comparison, i.e. not a regex."^^xsd:string ;
  rdfs:label "Exact match string facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:ExportSearchResultsToSimpleAction
  rdf:type swa:SearchResultsAction ;
  arg:condition "true"^^xsd:boolean ;
  arg:onSelect "swa.exportSearchResults(formId, 'simple')"^^xsd:string ;
  rdfs:label "Export results to simple TSV spreadsheet"^^xsd:string ;
.
swa:ExportSearchResultsToTSVAction
  rdf:type swa:SearchResultsAction ;
  arg:condition "true"^^xsd:boolean ;
  arg:onSelect "swa.exportSearchResults(formId, 'tsv')"^^xsd:string ;
  rdfs:label "Export results to SPARQL TSV spreadsheet"^^xsd:string ;
.
swa:ExportSearchResultsToXMLAction
  rdf:type swa:SearchResultsAction ;
  arg:condition "true"^^xsd:boolean ;
  arg:onSelect "swa.exportSearchResults(formId, 'xml')"^^xsd:string ;
  rdfs:label "Export results to SPARQL XML file"^^xsd:string ;
.
swa:FilterFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:node ;
      rdfs:comment "The RDF node to filter."^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Abstract superclass of SPIN functions that take an RDF node as an argument and either return true (allowed) or false (disallowed). Use cases of those functions include filtering nodes in trees."^^xsd:string ;
  rdfs:label "Filter functions"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:FirstInstances
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            rdf:type ui:label ;
            sp:arg1 [
                sp:varName "instance"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "instance"^^xsd:string ;
          ]
          [
            sp:varName "uri"^^xsd:string ;
          ]
          [
            sp:varName "type"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:SubQuery ;
            sp:query [
                rdf:type sp:Select ;
                sp:limit "200"^^xsd:long ;
                sp:where (
                    [
                      rdf:type sp:TriplePath ;
                      sp:object [
                          sp:varName "class"^^xsd:string ;
                        ] ;
                      sp:path [
                          rdf:type sp:ModPath ;
                          sp:modMax -2 ;
                          sp:modMin 0 ;
                          sp:subPath rdfs:subClassOf ;
                        ] ;
                      sp:subject [
                          sp:varName "type"^^xsd:string ;
                        ] ;
                    ]
                    [
                      sp:object [
                          sp:varName "type"^^xsd:string ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "instance"^^xsd:string ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type xsd:string ;
                sp:arg1 [
                    sp:varName "instance"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class that the instances must have."^^xsd:string ;
    ] ;
  rdfs:comment "Gets a number of instances of a given class, and its subclasses, and orders them by label. The current cut-off is after 200 instances, and ordering is done at the end so the output may be unpredictable."^^xsd:string ;
  rdfs:label "First instances"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:Form
  rdf:type swa:FormClass ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Base class for the various types of forms, depending on the mode."^^xsd:string ;
  rdfs:label "Form"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:FormBody
  rdf:type ui:ResourceViewClass ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Base class for the body element of forms. Subclasses of this are meant to be inserted into Forms, and should be associated as ui:instanceView with domain classes."^^xsd:string ;
  rdfs:label "Form body"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
  rdfs:subClassOf ui:ResourceViews ;
.
swa:FormClass
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass for the various kinds of forms."^^xsd:string ;
  rdfs:label "Form class"^^xsd:string ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:FormElements
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract superclass to group together from related SWA elements."^^xsd:string ;
  rdfs:label "Form elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:FormHeader
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label to put upfront, e.g. \"Edit \"."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "A tool tip text for the header."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div class=\"swa-header\" title=\"{= ?toolTip }\">
    <div class=\"swa-top\">
        <div class=\"swa-left swa-header-label\">
            <ui:if ui:condition=\"{= bound(?label) }\">
                <span>{= ?label }</span>
            </ui:if>
        </div>
        <div class=\"swa-right swa-form-header-toolbar\">
            <ui:insertionPoint ui:pointId=\"toolBar\"/>
        </div>
    </div>
</div>
"""^^ui:Literal ;
  rdfs:comment "A header for forms, with a potential extension point to insert buttons in the upper right corner. Not stable."^^xsd:string ;
  rdfs:label "Form header"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:FormSearchGadget
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:footerPlugin ;
      spl:valueType swa:SearchFormFooterPlugin ;
      rdfs:comment "An SWP element to appear in the lower right corner."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id that shall be used for the new form. The system will generate a unique new id if left blank."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:hideGlobalSearch ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress global text search. By default a text field will appear on the top of the form, allowing users to search across all string properties of the given resources. However, this may be slow and can therefore be disabled. If the class being searched over defines swa:textSearchProperties, then the text search will only operate on those explicitly enumerated properties - even if arg:hideGlobalSearch is true."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchButtonHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function to handle the click event for the Search button."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressActions ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true, the drop down menu with actions will not appear."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressKeyPropertiesSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to disable the check boxes for selecting the result columns."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:typeSelectable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to allow users to switch to the search class using a drop down box."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:fid=\"{= IF(bound(?formId), ?formId, ui:uniqueId()) }\" let:searchGraph=\"{= ui:createSessionGraph() }\">
    <swa:WindowTitleSetter arg:title=\"Search for {= ui:label(?resourceType) }\"/>
    <ui:setContext let:lid=\"{= IF(bound(?formId), CONCAT(?formId, &quot;LID&quot;), ui:uniqueId()) }\" ui:varName=\"mode\" ui:varValue=\"search\">
        <ui:if ui:condition=\"{= ?typeSelectable }\">
            <ui:loadable ui:loadId=\"{= ?fid }TypeSwitch\">
                <swa:SearchFormTypeSwitch arg:loadId=\"{= ?lid }\" arg:resourceType=\"{= ?resourceType }\" arg:selectedType=\"{= IF(bound(?restoreSearch), spl:object(?restoreSearch, search:rootType), ?none) }\"/>
            </ui:loadable>
        </ui:if>
        <ui:loadable class=\"ui-layout-content\" ui:cache=\"{= ?cache }\" ui:loadId=\"{= ?lid }\">
            <ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= ?resourceType }\">
                <ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= swa:createNewTabLink }\">
                    <ui:setContext ui:varName=\"suppressRDFType\" ui:varValue=\"{= !?typeSelectable }\">
                        <ui:setContext ui:varName=\"swaRestoreSearch\" ui:varValue=\"{= ?restoreSearch }\">
                            <ui:if ui:condition=\"{= bound(?restoreSearch) }\">
                                <script>{= ui:functionCall(\"swa.setWindowTitleIfExists\", ?fid, CONCAT(\"Search \", ui:label(?resourceType))) }</script>
                            </ui:if>
                            <form autocomplete=\"off\" class=\"swa-form\" id=\"{= ?fid }\" let:qg=\"{= IF(bound(?queryGraph), ?queryGraph, ui:currentQueryGraph()) }\" searchGraph=\"{= ?searchGraph }\">
                                <input name=\"type\" type=\"hidden\" value=\"&lt;{= ?resourceType }&gt;\"/>
                                <input name=\"_base\" type=\"hidden\" value=\"{= ui:encodeNode(?qg) }\"/>
                                <ui:if ui:condition=\"{= ?qg != ui:currentQueryGraph() }\">
                                    <input name=\"schema\" type=\"hidden\" value=\"{= ui:encodeNode(ui:currentQueryGraph()) }\"/>
                                </ui:if>
                                <ui:if ui:condition=\"{= ?sortByFirstKeyProperty }\">
                                    <input name=\"_sortByFirstKeyProperty\" type=\"hidden\" value=\"true\"/>
                                </ui:if>
                                <ui:setContext ui:varName=\"suppressKeyPropertiesSelection\" ui:varValue=\"{= ?suppressKeyPropertiesSelection }\">
                                    <div class=\"swa-form-body\">
                                        <swa:SearchFormHiddenFields/>
                                        <swa:SearchFormFullTextSection arg:hideGlobalSearch=\"{= ?hideGlobalSearch }\" arg:resourceType=\"{= ?resourceType }\"/>
                                        <ui:classView ui:class=\"{= swa:resourceType() }\" ui:matchIds=\"search,form\"/>
                                        <swa:SearchFormDirectInstancesSection arg:resourceType=\"{= ?resourceType }\"/>
                                    </div>
                                </ui:setContext>
                            </form>
                        </ui:setContext>
                    </ui:setContext>
                </ui:setContext>
            </ui:setContext>
        </ui:loadable>
        <div class=\"swa-form-footer\" let:handler=\"{= COALESCE(?searchButtonHandler, &quot;swa.performSearchFormSearch&quot;) }('{= ?fid }', '{= ?searchGraph }', '{= swa:searchEvent(?searchEvent) }')\">
            <swa:Button arg:id=\"test-search-button\" arg:label=\"Search\" arg:onClick=\"{= ?handler }\"/>
            <swa:Space/>
            <swa:Button arg:label=\"Reset\" arg:onClick=\"swa.reloadSearchForm('{= ?lid }')\"/>
            <ui:if ui:condition=\"{= COALESCE((!?suppressActions), true) }\">
                <swa:Space/>
                <swa:SearchResultsActionsButton arg:formId=\"{= ?fid }\" arg:toolTip=\"Run operation on current search...\"/>
            </ui:if>
            <ui:if ui:condition=\"{= ?loadImmediately }\">
                <script>{= ?handler }</script>
            </ui:if>
            <ui:if ui:condition=\"{= bound(?footerPlugin) }\">
                <swa:Space/>
                <swa:Space/>
                <div style=\"float: right\">
                    <ui:dynamicView arg:formId=\"{= ?fid }\" ui:class=\"{= ?footerPlugin }\"/>
                </div>
            </ui:if>
        </div>
        <swa:MultiResourceEditDialog arg:loadId=\"multiResourceEditDialog\"/>
    </ui:setContext>
    <script type=\"text/javascript\">$(\"#{= ?fid }\").submit(function(e){$(\"#test-search-button\").click(); return false;});</script>
    <swa:SubscribeArgument arg:argumentName=\"resourceType\" arg:event=\"{= ?classSelectedEvent }\" arg:uiElementId=\"{= ?parentUIElementId }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """A form-based search gadget that provides input widgets for search filters (facet values).

Implementation note: The gadget creates a session graph at start-up and reuses that graph for the duration of its existence. Whenever the user clicks the search button, the content of that session graph is completely replaced with a new instance of search:Search, before the search event is published."""^^xsd:string ;
  rdfs:label "Form search gadget"^^xsd:string ;
  rdfs:subClassOf swa:SearchGadgets ;
.
swa:FormTitle
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to show the title for."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= !swa:contextValueIsTrue(&quot;swaHideFormTitle&quot;) }\">
    <div class=\"swa-title\">{= ui:label(?resource) }</div>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "An element that should be used to insert a header into the top of a form body. This does not only set the correct CSS style, but also includes logic that allows surrounding callers to switch off the label altogether. For example, if the form is shown as part of an application that already shows the title in a separate Header object, then the application can use ui:setContext to set the variable \"swaHideFormTitle\" to true."^^xsd:string ;
  rdfs:label "Form title"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:FullScreenBorderLayout
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:deepLinkingEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event that shall be published and subscribed to for \"deep linking\". If set, then the value of the data payload of the event will be placed behind the # of the browser URL. JavaScript code is used to make sure that whenever this value changes (e.g. when the user hits the Back button), then the event is re-published. In a typical scenario, the deep linking event may be the \"resourceSelected\" event that other components on the screen subscribe to."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressInitializer ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to not include the swa:Initializer."^^xsd:string ;
    ] ;
  ui:headIncludes """
<ui:group>
    <style>html, body {
			height: 100%;
			margin: 0;
		}</style>
</ui:group>
"""^^ui:Literal ;
  ui:prototype """
<ui:group>
    <ui:insertionPoint ui:pointId=\"1\"/>
    <ui:insertionPoint ui:pointId=\"2\"/>
    <ui:insertionPoint ui:pointId=\"3\"/>
    <ui:insertionPoint ui:pointId=\"4\"/>
    <ui:insertionPoint ui:pointId=\"5\"/>
    <script>$(document).ready(function() {
			$('body').layout({
			defaults: {
				applyDefaultStyles: true
			}<swa:BorderLayoutOptions arg:fixed=\"{= ?westFixed }\" arg:name=\"west\" arg:size=\"{= ?westSize }\"/>
        <swa:BorderLayoutOptions arg:fixed=\"{= ?eastFixed }\" arg:name=\"east\" arg:size=\"{= ?eastSize }\"/>
        <swa:BorderLayoutOptions arg:fixed=\"{= ?northFixed }\" arg:name=\"north\" arg:size=\"{= ?northSize }\"/>
        <swa:BorderLayoutOptions arg:fixed=\"{= ?southFixed }\" arg:name=\"south\" arg:size=\"{= ?southSize }\"/>
		})
	});</script>
    <ui:if ui:condition=\"{= (!bound(?suppressInitializer)) || (!?suppressInitializer) }\">
        <swa:Initializer/>
    </ui:if>
    <ui:if ui:condition=\"{= bound(?deepLinkingEvent) }\">
        <script>$(document).ready(function() {swa.initDeepLinking('{= ?deepLinkingEvent }');})</script>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """A convenience wrapper around the jQuery UI Layout. Makes it possible to define complex screen layouts with components in the west, east, north, south and center, and possibly with sliders between them. The BorderLayout can take up to 5 children, each of which must declare one the following HTML classes: \"ui-layout-west\", \"ui-layout-east\", \"ui-layout-north\", \"ui-layout-south\" or \"ui-layout-center\".

This element is mainly provided as a convenience, and possibly only for quick demos etc. For more options you may want to rather use jQuery UI Layout directly or create your own extension of this class based on a clone."""^^xsd:string ;
  rdfs:label "Full screen border layout"^^xsd:string ;
  rdfs:subClassOf swa:AbstractBorderLayout ;
.
swa:FullTextSearchFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subClass ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at."^^xsd:string ;
    ] ;
  rdfs:label "Full text search functions"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:Functions
  rdf:type spin:Function ;
  rdfs:label "Functions"^^xsd:string ;
  rdfs:subClassOf spin:Functions ;
.
swa:Gadget
  rdf:type rdfs:Class ;
  rdfs:comment "A flexible, configurable user interface element that can be embedded into a gadget container, e.g. OpenSocial."^^xsd:string ;
  rdfs:label "Gadget"^^xsd:string ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:Gadgets
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:parentUIElementId ;
      spl:valueType xsd:string ;
      rdfs:comment "HTML element ID for a containing element"^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Base class of gadgets that can be inserted into a gadget container."^^xsd:string ;
  rdfs:label "Gadgets"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:GetResourceLabel
  rdf:type ui:Service ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the label of."^^xsd:string ;
    ] ;
  ui:prototype """
<swon:Object>
    <swon:Value arg:name=\"label\" arg:value=\"{= ui:label(?resource) }\"/>
</swon:Object>
"""^^ui:Literal ;
  rdfs:comment "A simple global service that can be used to retrieve the human-readable label of a given resource. Result is a JSON object such as { label : 'Hello' }."^^xsd:string ;
  rdfs:label "Get resource label"^^xsd:string ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:GridDataView
  rdf:type ui:ViewElement ;
  ui:prototype """
<ui:call arg:this=\"{= ?this }\" ui:template=\"{= ?dataProvider }\">
    <swa:ResultSetGrid arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:comment "A DataView displaying a grid (table)."^^xsd:string ;
  rdfs:label "Grid data view"^^xsd:string ;
  rdfs:subClassOf ui:DataViews ;
.
swa:GridElements
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract superclass to group together grid related SWA elements."^^xsd:string ;
  rdfs:label "Grid elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:GridSearchColumns
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "columnIndex"^^xsd:string ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "colName"^^xsd:string ;
          ]
          [
            sp:varName "numeric"^^xsd:string ;
          ]
          [
            sp:varName "varName"^^xsd:string ;
          ]
          [
            sp:varName "inverse"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:or ;
                        sp:arg1 [
                            rdf:type sp:not ;
                            sp:arg1 [
                                rdf:type sp:bound ;
                                sp:arg1 [
                                    sp:varName "suppressLabelColumn"^^xsd:string ;
                                  ] ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:not ;
                            sp:arg1 [
                                sp:varName "suppressLabelColumn"^^xsd:string ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression "Resource" ;
                    sp:variable [
                        sp:varName "colName"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression "label" ;
                    sp:variable [
                        sp:varName "varName"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression -1 ;
                    sp:variable [
                        sp:varName "columnIndex"^^xsd:string ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:NamedGraph ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "rootType"^^xsd:string ;
                            ] ;
                          sp:predicate search:rootType ;
                          sp:subject [
                              sp:varName "search"^^xsd:string ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "column"^^xsd:string ;
                            ] ;
                          sp:predicate spin:column ;
                          sp:subject [
                              sp:varName "search"^^xsd:string ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "columnIndex"^^xsd:string ;
                            ] ;
                          sp:predicate spin:columnIndex ;
                          sp:subject [
                              sp:varName "column"^^xsd:string ;
                            ] ;
                        ]
                        [
                          sp:object [
                              sp:varName "keyProperty"^^xsd:string ;
                            ] ;
                          sp:predicate search:columnProperty ;
                          sp:subject [
                              sp:varName "column"^^xsd:string ;
                            ] ;
                        ]
                        [
                          rdf:type sp:Bind ;
                          sp:expression [
                              rdf:type sp:exists ;
                              sp:elements (
                                  [
                                    sp:object search:InversePropertyColumn ;
                                    sp:predicate rdf:type ;
                                    sp:subject [
                                        sp:varName "column"^^xsd:string ;
                                      ] ;
                                  ]
                                ) ;
                            ] ;
                          sp:variable [
                              sp:varName "inverse"^^xsd:string ;
                            ] ;
                        ]
                      ) ;
                    sp:graphNameNode [
                        sp:varName "searchGraph"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type spif:titleCase ;
                        sp:arg1 [
                            rdf:type ui:label ;
                            sp:arg1 [
                                sp:varName "keyProperty"^^xsd:string ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "colName"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type swa:isNumericDatatype ;
                        arg:node [
                            rdf:type swa:localRangeAtClass ;
                            arg:class [
                                sp:varName "rootType"^^xsd:string ;
                              ] ;
                            arg:property [
                                sp:varName "keyProperty"^^xsd:string ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "numeric"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type xsd:string ;
                        sp:arg1 [
                            sp:varName "keyProperty"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "varName"^^xsd:string ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the search:Search."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:label "Grid search columns"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:GridSearchResultsBody
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:rowNumCookie ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a cookie remembering the number of rows."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the search:Search to execute."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the first column."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to publish when the user clicks on a result. The data payload of this event is the URI of the resource."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?searchGraph) }\">
    <ui:group let:pagerId=\"{= ui:uniqueId() }\" let:tableId=\"{= ui:uniqueId() }\">
        <table id=\"{= ?tableId }\"/>
        <div id=\"{= ?pagerId }\"/>
        <script>$(\"#{= ?tableId }\").jqGrid({<ui:createLink arg:searchGraph=\"{= ?searchGraph }\" arg:suppressLabelColumn=\"{= ?suppressLabelColumn }\" ui:viewClass=\"{= swa:GridSearchResultsCallback }\">\"url\" : swa.redirectLink(\"{= ui:escapeJSON(?link) }\"),</ui:createLink>
            <swon:Value arg:name=\"datatype\" arg:value=\"json\"/>
            <ui:call arg:searchGraph=\"{= ?searchGraph }\" arg:suppressLabelColumn=\"{= ?suppressLabelColumn }\" ui:template=\"{= swa:GridSearchColumns }\">
                <swon:Values arg:name=\"colNames\">
                    <ui:forEach ui:resultSet=\"{= ?rs }\" ui:separator=\",\">'{= IF(?inverse, \"[inv] \", ?none) }{= ?colName }'</ui:forEach>
                </swon:Values>
                <swon:Values arg:name=\"colModel\">
                    <ui:forEach ui:resultSet=\"{= ?rs }\" ui:separator=\",\">
                        <swon:Object>
                            <ui:if ui:condition=\"{= ?numeric }\">
                                <swon:Value arg:name=\"align\" arg:value=\"right\"/>
                            </ui:if>
                            <swon:Value arg:name=\"name\" arg:value=\"{= ?varName }\"/>
                        </swon:Object>
                    </ui:forEach>
                </swon:Values>
            </ui:call>
            <ui:if ui:condition=\"{= bound(?resourceSelectedEvent) }\">,onSelectRow: function(resource) {
		{= swa:publishEvent(?resourceSelectedEvent, \"resource\") }
	},</ui:if>
            <ui:if ui:condition=\"{= bound(?width) }\">
                <swon:Value arg:name=\"width\" arg:value=\"{= ?width }\"/>
            </ui:if>
            <ui:else>
                <swon:Value arg:name=\"autowidth\" arg:value=\"{= true }\"/>
            </ui:else>
            <swon:Value arg:name=\"height\" arg:value=\"auto\"/>
            <swon:Value arg:name=\"mtype\" arg:value=\"POST\"/>
,rowNum: <ui:if ui:condition=\"{= bound(?rowNumCookie) }\">swa.getCookie(\"{= ?rowNumCookie }\", 10)</ui:if>
            <ui:else>10</ui:else>,
rowList:[5,10,15,20,25],
gridComplete: function() {
if(swa.searchPerformed){
{= swa:publishEvent(swa:searchCompletedEvent(), \"true\") }
swa.searchPerformed=false;
}
},<ui:if ui:condition=\"{= bound(?rowNumCookie) }\">loadComplete: function() {
	var currentRowNum = $(\"#{= ?tableId }\").getGridParam('rowNum');
	$.cookie('{= ?rowNumCookie }', currentRowNum);
},</ui:if>
            <swon:Value arg:name=\"pager\" arg:value=\"#{= ?pagerId }\"/>
            <swon:Value arg:name=\"sortorder\" arg:value=\"asc\"/>
            <swon:Value arg:name=\"viewrecords\" arg:value=\"{= true }\"/>}).jqGrid('navGrid', '#{= ?pagerId }',{<swon:Value arg:name=\"add\" arg:value=\"{= false }\"/>
            <swon:Value arg:name=\"del\" arg:value=\"{= false }\"/>
            <swon:Value arg:name=\"edit\" arg:value=\"{= false }\"/>
            <swon:Value arg:name=\"search\" arg:value=\"{= false }\"/>
});</script>
    </ui:group>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "The body of the swa:GridSearchResultsGadget, which can also be used in other places that operate on a given searchGraph."^^xsd:string ;
  rdfs:label "Grid search results body"^^xsd:string ;
  rdfs:subClassOf swa:GridElements ;
.
swa:GridSearchResultsCallback
  rdf:type ui:Service ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:page ;
      spl:valueType xsd:integer ;
      rdfs:comment "The current page - starting with 1."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:sidx ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the sort column (for property)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:sord ;
      spl:valueType xsd:string ;
      rdfs:comment "\"asc\" or \"desc\""^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to not have a label column."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:rows ;
      spl:valueType xsd:integer ;
      rdfs:comment "The number of rows to deliver."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:searchGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph containing the search:Search instance."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:setContext let:startIndex=\"{= COALESCE(((?page - 1) * ?rows), 0) }\" ui:queryGraph=\"{= ?searchGraph }\">
    <ui:group let:desc=\"{= ?sord = &quot;desc&quot; }\" let:search=\"{= search:theSearch() }\" let:sortProperty=\"{= IF((bound(?sidx) &amp;&amp; (?sidx != &quot;label&quot;)), IRI(?sidx), ?none) }\">
        <ui:group let:queryGraph=\"{= spl:object(?search, search:queryGraph) }\">
            <search:results arg:count=\"{= ?rows }\" arg:descSorting=\"{= ?desc }\" arg:search=\"{= ?search }\" arg:sortProperty=\"{= ?sortProperty }\" arg:startIndex=\"{= ?startIndex }\">
                <swon:Object>
                    <ui:setContext let:floor=\"{= floor((?totalCount / ?rows)) }\" ui:queryGraph=\"{= ?queryGraph }\">
                        <swon:Value arg:name=\"page\" arg:value=\"{= ?page }\"/>
                        <swon:Value arg:name=\"records\" arg:value=\"{= ?totalCount }\"/>
                        <swon:Value arg:name=\"total\" arg:value=\"{= IF(((?floor * ?rows) &lt; ?totalCount), (?floor + 1), ?floor) }\"/>
                        <swon:Values arg:name=\"rows\">
                            <ui:if ui:condition=\"{= ?totalCount &gt; 0 }\">
                                <ui:forEach ui:resultSet=\"{= ?results }\" ui:separator=\",\">
                                    <swon:Object>
                                        <swon:Value arg:name=\"id\" arg:value=\"{= IF(isIRI(?result), ?result, swa:bnodeId(?result)) }\"/>
                                        <swon:Value arg:name=\"cell\">
                                            <ui:if ui:condition=\"{= EXISTS {
                                                GRAPH ?searchGraph {
                                                    ?search spin:column ?anyColumn .
                                                } .
                                            } }\">
                                                <swon:RSArray arg:resultSet=\"{#
                                                        SELECT ?label
                                                        WHERE {
                                                            {
                                                                FILTER ((!bound(?suppressLabelColumn)) || (!?suppressLabelColumn)) .
                                                                BIND (ui:label(?result) AS ?label) .
                                                                BIND (-1 AS ?columnIndex) .
                                                            }
                                                            UNION
                                                            {
                                                                GRAPH ?searchGraph {
                                                                    ?search spin:column ?column .
                                                                    ?column spin:columnIndex ?columnIndex .
                                                                    ?column search:columnProperty ?keyProperty .
                                                                    BIND (spl:object(?column, rdf:type) AS ?columnType) .
                                                                } .
                                                                BIND (IF((?columnType = search:InversePropertyColumn), swa:subjectsList(?result, ?keyProperty), ui:label(swa:objectsList(?result, ?keyProperty))) AS ?label) .
                                                            } .
                                                        }
                                                        ORDER BY (?columnIndex) }\"/>
                                            </ui:if>
                                            <ui:else>
                                                <swon:RSArray arg:resultSet=\"{#
                                                        SELECT ?label
                                                        WHERE {
                                                            BIND (ui:label(?result) AS ?label) .
                                                        } }\"/>
                                            </ui:else>
                                        </swon:Value>
                                    </swon:Object>
                                </ui:forEach>
                            </ui:if>
                        </swon:Values>
                    </ui:setContext>
                </swon:Object>
            </search:results>
        </ui:group>
    </ui:group>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment """Delivers the content of the current page of a swa:GridSearchResultsGadget in the format expected by jqGrid:

{
	page : (optional page index),
	records : (number of result rows overall),
	total : (number of pages overall),
	rows : [
		{
			id : (URI of the resource, starting with @ for bnodes),
			cell : [ \"valueCol1\", \"valueCol2\", ... ]
		},
		...
	]
}"""^^xsd:string ;
  rdfs:label "Grid search results callback"^^xsd:string ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:GridSearchResultsGadget
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:rowNumCookie ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a cookie remembering the number of rows."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressLabelColumn ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the first column."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <swa:Subscribe arg:code=\"swa.searchPerformed=true;swa.loadWithResource('{= ?id }-loadable', 'searchGraph', data)\" arg:event=\"{= swa:searchEvent(?searchEvent) }\"/>
    <ui:loadable class=\"ui-layout-content\" ui:loadId=\"{= ?id }-loadable\">
        <swa:GridSearchResultsBody ui:args=\"*\"/>
    </ui:loadable>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A search results gadget that renders the matching resources and possibly their key properties in a grid (currently using jqGrid)."^^xsd:string ;
  rdfs:label "Grid search results gadget"^^xsd:string ;
  rdfs:subClassOf swa:SearchResultsGadgets ;
.
swa:HTMLLiteralViewer
  rdf:type swa:ObjectViewerClass ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <ui:parse ui:str=\"{= ?object }\"/>
    <swa:LangDisplay arg:lang=\"{= lang(?object) }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer that can be selected for literals that contain valid HTML mark-up. The widget will use ui:parse to turn the HTML literal into proper HTML nodes, so that HTML tags like <b> will be used for formatting."^^xsd:string ;
  rdfs:label "HTML literal viewer"^^xsd:string ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:Header
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label to insert."^^xsd:string ;
    ] ;
  ui:prototype """
<div class=\"swa-header\">
    <div class=\"swa-header-label\">{= ?label }</div>
</div>
"""^^ui:Literal ;
  rdfs:comment "Displays the title area of a panel on the screen - typically a black bar with a label on it."^^xsd:string ;
  rdfs:label "Header"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:HeaderLabelFunctions
  rdf:type spin:Function ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the label of."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Abstract superclass for functions that take a resource and deliver a label that is displayed in the header of ViewForms and potentially other places. If you want to activate a different function than the default one, set the context variable 'headerLabelFunction' around the swa:ViewForm element."^^xsd:string ;
  rdfs:label "Header label functions"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:HiddenFields
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract base class for elements that insert hidden fields."^^xsd:string ;
  rdfs:label "Hidden fields"^^xsd:string ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:ImageResourceViewer
  rdf:type swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type sp:isIRI ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:isImageURL ;
              arg:url [
                  rdf:type xsd:string ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                ] ;
            ] ;
        ] ;
      swa:weight 2 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<img class=\"swa-image\" src=\"{= ?object }\"/>
"""^^ui:Literal ;
  rdfs:comment "The default viewer for URI resources that appear to be images, judged by their file extension."^^xsd:string ;
  rdfs:label "Image resource viewer"^^xsd:string ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:Index
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:cache ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to activate caching for the letter dialogs."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:labelProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The label property, e.g. rdfs:label or skos:prefLabel."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "The JavaScript code that will be called if the user has selected a resource. The variable resource will point to the URI of the selected resource."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The type of instances to index."^^xsd:string ;
    ] ;
  ui:prototype """
<div class=\"swa-index\">
    <ui:forEach ui:resultSet=\"{#
            SELECT *
            WHERE {
                rdf:nil swa:letters ?letter .
            } }\" ui:separator=\" \">
        <a href=\"javascript:void(0)\" onclick=\"swa.openIndexLetterDialog('swaIndexLetterDialog', '{= ?letter }')\">{= ?letter }</a>
    </ui:forEach>
    <swa:IndexLetterDialog arg:cache=\"{= ?cache }\" arg:labelProperty=\"{= ?labelProperty }\" arg:onSelect=\"{= ?onSelect }\" arg:resourceType=\"{= ?resourceType }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "Displays a list of hyperlinks A B C ... Z * where each letter opens a dialog with all resources starting with that letter."^^xsd:string ;
  rdfs:label "Index"^^xsd:string ;
  rdfs:subClassOf swa:IndexElements ;
.
swa:IndexElements
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract superclass for elements related to A-Z search index."^^xsd:string ;
  rdfs:label "Index elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:IndexLetterDialog
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:cache ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to activate caching for the dialogs."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:labelProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property holding the label information, e.g. skos:prefLabel."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "The JavaScript that will be called."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The type of instances to display."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:loadable style=\"display: none\" ui:cache=\"{= ?cache }\" ui:loadId=\"swaIndexLetterDialog\">
    <ui:if ui:condition=\"{= bound(?letter) }\">
        <div id=\"div-swaIndexLetterDialog\" title=\"{= ?letter }\">
            <swa:SearchResultsGrid arg:onSelect=\"{= ?onSelect };swa.closeDialog('swaIndexLetterDialog');\" arg:params=\"_base={= ui:currentQueryGraph() }&amp;_cache={= ?cache }&amp;facet0={= ui:encodeNode(?labelProperty) }&amp;regex0=%5E{= ?letter }&amp;lang0={= ui:lang() }&amp;type={= ui:encodeNode(?resourceType) }\" arg:type=\"{= ?resourceType }\" arg:width=\"{= 400 }\"/>
        </div>
    </ui:if>
</ui:loadable>
"""^^ui:Literal ;
  rdfs:comment "A dialog that displays a sorted list of all resources starting with a given letter."^^xsd:string ;
  rdfs:label "Index letter dialog"^^xsd:string ;
  rdfs:subClassOf swa:IndexElements ;
.
swa:Initializer
  rdf:type ui:NodeClass ;
  ui:prototype """
<script>$(document).ready(function() {swa.server='{= ui:server() }'; swa.queryGraphURI='{= ui:currentQueryGraph() }';})</script>
"""^^ui:Literal ;
  rdfs:comment "Should be placed into the beginning of an SWA application's main element, i.e. the start of the body. Will set some variables required by some SWA features. Note that swa:FullScreenBorderLayout includes this automatically."^^xsd:string ;
  rdfs:label "Initializer"^^xsd:string ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:InstancesGridGadget
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:directInstancesOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only display the direct instances of the class, i.e. instances of subclasses will not be displayed."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a button to create classes appear under the tree."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to so that the instances can be reloaded whenever the class changes."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:instanceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to fire if the selected instance has changed."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class of instances to display."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:loadId=\"{= ui:uniqueId() }\" let:searchGraph=\"{= ui:createSessionGraph() }\">
    <ui:if ui:condition=\"{= bound(?resourceType) }\">
        <swa:WindowTitleSetter arg:title=\"Instances of {= ui:label(?resourceType) }\"/>
        <ui:loadable class=\"ui-layout-content\" ui:loadId=\"{= ?loadId }\">
            <ui:update ui:updateQuery=\"{!
                    DELETE WHERE {
                        GRAPH ?searchGraph {
                            ?s ?p ?o .
                        } .
                    } }\"/>
            <ui:group let:search=\"{= BNODE() }\">
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            GRAPH ?searchGraph {
                                ?search a search:Search .
                                ?search search:queryGraph ?queryGraph .
                                ?search search:rootType ?resourceType .
                                ?search search:directInstancesSearch ?directInstancesOnly .
                            } .
                        }
                        WHERE {
                            BIND (ui:currentQueryGraph() AS ?queryGraph) .
                        } }\"/>
                <ui:if ui:condition=\"{= EXISTS {
                    ?subClass rdfs:subClassOf ?resourceType .
                } &amp;&amp; swa:falseOrUnbound(?directInstancesOnly) }\">
                    <ui:update ui:updateQuery=\"{!
                            INSERT {
                                GRAPH ?searchGraph {
                                    ?search spin:column ?column .
                                    ?column spin:columnIndex 0 .
                                    ?column a search:PropertyColumn .
                                    ?column search:columnProperty rdf:type .
                                } .
                            }
                            WHERE {
                                BIND (BNODE() AS ?column) .
                            } }\"/>
                </ui:if>
            </ui:group>
            <swa:GridSearchResultsBody arg:resourceSelectedEvent=\"{= ?instanceSelectedEvent }\" ui:args=\"*\"/>
        </ui:loadable>
        <div class=\"swa-form-footer\">
            <swa:AutoComplete arg:id=\"instancesAutoComplete\" arg:onSelect=\"{= swa:publishEvent(?instanceSelectedEvent, &quot;resource&quot;) }\" arg:type=\"{= ?resourceType }\"/>
            <ui:if ui:condition=\"{= ?editable }\">
                <div style=\"float: right\">
                    <swa:CreateResourceButton arg:createHandler=\"{= swa:CreateResourceHandler }\" arg:iconClass=\"swa-icon-individual\" arg:resourceSelectedEvent=\"{= ?instanceSelectedEvent }\" arg:resourceType=\"{= ?resourceType }\"/>
                </div>
            </ui:if>
        </div>
    </ui:if>
    <ui:if ui:condition=\"{= bound(?parentUIElementId) }\">
        <swa:SubscribeArgument arg:argumentName=\"resourceType\" arg:event=\"{= ?classSelectedEvent }\" arg:uiElementId=\"{= ?parentUIElementId }\"/>
    </ui:if>
    <ui:else>
        <swa:SubscribeArgument arg:argumentName=\"resourceType\" arg:event=\"{= ?classSelectedEvent }\"/>
    </ui:else>
    <swa:Subscribe arg:code=\"swa.handleChangeForInstancesGrid(data, '{= ?resourceType }', '{= ?loadId }')\" arg:event=\"org.topbraid.swa.change\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A gadget that displays the instances of a given class (?resourceType) in a grid. The gadget has an auto-complete box under the grid."^^xsd:string ;
  rdfs:label "Instances grid gadget"^^xsd:string ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:Label
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:node ;
      rdfs:comment "The RDF node to display the label of."^^xsd:string ;
    ] ;
  ui:prototype """
<span class=\"swa-label\">
    <ui:if ui:condition=\"{= isLiteral(?node) }\">{= ui:label(?node) }</ui:if>
    <ui:else>
        <ui:resourceView ui:matchIds=\"label\" ui:resource=\"{= ?node }\"/>
    </ui:else>
</span>
"""^^ui:Literal ;
  rdfs:comment "A span that inserts an instance view of a given resource with match id \"label\". If the node is a literal it will simply render the ui:label of the literal."^^xsd:string ;
  rdfs:label "Label"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:LabelRegexStringFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:RegexFacetValue ;
  swa:objectFacetMenuName "label contains"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type sp:not ;
                  sp:arg1 [
                      rdf:type swa:isDatatypeRange ;
                      arg:range [
                          sp:varName "range"^^xsd:string ;
                        ] ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:hasMatchingRestoreFacetValue ;
              arg:facetClass swa:URIResourceFacet ;
              arg:property [
                  sp:varName "predicate"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight -2 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <input class=\"{= swa:testClass(?predicate) }\" name=\"label{= ?uid }\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:pattern), ?none) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An ObjectFacet showing a text field. The resulting string will be matched against as a regex on labels of linked object resources."^^xsd:string ;
  rdfs:label "Label regex string facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:LabeledElement
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:labelWidth ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional label width."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional tool tip text to appear over the label."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label text."^^xsd:string ;
    ] ;
  ui:prototype """
<table class=\"swa-labeled-objects-table\" let:id=\"{= ui:uniqueId() }\">
    <tr class=\"swa-labeled-objects-tr\">
        <td class=\"swa-dialog-label-td\" style=\"{= IF(bound(?labelWidth), CONCAT(&quot;width: &quot;, ?labelWidth), ?none) }\">
            <label for=\"{= ?id }\" title=\"{= ?toolTip }\">{= ?label }</label>
        </td>
        <td class=\"swa-labeled-objects-icons-td\">
            <span class=\"swa-icon\"/>
        </td>
        <td id=\"{= ?id }\">
            <ui:insertionPoint ui:pointId=\"body\"/>
        </td>
    </tr>
</table>
"""^^ui:Literal ;
  rdfs:comment "A container element with one child, that places a label to the left and the child element to the right, in the same layout as the tabular forms."^^xsd:string ;
  rdfs:label "Labeled element"^^xsd:string ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:LabeledObjects
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only allow at most one object for this component."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:if ui:condition=\"{= (((!bound(?hideIfEmpty)) || (?hideIfEmpty != true)) || (swa:mode() != swa:ViewMode)) || (bound(?subject) &amp;&amp; EXISTS {
    ?subject ?predicate ?anyObject .
}) }\">
    <ui:if ui:condition=\"{= (!bound(?hideInModes)) || (!swa:containsCurrentModeName(?hideInModes)) }\">
        <ui:if ui:condition=\"{= ((rdf:type != ?predicate) || (swa:mode() != swa:SearchMode)) || COALESCE(ui:contextValue(&quot;suppressRDFType&quot;), true) }\">
            <table class=\"swa-labeled-objects-table\" let:pid=\"{= ui:uniqueId() }\">
                <tr class=\"swa-labeled-objects-tr\">
                    <td class=\"swa-labeled-objects-label-td {= IF(?tabular, &quot;swa-labeled-objects-tabular-label&quot;, ?none) }\" style=\"{= IF(bound(?labelWidth), CONCAT(&quot;width: &quot;, ?labelWidth), ?none) }\">
                        <div class=\"swa-shifted-label\">
                            <swa:PropertyLabel arg:id=\"property-label-{= ?predicate }\" arg:label=\"{= IF(bound(?label), ?label, ui:label(?predicate)) }\" arg:property=\"{= ?predicate }\"/>
                        </div>
                    </td>
                    <ui:dynamicView arg:editWidget=\"{= ?editWidget }\" arg:predicate=\"{= ?predicate }\" arg:searchWidget=\"{= ?searchWidget }\" arg:single=\"{= ?single }\" arg:subject=\"{= ?subject }\" arg:uid=\"{= ?pid }\" arg:viewWidget=\"{= ?viewWidget }\" ui:class=\"{= COALESCE(swa:modeProperty(swa:objectWidgetMiddleColumnClass), swa:DefaultObjectWidgetMiddleColumn) }\"/>
                    <td class=\"swa-labeled-objects-body-td\" id=\"{= ?pid }-body\">
                        <ui:setContext ui:varName=\"editWidget\" ui:varValue=\"{= ?editWidget }\">
                            <ui:setContext ui:varName=\"searchWidget\" ui:varValue=\"{= ?searchWidget }\">
                                <ui:setContext ui:varName=\"viewWidget\" ui:varValue=\"{= ?viewWidget }\">
                                    <swa:ObjectsBody ui:args=\"*\"/>
                                </ui:setContext>
                            </ui:setContext>
                        </ui:setContext>
                    </td>
                </tr>
            </table>
        </ui:if>
    </ui:if>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "The default implementation of swa:Object and swa:Objects. Displays a label on the left and the value widget(s) on the right."^^xsd:string ;
  rdfs:label "Labeled objects"^^xsd:string ;
  rdfs:subClassOf swa:Objects ;
.
swa:LabeledSubjects
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only allow at most one subject for this component."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:if ui:condition=\"{= (((!bound(?hideIfEmpty)) || (?hideIfEmpty != true)) || (swa:mode() != swa:ViewMode)) || (bound(?object) &amp;&amp; EXISTS {
    ?anySubject ?predicate ?object .
}) }\">
    <table class=\"swa-labeled-objects-table\" let:pid=\"{= ui:uniqueId() }\">
        <tr class=\"swa-labeled-objects-tr\">
            <td class=\"swa-labeled-objects-label-td {= IF(?tabular, &quot;swa-labeled-objects-tabular-label&quot;, ?none) }\" style=\"{= IF(bound(?labelWidth), fn:concat(&quot;width: &quot;, ?labelWidth), ?none) }\">
                <div class=\"swa-shifted-label\">
                    <swa:PropertyLabel arg:inverse=\"{= !bound(?label) }\" arg:label=\"{= IF(bound(?label), ?label, ui:label(?predicate)) }\"/>
                </div>
            </td>
            <ui:dynamicView arg:editWidget=\"{= ?editWidget }\" arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:searchWidget=\"{= ?searchWidget }\" arg:single=\"{= ?single }\" arg:uid=\"{= ?pid }\" arg:viewWidget=\"{= ?viewWidget }\" ui:class=\"{= COALESCE(swa:modeProperty(swa:subjectWidgetMiddleColumnClass), swa:DefaultSubjectWidgetMiddleColumn) }\"/>
            <td class=\"swa-labeled-objects-body-td\" id=\"{= ?pid }-body\">
                <swa:SubjectsBody ui:args=\"*\"/>
            </td>
        </tr>
    </table>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "Default implementation of swa:Subjects."^^xsd:string ;
  rdfs:label "Labeled subjects"^^xsd:string ;
  rdfs:subClassOf swa:Subjects ;
.
swa:LangDisplay
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:lang ;
      spl:valueType xsd:string ;
      rdfs:comment "The language tag."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?lang) &amp;&amp; (?lang != &quot;&quot;) }\">
    <ui:if ui:condition=\"{= ui:contextValue(&quot;langFlags&quot;) }\">
        <img class=\"swa-lang-img\" src=\"{= swa:langImage(?lang) }\" title=\"Language code: {= ?lang }\"/>
    </ui:if>
    <ui:else>
        <span class=\"swa-lang\">({= ?lang })</span>
    </ui:else>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "Displays a given language. Does nothing if the language is unbound."^^xsd:string ;
  rdfs:label "Lang display"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:LangLiteralViewer
  rdf:type swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type sp:isLiteral ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type sp:gt ;
              sp:arg1 [
                  rdf:type sp:strlen ;
                  sp:arg1 [
                      rdf:type sp:lang ;
                      sp:arg1 [
                          sp:varName "object"^^xsd:string ;
                        ] ;
                    ] ;
                ] ;
              sp:arg2 0 ;
            ] ;
        ] ;
      swa:weight 1 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <div class=\"swa-shifted-label\">{= ?object }<swa:LangDisplay arg:lang=\"{= lang(?object) }\"/>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A node viewer for literal values that carry a language tag, displaying the literal's text and either a language code or a flag of the country associated with the language. By default this is showing the language code, but flags can be activated by setting the context variable \"langFlags\" to true."^^xsd:string ;
  rdfs:label "Lang literal viewer"^^xsd:string ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:LangSelector
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:changeHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JS snippet that shall be called on changes of the selection."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:initialValue ;
      spl:valueType xsd:string ;
      rdfs:comment "The initial language to display."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid of the surrounding widget. Will become the XY half of the lang-XY field name."^^xsd:string ;
    ] ;
  swa:defaultLanguages "ar de en fr it es pt ru zh"^^xsd:string ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<select class=\"swa-lang-selector\" id=\"{= ?uid }-lang\" name=\"lang-{= ?uid }\" onchange=\"{= ?onChange }\" title=\"Language (e.g. 'en' for English)\">
    <option/>
    <ui:forEach ui:resultSet='{#
            SELECT DISTINCT ?lang
            WHERE {
                {
                    GRAPH ui:graph {
                        BIND (COALESCE(spl:object(swa:LangSelector, swa:customLanguages), spl:object(swa:LangSelector, swa:defaultLanguages)) AS ?langs) .
                    } .
                    ?lang spif:split ( ?langs \" \" ) .
                }
                UNION
                {
                    BIND (xsd:string(?initialValue) AS ?lang) .
                } .
                FILTER (?lang != \"\") .
            }
            ORDER BY (?lang) }'>
        <option selected=\"{= IF((?initialValue = ?lang), &quot;selected&quot;, ?none) }\">{= ?lang }</option>
    </ui:forEach>
</select>
"""^^ui:Literal ;
  rdfs:comment "A select box that allows users to select a language code. The result is a form field such as lang-uniqueId42 that is sent to the edit servlet. The list of languages is specified by the property swa:defaultLanguages. These can be overloaded by adding a triple swa:LangSelector swa:customLanguages \"space-separated string\" to a UI graph."^^xsd:string ;
  rdfs:label "Lang selector"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:LayoutElements
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract base class for elements that can be used to drive an application's layout."^^xsd:string ;
  rdfs:label "Layout elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:Link
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI resource to link to."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <ui:group let:link=\"{= swa:createLink(?resource, ?uid) }\">
        <ui:if ui:condition=\"{= bound(?link) }\">
            <a class=\"swa-link\" href=\"javascript:void(0)\" id=\"{= ?uid }\" onclick=\"{= ?link }\">
                <swa:Label arg:node=\"{= ?resource }\"/>
            </a>
        </ui:if>
        <ui:else>
            <swa:Label arg:node=\"{= ?resource }\"/>
        </ui:else>
    </ui:group>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Creates a hyperlink to switch the current view to a given resource. This element should be used to create all hyperlinks in SWA applications, because this single place provides greater flexibility to make adjustments to the links. In particular, the semantics of what should happen if the user clicks on a link may be different for each application or even within different parts of a single application: in some cases the application may want to replace a form on the screen, while in other cases the selected resource should be opened in a modal dialog. The SPIN function swa:createLink is used to define the link. If this function retuns nothing, then no link is displayed, but rather an swa:Label."^^xsd:string ;
  rdfs:label "Link"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:ListElements
  rdf:type ui:NodeClass ;
  rdfs:label "List elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:LiteralViewer
  rdf:type swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:isLiteral ;
          sp:arg1 [
              sp:varName "object"^^xsd:string ;
            ] ;
        ] ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div class=\"swa-shifted-label\">{= ?object }</div>
"""^^ui:Literal ;
  rdfs:comment "A node viewer for literal values, displaying the literal's text."^^xsd:string ;
  rdfs:label "Literal viewer"^^xsd:string ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:MenuElements
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract superclass to group menu-related elements."^^xsd:string ;
  rdfs:label "Menu elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:Mode
  rdf:type rdfs:Class ;
  rdfs:comment "The class of the various modes that a form can be in, e.g. editing, viewing. Each Mode holds pointers to the relevant subclasses that shall be inserted."^^xsd:string ;
  rdfs:label "Mode"^^xsd:string ;
.
swa:MultiResourceEditDialog
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the ui:loadable that will be placed around the dialog."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The default type of the resources, used to select a suitable form."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceURIs ;
      spl:valueType xsd:string ;
      rdfs:comment "A space-separated list of URIs of the resources to edit."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:loadable ui:loadId=\"{= ?loadId }\">
    <ui:if ui:condition=\"{= bound(?resourceURIs) }\">
        <ui:group let:resource=\"{= &lt;urn:x-swa:MultiResource&gt; }\" let:sessionGraph=\"{= ui:createSessionGraph(ui:currentQueryGraph()) }\" letrs:rs='{#
                SELECT ?r
                WHERE {
                    ?uri spif:split ( ?resourceURIs \" \" ) .
                    BIND (IRI(str(?uri)) AS ?r) .
                } }'>
            <ui:group let:first=\"{= spr:cell(?rs, 0, 0) }\">
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            GRAPH ?sessionGraph {
                                ?resource ?p ?o .
                            } .
                        }
                        WHERE {
                            ?first ?p ?o .
                            FILTER NOT EXISTS {
                                ( ?rs 0 ) spr:colCells ?other .
                                FILTER ((?other != ?first) &amp;&amp; NOT EXISTS {
                                    ?other ?p ?o .
                                }) .
                            } .
                        } }\"/>
            </ui:group>
            <div id=\"div-{= ?loadId }\" let:oldQueryGraph=\"{= ui:currentQueryGraph() }\" title=\"Edit {= spr:rowCount(?rs) } instances of {= ui:label(?resourceType) }\">
                <ui:setContext let:fid=\"multiResourceEditForm\" ui:queryGraph=\"{= ui:graphWithImports(?sessionGraph) }\" ui:varName=\"mode\" ui:varValue=\"edit\">
                    <form autocomplete=\"off\" class=\"swa-form\" id=\"{= ?fid }\">
                        <input name=\"_base\" type=\"hidden\" value=\"{= ui:encodeNode(?oldQueryGraph) }\"/>
                        <input name=\"_resourceURIs\" type=\"hidden\" value=\"{= ?resourceURIs }\"/>
                        <div class=\"swa-form-body\">
                            <ui:classView ui:class=\"{= COALESCE(?resourceType, spl:object(?resource, rdf:type)) }\" ui:matchIds=\"edit,form\" ui:resource=\"{= ?resource }\"/>
                        </div>
                    </form>
                </ui:setContext>
            </div>
        </ui:group>
    </ui:if>
</ui:loadable>
"""^^ui:Literal ;
  rdfs:comment "A dialog that makes it possible to edit properties of multiple resources at the same time. This is a modal dialog that uses a session graph to build up a temporary instance with the intersection of all values. Then an edit form is displayed for that instance. The session graph is discarded once the dialog is closed."^^xsd:string ;
  rdfs:label "Multi resource edit dialog"^^xsd:string ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:NestedObjectEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type swa:isBlankNodeProperty ;
          arg:property [
              sp:varName "predicate"^^xsd:string ;
            ] ;
        ] ;
      swa:weight 1 ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= bound(?object) }\">
        <div class=\"swa-nested-form swa-nested-object-editor\">
            <input name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true) }\"/>
            <ui:resourceView ui:matchIds=\"nested,edit,form\" ui:resource=\"{= ?object }\"/>
        </div>
    </ui:if>
    <ui:else>
        <ui:group let:object=\"{= IRI(CONCAT(&quot;urn:x-new-bnode:&quot;, ui:uniqueId())) }\" let:range=\"{= swa:localRange(?predicate, ?subject) }\">
            <input name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true) }\"/>
            <ui:group let:id=\"{= ui:uniqueId() }\">
                <input name=\"resource-{= ?id }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true) }\"/>
                <input name=\"path-{= ?id }\" type=\"hidden\" value=\"{= ui:encodeNode(rdf:type) }\"/>
                <input name=\"new-{= ?id }\" type=\"hidden\" value=\"{= ui:encodeNode(?range) }\"/>
            </ui:group>
            <div class=\"swa-nested-form swa-nested-object-editor\">
                <ui:setContext ui:varName=\"mode\" ui:varValue=\"edit\">
                    <ui:classView arg:subject=\"{= ?object }\" ui:class=\"{= ?range }\" ui:matchIds=\"nested,edit,form\" ui:resource=\"{= ?object }\"/>
                </ui:setContext>
            </div>
        </ui:group>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A nested form, suitable for editing \"depending\" blank nodes. This is the default editor for properties that are marked with swa:blankNodeProperty=true in the ui:graph."^^xsd:string ;
  rdfs:label "Nested object editor"^^xsd:string ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:NestedObjectFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:NestedFacetValue ;
  swa:objectFacetMenuName "nested form"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:not ;
              sp:arg1 [
                  rdf:type swa:isDatatypeRange ;
                  arg:range [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:hasMatchingRestoreFacetValue ;
              arg:facetClass swa:NestedObjectFacet ;
              arg:property [
                  sp:varName "predicate"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight -1 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div class=\"swa-nested-form\" let:range=\"{= swa:localRangeAtClass(swa:resourceType(), ?predicate) }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <ui:group let:subjectVarName=\"{= IF(bound(?restore), spl:object(?restore, search:nestedSubjectVarName), ui:uniqueId()) }\">
        <input name=\"nested{= ?uid }\" type=\"hidden\" value=\"{= ?subjectVarName }\"/>
        <ui:setContext ui:varName=\"subjectVarName\" ui:varValue=\"{= ?subjectVarName }\">
            <ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= ?range }\">
                <ui:setContext ui:varName=\"suppressKeyPropertiesSelection\" ui:varValue=\"{= true }\">
                    <ui:classView ui:class=\"{= ?range }\" ui:matchIds=\"nested,search,form\"/>
                </ui:setContext>
            </ui:setContext>
        </ui:setContext>
    </ui:group>
    <script>$(\"#facetSelector-{= ?uid }\").addClass('swa-nested-form-facet-selector')</script>
</div>
"""^^ui:Literal ;
  rdfs:comment "Represents a nested form that points to a depending object resource."^^xsd:string ;
  rdfs:label "Nested object facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:NestedObjectViewer
  rdf:type swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:isBlank ;
              sp:arg1 [
                  sp:varName "object"^^xsd:string ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:isBlankNodeProperty ;
              arg:property [
                  sp:varName "predicate"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight 1 ;
    ] ;
  ui:prototype """
<div class=\"swa-nested-form swa-nested-object-viewer\">
    <ui:resourceView ui:matchIds=\"nested,view,form\" ui:resource=\"{= ?object }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "Displays an expanded view of an object as a \"nested form\". Currently only really suitable for blank nodes, e.g. schema:PostalAddress dangling off a schema:Person.  This is the default viewer for properties that are marked with swa:blankNodeProperty=true in the ui:graph."^^xsd:string ;
  rdfs:label "Nested object viewer"^^xsd:string ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:NestedSubjectFacet
  rdf:type swa:SubjectFacetClass ;
  swa:facetSearchType search:NestedFacetValue ;
  swa:subjectFacetMenuName "nested form"^^xsd:string ;
  swa:subjectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type swa:hasMatchingInverseRestoreFacetValue ;
          arg:facetClass swa:NestedSubjectFacet ;
          arg:property [
              sp:varName "predicate"^^xsd:string ;
            ] ;
        ] ;
      swa:weight -1 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div class=\"swa-nested-form\" let:domain=\"{= swa:localDomain(?none, ?predicate) }\" let:restore=\"{= swa:restoreInverseFacetValue(?predicate) }\">
    <ui:group let:subjectVarName=\"{= IF(bound(?restore), spl:object(?restore, search:nestedSubjectVarName), ui:uniqueId()) }\">
        <input name=\"nested{= ?uid }\" type=\"hidden\" value=\"{= ?subjectVarName }\"/>
        <ui:setContext ui:varName=\"subjectVarName\" ui:varValue=\"{= ?subjectVarName }\">
            <ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= ?domain }\">
                <ui:setContext ui:varName=\"suppressKeyPropertiesSelection\" ui:varValue=\"{= true }\">
                    <ui:classView ui:class=\"{= ?domain }\" ui:matchIds=\"search,form\"/>
                </ui:setContext>
            </ui:setContext>
        </ui:setContext>
    </ui:group>
</div>
"""^^ui:Literal ;
  rdfs:comment "Represents a nested form that points to a depending subject resource."^^xsd:string ;
  rdfs:label "Nested subject facet"^^xsd:string ;
  rdfs:subClassOf swa:SubjectFacet ;
.
swa:NoneObjectFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:NoneFacetValue ;
  swa:objectFacetMenuName "no value"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type swa:hasMatchingRestoreFacetValue ;
          arg:facetClass swa:NoneObjectFacet ;
          arg:property [
              sp:varName "predicate"^^xsd:string ;
            ] ;
        ] ;
      swa:weight -6 ;
    ] ;
  ui:prototype """
<div class=\"swa-facet-constant\">
    <input id=\"none{= ?uid }\" name=\"none{= ?uid }\" type=\"hidden\" value=\"true\"/>
    <span>no value</span>
</div>
"""^^ui:Literal ;
  rdfs:comment "A facet representing the existence of no value for the given predicate."^^xsd:string ;
  rdfs:label "None object facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:NumericRangeFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:RangeFacetValue ;
  swa:objectFacetMenuName "min/max range"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type swa:isNumericDatatype ;
                  arg:node [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:hasMatchingRestoreFacetValue ;
              arg:facetClass swa:NumericRangeFacet ;
              arg:property [
                  sp:varName "predicate"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight 5 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<span let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <input class=\"{= swa:testClass(?predicate) }-min\" name=\"min{= ?uid }\" size=\"6\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:min), ?none) }\"/>
    <span> - </span>
    <input class=\"{= swa:testClass(?predicate) }-max\" name=\"max{= ?uid }\" size=\"6\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:max), ?none) }\"/>
</span>
"""^^ui:Literal ;
  rdfs:comment "A facet with two input fields for min and max value of a numeric range."^^xsd:string ;
  rdfs:label "Numeric range facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:Object
  rdf:type ui:NodeClass ;
  ui:prototype """
<swa:LabeledObjects arg:single=\"{= true }\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "Inserts a widget for a single value of a given predicate at the given subject. This element should only be used if the property doesn't have a max cardinality of 1 anyway, to overload the default behavior."^^xsd:string ;
  rdfs:label "Object"^^xsd:string ;
  rdfs:subClassOf swa:AbstractObject ;
.
swa:ObjectEditor
  rdf:type swa:ObjectEditorClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:class=\"{= COALESCE(ui:contextValue(&quot;editWidget&quot;), swa:bestObjectEditorClass(?object, ?predicate, ?subject)) }\">
    <ui:if ui:condition=\"{= bound(?class) }\">
        <ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?class }\"/>
    </ui:if>
    <ui:else>
        <b>ERROR: No ObjectEditor found for {= ui:label(?predicate) } at {= ui:label(swa:resourceType(?subject)) } and range {= swa:localRange(?predicate, ?subject) }</b>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Inserts an editor for a given object, with different behavior depending on the type of object or the context."^^xsd:string ;
  rdfs:label "Object editor"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidget ;
.
swa:ObjectEditorClass
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass of the various types of object editors."^^xsd:string ;
  rdfs:label "Object editor class"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidgetClass ;
.
swa:ObjectEditorHiddenDatatypeField
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The datatype to send to the server for new values of this widget."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid identifying the associated editor."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?datatype) }\">
    <input name=\"datatype-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?datatype) }\"/>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A hidden field used to send a datatype to the SWP edit servlet."^^xsd:string ;
  rdfs:label "Object editor hidden datatype field"^^xsd:string ;
  rdfs:subClassOf swa:HiddenFields ;
.
swa:ObjectEditorHiddenFields
  rdf:type swa:ObjectWidgetClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:object ;
      rdfs:comment "The object node."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The unique id of this group."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <input class=\"swa-editor-hidden-field\" name=\"resource-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(COALESCE(?subject, &lt;urn:x-app-edit:root&gt;), true) }\"/>
    <input class=\"swa-editor-hidden-field\" name=\"path-{= ?uid }\" type=\"hidden\" value=\"&lt;{= ?predicate }&gt;\"/>
    <ui:if ui:condition=\"{= bound(?object) }\">
        <input class=\"swa-editor-hidden-field\" name=\"old-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?object, true) }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Inserts the hidden fields needed to link the server with a widget. Note that the fields have a marker class swa-editor-hidden-field that is used by delete row operations."^^xsd:string ;
  rdfs:label "Object editor hidden fields"^^xsd:string ;
  rdfs:subClassOf swa:HiddenFields ;
.
swa:ObjectEditorRow
  rdf:type swa:ObjectWidgetRowClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:editWidget ;
      spl:valueType swa:ObjectEditor ;
      rdfs:comment "An optional edit widget that shall be preferred."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <ui:if ui:condition=\"{= ((bound(?subject) &amp;&amp; bound(?object)) &amp;&amp; bound(?predicate)) &amp;&amp; swa:isReadOnlyTriple(?subject, ?predicate, ?object) }\">
        <swa:ObjectViewer ui:args=\"*\"/>
    </ui:if>
    <ui:else>
        <table class=\"swa-object-editor-row-table\" id=\"{= ?uid }\">
            <tr>
                <td class=\"swa-object-row-main-td\">
                    <swa:ObjectEditorHiddenFields ui:args=\"*\"/>
                    <swa:ObjectEditor ui:args=\"*\"/>
                </td>
                <td class=\"swa-object-row-button-td\">
                    <a class=\"swa-delete-row-button swa-icon ui-icon ui-icon-closethick\" href=\"javascript:void(0)\" onclick=\"swa.deleteRow(&quot;{= ?uid }&quot;)\"/>
                </td>
            </tr>
        </table>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:label "Object editor row"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidgetRow ;
.
swa:ObjectElements
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource of the form or widget. May be left empty in which case the subjectType will be used."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract superclass for all elements that take a subject/predicate combination and then display or edit the objects."^^xsd:string ;
  rdfs:label "Object elements"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:ObjectFacet
  rdf:type swa:ObjectFacetClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:class=\"{= COALESCE(ui:contextValue(&quot;searchWidget&quot;), swa:bestObjectFacetClass(?predicate)) }\">
    <ui:if ui:condition=\"{= bound(?class) }\">
        <ui:dynamicView arg:predicate=\"{= ?predicate }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?class }\"/>
        <ui:group let:restoreSearch=\"{= swa:restoreSearch() }\">
            <ui:if ui:condition=\"{= bound(?restoreSearch) }\">
                <ui:update ui:updateQuery=\"{!
                        INSERT {
                            GRAPH ui:tempGraph {
                                ?restoreSearch swa:used ?predicate .
                            } .
                        }
                        WHERE {
                        } }\"/>
            </ui:if>
        </ui:group>
    </ui:if>
    <ui:else>
        <b>ERROR: No ObjectFacet found for {= ui:label(?predicate) } at {= ui:label(swa:resourceType()) } and range {= swa:localRangeAtClass(swa:resourceType(), ?predicate) }</b>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """An object widget representing a facet on a search form.

ObjectFacets should support restoring their state from a \"saved search\" (instance of search:Search). See the existing widgets for example source code."""^^xsd:string ;
  rdfs:label "Object facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidget ;
.
swa:ObjectFacetClass
  rdf:type rdfs:Class ;
  rdfs:comment "The metaclass of object facets."^^xsd:string ;
  rdfs:label "Object facet class"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidgetClass ;
.
swa:ObjectFacetRow
  rdf:type swa:ObjectWidgetRowClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <table>
        <tr>
            <td class=\"swa-widget-span\" id=\"{= ?uid }\" style=\"vertical-align: top\">
                <ui:loadable ui:loadId=\"{= ?uid }-loadable\">
                    <input name=\"facet{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?predicate) }\"/>
                    <ui:group let:subjectVarName=\"{= ui:contextValue(&quot;subjectVarName&quot;) }\">
                        <ui:if ui:condition=\"{= bound(?subjectVarName) }\">
                            <input name=\"subject{= ?uid }\" type=\"hidden\" value=\"{= ?subjectVarName }\"/>
                        </ui:if>
                    </ui:group>
                    <ui:if ui:condition=\"{= bound(?selectedWidget) }\">
                        <ui:dynamicView arg:predicate=\"{= ?predicate }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?selectedWidget }\"/>
                    </ui:if>
                    <ui:else>
                        <swa:ObjectFacet arg:predicate=\"{= ?predicate }\" arg:uid=\"{= ?uid }\"/>
                    </ui:else>
                </ui:loadable>
            </td>
            <td let:buttonId=\"facetSelector-{= ?uid }\" style=\"vertical-align: top\">
                <div class=\"swa-facet-selector\" id=\"{= ?buttonId }\" onclick=\"swa.openFacetSelectionMenu('{= ?buttonId }', '{= ?uid }', '{= swa:resourceType() }', '{= ?predicate }')\" title=\"Alternative filters\"/>
            </td>
        </tr>
    </table>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Object facet row"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidgetRow ;
.
swa:ObjectFacetWidgets
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "actionName"^^xsd:string ;
          ]
          [
            sp:varName "actionLocalName"^^xsd:string ;
          ]
          [
            sp:varName "onSelect"^^xsd:string ;
          ]
          [
            sp:varName "enabled"^^xsd:string ;
          ]
          [
            sp:varName "group"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
          [
            sp:varName "iconClass"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:SubQuery ;
                  sp:query [
                      rdf:type sp:Select ;
                      sp:orderBy (
                          [
                            rdf:type sp:Desc ;
                            sp:expression [
                                sp:varName "weight"^^xsd:string ;
                              ] ;
                          ]
                        ) ;
                      sp:where (
                          [
                            sp:object [
                                sp:varName "label"^^xsd:string ;
                              ] ;
                            sp:predicate swa:objectFacetMenuName ;
                            sp:subject [
                                sp:varName "widgetClass"^^xsd:string ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "w"^^xsd:string ;
                              ] ;
                            sp:predicate swa:objectWidgetWeight ;
                            sp:subject [
                                sp:varName "widgetClass"^^xsd:string ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "expression"^^xsd:string ;
                              ] ;
                            sp:predicate swa:expression ;
                            sp:subject [
                                sp:varName "w"^^xsd:string ;
                              ] ;
                          ]
                          [
                            rdf:type sp:Bind ;
                            sp:expression [
                                rdf:type sp:coalesce ;
                                sp:arg1 [
                                    rdf:type spl:object ;
                                    sp:arg1 [
                                        sp:varName "w"^^xsd:string ;
                                      ] ;
                                    sp:arg2 swa:weight ;
                                  ] ;
                                sp:arg2 0 ;
                              ] ;
                            sp:variable [
                                sp:varName "weight"^^xsd:string ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type spin:eval ;
                      sp:arg1 [
                          sp:varName "expression"^^xsd:string ;
                        ] ;
                      sp:arg2 arg:predicate ;
                      sp:arg3 [
                          sp:varName "predicate"^^xsd:string ;
                        ] ;
                      sp:arg4 arg:range ;
                      sp:arg5 [
                          sp:varName "range"^^xsd:string ;
                        ] ;
                      sp:arg6 arg:resourceType ;
                      sp:arg7 [
                          sp:varName "resourceType"^^xsd:string ;
                        ] ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      sp:varName "widgetClass"^^xsd:string ;
                    ] ;
                  sp:variable [
                      sp:varName "actionName"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type afn:localname ;
                      sp:arg1 [
                          sp:varName "widgetClass"^^xsd:string ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "actionLocalName"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression "true"^^xsd:boolean ;
                  sp:variable [
                      sp:varName "enabled"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type sp:concat ;
                      sp:arg1 "swa.replaceFacet('" ;
                      sp:arg2 [
                          sp:varName "elementId"^^xsd:string ;
                        ] ;
                      sp:arg3 "', '" ;
                      sp:arg4 [
                          rdf:type xsd:string ;
                          sp:arg1 [
                              sp:varName "widgetClass"^^xsd:string ;
                            ] ;
                        ] ;
                      sp:arg5 "', '" ;
                      sp:arg6 [
                          rdf:type xsd:string ;
                          sp:arg1 [
                              sp:varName "resourceType"^^xsd:string ;
                            ] ;
                        ] ;
                      sp:arg7 "', '" ;
                      sp:arg8 [
                          rdf:type xsd:string ;
                          sp:arg1 [
                              sp:varName "predicate"^^xsd:string ;
                            ] ;
                        ] ;
                      sp:arg9 "')" ;
                    ] ;
                  sp:variable [
                      sp:varName "onSelect"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the surrounding element that shall have its content replaced."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the widget for."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The range class."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type on the form."^^xsd:string ;
    ] ;
  rdfs:comment "Gets the suitable facet widgets for a drop down menu."^^xsd:string ;
  rdfs:label "Object facet widgets"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ObjectFacetWidgetsCallback
  rdf:type ui:JSONService ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the div holding the current widget."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the widget."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The class on the form."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:call arg:elementId=\"{= ?elementId }\" arg:predicate=\"{= ?predicate }\" arg:range=\"{= swa:localRangeAtClass(?resourceType, ?predicate) }\" arg:resourceType=\"{= ?resourceType }\" ui:args=\"template\" ui:template=\"{= swa:ObjectFacetWidgets }\">
    <swon:RSObjectArray arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:label "Object facet widgets callback"^^xsd:string ;
  rdfs:subClassOf swa:MenuElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:ObjectGroupElements
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The title label."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract superclass serving as base for various object groups."^^xsd:string ;
  rdfs:label "Object group elements"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:ObjectPredicateSelectionTemplates
  rdf:type spin:SelectTemplate ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject."^^xsd:string ;
    ] ;
  rdfs:comment "Abstract base class for templates that can be used to select which predicates shall appear on a form, based on a subject or a subject type from the context."^^xsd:string ;
  rdfs:label "Predicate selection templates"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ObjectViewer
  rdf:type swa:ObjectViewerClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div class=\"swa-object-widget\" let:class=\"{= COALESCE(ui:contextValue(&quot;viewWidget&quot;), swa:bestObjectViewerClass(?object, ?predicate, ?subject)) }\">
    <ui:if ui:condition=\"{= bound(?class) }\">
        <ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" ui:class=\"{= ?class }\"/>
    </ui:if>
    <ui:else>
        <ui:if ui:condition=\"{= bound(?object) }\">[Error: no ObjectViewer found for {= ui:label(?subject) }, {= ui:label(?predicate) }, {= ui:label(?object) }]</ui:if>
    </ui:else>
</div>
"""^^ui:Literal ;
  rdfs:comment "A read-only widget displaying a single object."^^xsd:string ;
  rdfs:label "Object viewer"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidget ;
.
swa:ObjectViewerClass
  rdf:type rdfs:Class ;
  rdfs:comment "The metaclass of object viewer elements."^^xsd:string ;
  rdfs:label "Object viewer class"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidgetClass ;
.
swa:ObjectViewerRow
  rdf:type swa:ObjectWidgetRowClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:datatype=\"{= IF(isLiteral(?object), datatype(?object), ?no) }\" let:uid=\"{= ui:uniqueId() }\">
    <div about=\"{= IF(isIRI(?subject), ?subject, ?noBNodes) }\" class=\"swa-widget-row\" content=\"{= IF(isLiteral(?object), ?object, ?no) }\" datatype=\"{= ?datatype }\" href=\"{= IF(isIRI(?object), ?object, ?no) }\" id=\"{= ?uid }\" property=\"{= IF(isLiteral(?object), ui:encodeNode(?predicate), ?no) }\" rel=\"{= IF(isIRI(?object), ui:encodeNode(?predicate), ?no) }\" ui:addNamespace=\"{= IF(swa:hasPrefix(?predicate), ?predicate, ?none) }\">
        <swa:ObjectViewer arg:uid=\"{= ?uid }\" ui:args=\"*\"/>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A row in an ObjectViewer."^^xsd:string ;
  rdfs:label "Object viewer row"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidgetRow ;
.
swa:ObjectWidget
  rdf:type swa:ObjectWidgetClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:object ;
      rdfs:comment "The object to display or edit."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid used to identify the triple."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" ui:class=\"{= swa:modeProperty(swa:objectWidgetClass) }\"/>
"""^^ui:Literal ;
  rdfs:comment "A component representing a single RDF node. Depending on the mode, this may for example be an ObjectViewer or ObjectEditor."^^xsd:string ;
  rdfs:label "Object widget"^^xsd:string ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:ObjectWidgetClass
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass of the various object widget types."^^xsd:string ;
  rdfs:label "Object widget class"^^xsd:string ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:ObjectWidgetMiddleColumn
  rdf:type swa:ObjectWidgetMiddleColumnClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:editWidget ;
      spl:valueType swa:ObjectEditorClass ;
      rdfs:comment "The preferred widget if in edit mode."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchWidget ;
      spl:valueType swa:ObjectFacetClass ;
      rdfs:comment "The preferred facet widget."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True whether the surrounding widget has at most one value."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:viewWidget ;
      spl:valueType swa:ObjectViewerClass ;
      rdfs:comment "The preferred widget if in view mode."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid of the surrounding widget."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Base class of the elements that can show up as middle column between the label and the actual widgets on a form. The selection of the particular middle column element is made through the mode property swa:objectWidgetMiddleColumnClass."^^xsd:string ;
  rdfs:label "Object widget middle column"^^xsd:string ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:ObjectWidgetMiddleColumnClass
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass of the various object widget middle column types."^^xsd:string ;
  rdfs:label "Object widget middle column class"^^xsd:string ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:ObjectWidgetRow
  rdf:type swa:ObjectWidgetRowClass ;
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:object ;
      rdfs:comment "The object node."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" ui:class=\"{= swa:modeProperty(swa:objectWidgetRowClass) }\"/>
"""^^ui:Literal ;
  rdfs:comment "Superclass for the widget row types."^^xsd:string ;
  rdfs:label "Object widget row"^^xsd:string ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:ObjectWidgetRowClass
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass for ObjectWidgetRows."^^xsd:string ;
  rdfs:label "Object widget row class"^^xsd:string ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:Objects
  rdf:type ui:NodeClass ;
  ui:prototype """
<ui:group let:function=\"{= swa:modeProperty(swa:isSingleFunction) }\">
    <swa:LabeledObjects arg:single=\"{= IF(bound(?function), spif:invoke(?function, ?predicate, ?subject), swa:modeProperty(swa:isSingleConstant)) }\" ui:args=\"*\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A two-columned structure with a label on the left and zero or more objects on the right."^^xsd:string ;
  rdfs:label "Objects"^^xsd:string ;
  rdfs:subClassOf swa:AbstractObject ;
.
swa:ObjectsBody
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to allow at most one value."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:dynamicView arg:predicate=\"{= ?predicate }\" arg:single=\"{= ?single }\" arg:subject=\"{= ?subject }\" ui:class=\"{= COALESCE(swa:modeProperty(swa:objectsBodyClass), swa:DefaultObjectsBody) }\"/>
"""^^ui:Literal ;
  rdfs:comment "The body of an Object(s) widget, typically containing one row for each value. This can be \"overloaded\" via a mode property."^^xsd:string ;
  rdfs:label "Objects body"^^xsd:string ;
  rdfs:subClassOf swa:ObjectElements ;
.
swa:ObjectsEnum
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:hideIfEmpty ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to hide the whole group if the subject has no value for any property in it."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:open ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If arg:openable=\"true\" then this can be set to true to have the content visible by default."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:openable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have an open/close icon appear next to the label. Requires a label to be present. The content will appear hidden by default, but arg:open=\"true\" can be used to control the initial state."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource to display."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= ((((!bound(?subject)) || swa:isEditMode()) || (COALESCE(?hideIfEmpty, false) = false)) || swa:subjectHasObjectFromEnum(?subject, ?thisParent)) || swa:objectHasSubjectFromEnum(?subject, ?thisParent) }\">
    <div class=\"swa-objects-group\" let:bodyId=\"{= ui:uniqueId() }\">
        <ui:if ui:condition=\"{= ?openable }\">
            <div class=\"swa-sub-title\" let:id=\"{= ui:uniqueId() }\">
                <div class=\"swa-objects-enum-icon ui-icon ui-icon-triangle-1-{= IF((bound(?open) &amp;&amp; ?open), &quot;s&quot;, &quot;e&quot;) }\" id=\"{= ?id }\" onclick=\"swa.toggleObjectsEnum('{= ?bodyId }', '{= ?id }')\"/>
                <div style=\"float: left\">{= ?label }</div>
                <div style=\"clear: both\"/>
            </div>
        </ui:if>
        <ui:elseif ui:condition=\"{= bound(?label) }\">
            <div class=\"swa-sub-title\">{= ?label }</div>
        </ui:elseif>
        <div id=\"{= ?bodyId }\" style=\"{= IF((?openable &amp;&amp; ((!bound(?open)) || (!?open))), &quot;display: none&quot;, ?none) }\">
            <ui:insertionPoint ui:pointId=\"body\"/>
        </div>
    </div>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A container around a finite list of swa:Objects (or swa:Subjects) elements - not computed through a filter function but explicitly enumerated. Can be used in conjunction with swa:ObjectsPlaceholder. By default all swa:Objects inside of an ObjectsEnum are displayed under a simple title. However, if arg:openable=\"true\" then the body can be expanded and collapsed via an arrow icon. This can be used to organize forms into optional sections."^^xsd:string ;
  rdfs:label "Objects enum"^^xsd:string ;
  rdfs:subClassOf swa:ObjectGroupElements ;
.
swa:ObjectsGroup
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function that takes a predicate and a subject as arguments and returns true for all predicates that should be displayed."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicates ;
      spl:valueType sp:Select ;
      rdfs:comment "A result set (e.g., SPARQL SELECT query) that delivers the predicates in this group."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group letrs:rs=\"{#
        SELECT ?predicate
        WHERE {
            ( ?predicates 0 ) spr:colCells ?predicate .
            FILTER ((!bound(?filterFunction)) || spif:invoke(?filterFunction, ?predicate, ?subject)) .
            FILTER (!swa:isHiddenPropertyAtSubject(?predicate, ?subject)) .
        } }\">
    <ui:if ui:condition=\"{= spr:rowCount(?rs) &gt; 0 }\">
        <div class=\"swa-objects-group\">
            <ui:if ui:condition=\"{= bound(?label) }\">
                <div class=\"swa-sub-title\">{= ?label }</div>
            </ui:if>
            <ui:forEach ui:resultSet=\"{= ?rs }\">
                <swa:Objects arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" arg:tabular=\"{= true }\"/>
            </ui:forEach>
        </div>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A group of swa:Objects elements where the predicates are computed by taking a result set (e.g. of all relevant properties) and applying a filter on top of it, e.g. to only show the annotation properties among those that are relevant."^^xsd:string ;
  rdfs:label "Objects group"^^xsd:string ;
  rdfs:subClassOf swa:ObjectGroupElements ;
.
swa:ObjectsPlaceholder
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function that takes a predicate and a subject as arguments and returns true for all predicates that should be displayed. If no function is specified then all \"other\" predicates will be shown."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:open ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If arg:openable=\"true\" then this can be set to true to have the content visible by default."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:openable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have an open/close icon appear next to the label. Requires a label to be present. The content will appear hidden by default, but arg:open=\"true\" can be used to control the initial state."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject resource to display."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:call arg:subject=\"{= ?subject }\" let:rootView=\"{= swa:rootView(?thisParent) }\" ui:template=\"{= swa:modeProperty(swa:formObjectPredicateSelectionTemplate) }\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    ?thisParent swa:used ?predicate .
                } .
            }
            WHERE {
                ?rootView swa:predicatesOfObjects ?predicate .
            } }\"/>
    <ui:group letrs:rs=\"{#
            SELECT ?predicate
            WHERE {
                ( ?rs 0 ) spr:colCells ?predicate .
                FILTER NOT EXISTS {
                    GRAPH ui:tempGraph {
                        ?thisParent swa:used ?predicate .
                    } .
                } .
                FILTER (!swa:isHiddenPropertyAtSubject(?predicate, ?subject)) .
                FILTER ((!bound(?filterFunction)) || spif:invoke(?filterFunction, ?predicate, ?subject)) .
            } }\">
        <ui:if ui:condition=\"{= spr:rowCount(?rs) &gt; 0 }\">
            <div class=\"swa-objects-group\" let:bodyId=\"{= ui:uniqueId() }\">
                <ui:if ui:condition=\"{= ?openable }\">
                    <div class=\"swa-sub-title\" let:id=\"{= ui:uniqueId() }\">
                        <div class=\"swa-objects-enum-icon ui-icon ui-icon-triangle-1-{= IF((bound(?open) &amp;&amp; ?open), &quot;s&quot;, &quot;e&quot;) }\" id=\"{= ?id }\" onclick=\"swa.toggleObjectsEnum('{= ?bodyId }', '{= ?id }')\"/>
                        <div style=\"float: left\">{= ?label }</div>
                        <div style=\"clear: both\"/>
                    </div>
                </ui:if>
                <ui:elseif ui:condition=\"{= bound(?label) }\">
                    <div class=\"swa-sub-title\">{= ?label }</div>
                </ui:elseif>
                <div id=\"{= ?bodyId }\" style=\"{= IF((?openable &amp;&amp; ((!bound(?open)) || (!?open))), &quot;display: none&quot;, ?none) }\">
                    <ui:forEach ui:resultSet=\"{= ?rs }\">
                        <swa:Objects arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" arg:tabular=\"{= true }\"/>
                    </ui:forEach>
                </div>
            </div>
        </ui:if>
    </ui:group>
</ui:call>
"""^^ui:Literal ;
  rdfs:comment "Inserts Objects for all \"other\" properties for the given subject. This includes all properties that are not mentioned explicitly through other swa:Objects elements on the surrounding element tree. A filter function can be provided to further exclude certain properties that shouldn't be visible at all."^^xsd:string ;
  rdfs:label "Objects placeholder"^^xsd:string ;
  rdfs:subClassOf swa:ObjectGroupElements ;
.
swa:OneOfItems
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "item"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "oneOf"^^xsd:string ;
              ] ;
            sp:predicate owl:oneOf ;
            sp:subject [
                sp:varName "resource"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "item"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:SeqPath ;
                sp:path1 [
                    rdf:type sp:ModPath ;
                    sp:modMax -2 ;
                    sp:modMin 0 ;
                    sp:subPath rdf:rest ;
                  ] ;
                sp:path2 rdf:first ;
              ] ;
            sp:subject [
                sp:varName "oneOf"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The datatype or class."^^xsd:string ;
    ] ;
  rdfs:comment "Given an rdfs:Datatype or enumerated class, returns the members of the owl:oneOf enumeration."^^xsd:string ;
  rdfs:label "oneOf items"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ParamsDialog
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:dataGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The data graph."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:callback ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript expression that shall be evaluated if the user Oks the dialog. This expression can access the params from the server using the variable 'data'. For example to simply apply the edits, make it \"swa.processEdits(data)\"."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The title label of the dialog."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the resulting ui:loadable."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resource to create."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:loadable ui:loadId=\"{= ?loadId }\">
    <ui:if ui:condition=\"{= bound(?resourceType) }\">
        <div id=\"div-{= ?loadId }\" title=\"{= ?label }\">
            <ui:setContext ui:queryGraph=\"{= ui:graph }\" ui:varName=\"dataGraph\" ui:varValue=\"{= ui:currentQueryGraph() }\">
                <swa:CreateForm arg:formId=\"{= ?loadId }-form\" arg:resourceType=\"{= ?resourceType }\" arg:resourceURI=\"urn:x-swa:Dummy\"/>
            </ui:setContext>
            <div class=\"swa-dialog-button-bar\">
                <button onclick=\"swa.submitParamsDialog('{= ?loadId }', &quot;{= ui:escapeJSON(?callback) }&quot;)\">OK</button>
                <swa:Space/>
                <button onclick=\"swa.closeDialog('{= ?loadId }')\">Cancel</button>
            </div>
        </div>
    </ui:if>
</ui:loadable>
"""^^ui:Literal ;
  rdfs:comment "A dialog that displays an edit form (swa:CreateForm) for a new instance of a given class. When the user presses the OK button, it will translate the edited values into a set of parameters (name-value-pairs) using a server callback. The resulting parameters can then be used to invoke another service such as an SWP request or a SPARQLMotion script."^^xsd:string ;
  rdfs:label "Params dialog"^^xsd:string ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:PasswordEditor
  rdf:type swa:ObjectEditorClass ;
  ui:prototype """
<swa:AbstractTextFieldEditor arg:inputType=\"password\" arg:suppressLanguage=\"{= true }\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "Similar to TextFieldEditor but with a password field instead of a normal text field - the entered characters are not visible to the user. This widget has no weight - in order to use it on a form you could use <swa:Object swa:editWidget=\"swa:PasswordEditor\" ... />."^^xsd:string ;
  rdfs:label "Password editor"^^xsd:string ;
  rdfs:subClassOf swa:AbstractTextFieldEditor ;
.
swa:PasswordViewer
  rdf:type swa:ObjectViewerClass ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <ui:if ui:condition=\"{= bound(?object) &amp;&amp; isLiteral(?object) }\">
        <ui:forEach ui:resultSet=\"{#
                SELECT ?i
                WHERE {
                    BIND (fn:string-length(xsd:string(?object)) AS ?length) .
                    ?i spif:for ( 0 ?length ) .
                } }\">?</ui:forEach>
    </ui:if>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer for passwords that replaces all characters with a special dot symbol."^^xsd:string ;
  rdfs:label "Password viewer"^^xsd:string ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:PlainTextFieldEditor
  rdf:type swa:ObjectEditorClass ;
  ui:prototype """
<swa:AbstractTextFieldEditor arg:inputType=\"text\" arg:suppressLanguage=\"{= true }\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "A text field without the ability to enter a language tag. This can be selected \"manually\" on forms, using arg:editWidget."^^xsd:string ;
  rdfs:label "Plain text field editor"^^xsd:string ;
  rdfs:subClassOf swa:AbstractTextFieldEditor ;
.
swa:ProgressJSONCallback
  rdf:type ui:Service ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the progress to check."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group>{= ui:progressJSON(?id) }</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A service used by the SWA progress bars."^^xsd:string ;
  rdfs:label "Progress JSON callback"^^xsd:string ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:PropertyFormBody
  rdf:type ui:ResourceViewClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group default:subject=\"{= ?resource }\">
    <ui:call arg:subject=\"{= ?resource }\" ui:template=\"{= swa:modeProperty(swa:formObjectPredicateSelectionTemplate) }\">
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isAnnotationProperty }\" arg:label=\"Annotations\" arg:predicates=\"{= ?rs }\"/>
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isPropertyAxiomProperty }\" arg:label=\"Property Axioms\" arg:predicates=\"{= ?rs }\"/>
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isNonPropertyAxiomProperty }\" arg:label=\"Properties\" arg:predicates=\"{= ?rs }\"/>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default view for rdf:Property, with widget groups for Annotation Properties, Property Axioms and Other Properties."^^xsd:string ;
  rdfs:label "Property form body"^^xsd:string ;
  rdfs:subClassOf swa:FormBody ;
.
swa:PropertyLabel
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "An id for the resulting span, in case you ever need to reference it."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:inverse ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have the label surrounded by \"is ... of\"."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to display."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label to display."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= ?inverse }\">
        <span class=\"swa-property-label-inverse\">is </span>
        <span class=\"swa-property-label\" id=\"{= ?id }\">{= ?label }</span>
        <span class=\"swa-property-label-inverse\"> of</span>
        <span class=\"swa-property-label\">:</span>
    </ui:if>
    <ui:else>
        <span class=\"swa-property-label\" id=\"{= ?id }\">{= ?label }:</span>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The label used to display the name of the property on a form, consisting of the property's label and a column. Should also be used to display properties elsewhere to have a central implementation that could be overloaded etc."^^xsd:string ;
  rdfs:label "Property label"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:RegexStringFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:RegexFacetValue ;
  swa:objectFacetMenuName "text contains"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:or ;
          sp:arg1 [
              rdf:type sp:not ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type swa:isDatatypeRange ;
                  arg:range [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type swa:hasMatchingRestoreFacetValue ;
                  arg:facetClass swa:RegexStringFacet ;
                  arg:property [
                      sp:varName "predicate"^^xsd:string ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:datatype=\"{= swa:localRange(?predicate, ?subject) }\" let:restore=\"{= swa:restoreFacetValue(?predicate) }\">
    <input class=\"{= swa:testClass(?predicate) }\" name=\"regex{= ?uid }\" type=\"text\" value=\"{= IF(bound(?restore), spl:object(?restore, search:pattern), ?none) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An ObjectFacet showing a text field. The resulting string will be matched against as a regex."^^xsd:string ;
  rdfs:label "Regex string facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:ResourceAction
  rdf:type rdfs:Class ;
  rdfs:comment """An action that can be applied to a given Resource, e.g. the selected node of a tree or the subject on a form. In the executing JavaScript, the variable resourceURI points to the URI of the selected resource from the menu.

Note that when selecting suitable actions, the execution engine will evaluate the condition on the ui:unionGraph, which may include more triples than expected by the engine. The expression may want to switch to the current domain model using ui:currentQueryGraph() instead."""^^xsd:string ;
  rdfs:label "Resource action"^^xsd:string ;
  rdfs:subClassOf swa:Action ;
.
swa:ResourceActions
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "group"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "actionName"^^xsd:string ;
          ]
          [
            sp:varName "actionLocalName"^^xsd:string ;
          ]
          [
            sp:varName "onSelect"^^xsd:string ;
          ]
          [
            sp:varName "enabled"^^xsd:string ;
          ]
          [
            sp:varName "group"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
          [
            sp:varName "iconClass"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                (
                  [
                    sp:object swa:ResourceAction ;
                    sp:predicate rdf:type ;
                    sp:subject [
                        sp:varName "action"^^xsd:string ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "label"^^xsd:string ;
                      ] ;
                    sp:predicate rdfs:label ;
                    sp:subject [
                        sp:varName "action"^^xsd:string ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "condition"^^xsd:string ;
                      ] ;
                    sp:predicate arg:condition ;
                    sp:subject [
                        sp:varName "action"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type ui:encodeNode ;
                        sp:arg1 [
                            sp:varName "action"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "actionName"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type afn:localname ;
                        sp:arg1 [
                            sp:varName "action"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "actionLocalName"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type spl:object ;
                        sp:arg1 [
                            sp:varName "action"^^xsd:string ;
                          ] ;
                        sp:arg2 arg:onSelect ;
                      ] ;
                    sp:variable [
                        sp:varName "onSelectRaw"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:coalesce ;
                        sp:arg1 [
                            sp:varName "onSelectRaw"^^xsd:string ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:if ;
                            sp:arg1 [
                                rdf:type swa:hasOtherArgument ;
                                spl:class [
                                    sp:varName "action"^^xsd:string ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                rdf:type sp:concat ;
                                sp:arg1 "swa.openHandlerDialog(\"" ;
                                sp:arg2 [
                                    rdf:type ui:escapeJSON ;
                                    sp:arg1 [
                                        sp:varName "label"^^xsd:string ;
                                      ] ;
                                  ] ;
                                sp:arg3 "\", \"<" ;
                                sp:arg4 [
                                    rdf:type xsd:string ;
                                    sp:arg1 [
                                        sp:varName "action"^^xsd:string ;
                                      ] ;
                                  ] ;
                                sp:arg5 ">\", \"" ;
                                sp:arg6 [
                                    rdf:type ui:escapeJSON ;
                                    sp:arg1 [
                                        rdf:type xsd:string ;
                                        sp:arg1 [
                                            sp:varName "resource"^^xsd:string ;
                                          ] ;
                                      ] ;
                                  ] ;
                                sp:arg7 "\")" ;
                              ] ;
                            sp:arg3 [
                                sp:varName "none"^^xsd:string ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "onSelect"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:coalesce ;
                        sp:arg1 [
                            rdf:type spl:object ;
                            sp:arg1 [
                                sp:varName "action"^^xsd:string ;
                              ] ;
                            sp:arg2 arg:group ;
                          ] ;
                        sp:arg2 "" ;
                      ] ;
                    sp:variable [
                        sp:varName "group"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type spl:object ;
                        sp:arg1 [
                            sp:varName "action"^^xsd:string ;
                          ] ;
                        sp:arg2 arg:iconClass ;
                      ] ;
                    sp:variable [
                        sp:varName "iconClass"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type spl:object ;
                        sp:arg1 [
                            sp:varName "action"^^xsd:string ;
                          ] ;
                        sp:arg2 arg:appName ;
                      ] ;
                    sp:variable [
                        sp:varName "actionAppName"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:if ;
                        sp:arg1 [
                            rdf:type sp:bound ;
                            sp:arg1 [
                                sp:varName "actionAppName"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            rdf:type swa:hasAppName ;
                            sp:arg1 [
                                sp:varName "appName"^^xsd:string ;
                              ] ;
                            sp:arg2 [
                                sp:varName "actionAppName"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg3 [
                            rdf:type sp:or ;
                            sp:arg1 [
                                rdf:type sp:not ;
                                sp:arg1 [
                                    rdf:type sp:bound ;
                                    sp:arg1 [
                                        sp:varName "appName"^^xsd:string ;
                                      ] ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                rdf:type sp:eq ;
                                sp:arg1 [
                                    sp:varName "appName"^^xsd:string ;
                                  ] ;
                                sp:arg2 "" ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spin:eval ;
                      sp:arg1 [
                          sp:varName "condition"^^xsd:string ;
                        ] ;
                      sp:arg2 arg:resource ;
                      sp:arg3 [
                          sp:varName "resource"^^xsd:string ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "enabled"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:bound ;
                      sp:arg1 [
                          sp:varName "enabled"^^xsd:string ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The current app name."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The Resource to get the actions for."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:label "Resource actions"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:ResourceActionsButton
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional id for the button."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to apply the action(s) on. If left blank, then a getter expression must be provided."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resourceGetter ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript expression that is evaluated to return the URI of the selected resource."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:style ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional CSS style for the button."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional tool tip text to appear on the button."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:id=\"{= COALESCE(?id, ui:uniqueId()) }\">
    <button class=\"swa-button swa-resource-actions-button\" id=\"{= ?id }\" onclick=\"swa.openResourceActionsMenu('{= ?id }', '{= IF(bound(?resourceGetter), ?resourceGetter, fn:concat(&quot;\\&quot;&quot;, xsd:string(?resource), &quot;\\&quot;&quot;)) }', '{= ui:currentQueryGraph() }', '{= swa:appName() }')\" style=\"{= ?style }\" title=\"{= ?toolTip }\">
        <div class=\"ui-icon ui-icon-gear\"/>
    </button>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A Button displaying a popup menu when pressed, consisting of ResourceActions for a given resource. The resource is either a constant or delivered dynamically through a (JavaScript) getter expression."^^xsd:string ;
  rdfs:label "Resource actions button"^^xsd:string ;
  rdfs:subClassOf swa:MenuElements ;
.
swa:ResourceActionsCallback
  rdf:type ui:JSONService ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The current app name to narrow down the results."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the actions of."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:call arg:appName=\"{= ?appName }\" arg:resource=\"{= ?resource }\" ui:template=\"{= swa:ResourceActions }\">
    <swon:RSObjectArray arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:label "Resource actions callback"^^xsd:string ;
  rdfs:subClassOf swa:MenuElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:ResourceDestructor
  rdf:type swa:Destructor ;
  ui:prototype """
<ui:if ui:condition=\"{= NOT EXISTS {
    GRAPH ui:tempGraph {
        swa:DestructorMetadata swa:visited ?resource .
    } .
} }\">
    <ui:update ui:updateQuery=\"{!
            INSERT {
                GRAPH ui:tempGraph {
                    swa:DestructorMetadata swa:visited ?resource .
                } .
            }
            WHERE {
            } }\"/>
    <ui:resourceView ui:matchIds=\"destructor\" ui:resource=\"{= ?resource }\"/>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A helper element that can be used to collect all triples that need to be deleted if a given resource is to be deleted. This remembers metadata about whether it has already \"seen\" a given resource, thus avoiding infinite loops."^^xsd:string ;
  rdfs:label "Resource destructor"^^xsd:string ;
  rdfs:subClassOf swa:Destructors ;
.
swa:ResourceEditHandlers
  rdf:type swa:EditHandlerClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to execute the action on."^^xsd:string ;
    ] ;
  rdfs:label "Resource edit handlers"^^xsd:string ;
  rdfs:subClassOf swa:EditHandlers ;
.
swa:ResourceEnumDropDownEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:bound ;
              sp:arg1 [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:isResourceEnumeration ;
              arg:resource [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<swa:AbstractEnumDropDownEditor ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Resource enum drop down editor"^^xsd:string ;
  rdfs:subClassOf swa:AbstractEnumDropDownEditor ;
.
swa:ResourceEnumDropDownFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:objectFacetMenuName "drop down list"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:bound ;
              sp:arg1 [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:isResourceEnumeration ;
              arg:resource [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<swa:AbstractEnumDropDownFacet ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Resource enum drop down facet"^^xsd:string ;
  rdfs:subClassOf swa:AbstractEnumDropDownFacet ;
.
swa:ResourceEnumRadioButtonsEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:bound ;
              sp:arg1 [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:isResourceEnumeration ;
              arg:resource [
                  sp:varName "range"^^xsd:string ;
                ] ;
            ] ;
        ] ;
      swa:weight 6 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<swa:AbstractRadioButtonsEditor ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:label "Resource enum radio buttons editor"^^xsd:string ;
  rdfs:subClassOf swa:AbstractRadioButtonsEditor ;
.
swa:ResourceFormBody
  rdf:type ui:ResourceViewClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <ui:call arg:subject=\"{= ?resource }\" ui:template=\"{= swa:modeProperty(swa:formObjectPredicateSelectionTemplate) }\">
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isAnnotationProperty }\" arg:label=\"Annotations\" arg:predicates=\"{= ?rs }\" arg:subject=\"{= ?resource }\"/>
        <swa:ObjectsGroup arg:filterFunction=\"{= swa:isNonAnnotationProperty }\" arg:label=\"Properties\" arg:predicates=\"{= ?rs }\" arg:subject=\"{= ?resource }\"/>
    </ui:call>
    <ui:call arg:object=\"{= ?resource }\" ui:template=\"{= swa:modeProperty(swa:formSubjectPredicateSelectionTemplate) }\">
        <swa:SubjectsGroup arg:label=\"Incoming References\" arg:object=\"{= ?resource }\" arg:predicates=\"{= ?rs }\"/>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The default view for rdfs:Resource, with widget groups for Annotation Properties and Other Properties."^^xsd:string ;
  rdfs:label "Resource form body"^^xsd:string ;
  rdfs:subClassOf swa:FormBody ;
.
swa:ResourceSelectionDialog
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label of the dialog."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:callback ;
      spl:valueType xsd:string ;
      rdfs:comment "A callback expression to invoke when the resource has been selected. The variable 'resource' will contain the selected resource, and 'label' its label."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the resulting ui:loadable."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resources to select."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div id=\"div-{= ?loadId }\" title=\"{= COALESCE(?label, fn:concat(&quot;Select &quot;, ui:label(?resourceType))) }\">
    <swa:LabeledElement arg:label=\"{= ui:label(?resourceType) }\">
        <swa:AutoComplete arg:onSelect=\"swa.closeDialog(&quot;{= ?loadId }&quot;);eval({= ?callback });\" arg:type=\"{= ?resourceType }\"/>
    </swa:LabeledElement>
    <div class=\"swa-dialog-button-bar\">
        <button onclick=\"swa.closeDialog('{= ?loadId }')\">Cancel</button>
    </div>
</div>
"""^^ui:Literal ;
  rdfs:comment "A dialog that can be used to select a single resource with a given type. Currently only shows an auto-complete box, but future versions may also have a tree of classes and a grid of instances per class."^^xsd:string ;
  rdfs:label "Resource selection dialog"^^xsd:string ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:ResourceSubjectEditor
  rdf:type swa:SubjectEditorClass ;
  swa:subjectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:or ;
          sp:arg1 [
              rdf:type sp:not ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "subject"^^xsd:string ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type sp:isIRI ;
              sp:arg1 [
                  sp:varName "subject"^^xsd:string ;
                ] ;
            ] ;
        ] ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:domain=\"{= swa:localDomain(?object, ?predicate) }\">
    <swa:AutoComplete arg:class=\"swa-text-field\" arg:id=\"new-{= ?uid }\" arg:initialValue=\"{= ?subject }\" arg:type=\"{= ?domain }\" arg:withSelectMenu=\"{= true }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A SubjectEditor based on an AutoComplete widget."^^xsd:string ;
  rdfs:label "Resource subject editor"^^xsd:string ;
  rdfs:subClassOf swa:SubjectEditor ;
.
swa:ResourceSubjectFacet
  rdf:type swa:SubjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:subjectFacetMenuName "equals"^^xsd:string ;
  swa:subjectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type swa:hasMatchingInverseRestoreFacetValue ;
          arg:facetClass swa:ResourceSubjectFacet ;
          arg:property [
              sp:varName "predicate"^^xsd:string ;
            ] ;
        ] ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:restore=\"{= swa:restoreInverseFacetValue(?predicate) }\">
    <swa:AutoComplete arg:id=\"value{= ?uid }\" arg:initialValue=\"{= IF(bound(?restore), spl:object(?restore, search:object), ?none) }\" arg:type=\"{= swa:localDomain(?none, ?predicate) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Resource subject facet"^^xsd:string ;
  rdfs:subClassOf swa:SubjectFacet ;
.
swa:ResourceSummary
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:defaultImage ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional default image to be used if no swa:summaryImage can be found."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display."^^xsd:string ;
    ] ;
  ui:prototype """
<table class=\"swa-resource-summary\" let:searchGraph=\"{= ui:contextValue(&quot;searchGraph&quot;) }\">
    <tr let:description=\"{= swa:getDescription(?this) }\" let:image=\"{= COALESCE(swa:getThumbnail(?this), ?defaultImage) }\">
        <td default:subject=\"{= ?this }\" default:tabular=\"{= true }\" style=\"width: 100%\" valign=\"top\">
            <div class=\"swa-title\">{= ui:label(?this) }</div>
            <ui:if ui:condition=\"{= bound(?description) }\">
                <div class=\"swa-resource-summary-description\">{= swa:abbreviatedText(?description, 150) }</div>
            </ui:if>
            <ui:if ui:condition=\"{= bound(?searchGraph) }\">
                <ui:forEach ui:resultSet=\"{#
                        SELECT ?property
                        WHERE {
                            ?searchGraph search:columnPropertiesFromTheSearch ?property .
                        } }\">
                    <swa:Objects arg:predicate=\"{= ?property }\" arg:subject=\"{= ?this }\" arg:tabular=\"{= true }\"/>
                </ui:forEach>
            </ui:if>
        </td>
        <ui:if ui:condition=\"{= bound(?image) }\">
            <td class=\"swa-resource-summary-image-cell\" valign=\"top\">
                <img class=\"swa-resource-summary-image\" src=\"{= ?image }\"/>
            </td>
        </ui:if>
    </tr>
</table>
"""^^ui:Literal ;
  rdfs:comment "The default summary view (in particular used by swa:SummarySearchResultsGadget)."^^xsd:string ;
  rdfs:label "Resource summary"^^xsd:string ;
  rdfs:subClassOf ui:ResourceViews ;
.
swa:ResourceViewDialog
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the ui:loadable that will be placed around the dialog."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:loadable ui:loadId=\"{= ?loadId }\">
    <ui:if ui:condition=\"{= bound(?resource) }\">
        <div id=\"div-{= ?loadId }\" title=\"{= ui:label(?resource) }\">
            <ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= swa:createNoLink }\">
                <ui:resourceView ui:resource=\"{= ?resource }\"/>
            </ui:setContext>
        </div>
    </ui:if>
</ui:loadable>
"""^^ui:Literal ;
  rdfs:comment "A dialog that shows the default view of a given resource. This needs to be inserted into the document and will remain initially invisible. The JavaScript call swa.openResourceViewDialog() must be called with the provided loadId and the URI of a resource."^^xsd:string ;
  rdfs:label "Resource view dialog"^^xsd:string ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:ResultSetGrid
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:colWidths ;
      spl:valueType xsd:string ;
      rdfs:comment "A comma-separated list of integers, one for each column, to be used as width."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:hiddenColName ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) name of a column that shall be hidden. This can be used to store a pointer to a resource while the visible columns contain literal values. The invisible column can still be queried in the onSelect handler. In a typical set up, the hidden column is used to represent the URI of a resource, while other properties of that resource are being displayed. For this to work, the usual design pattern is to have a result set where the first column is computed as in BIND (xsd:string(?resource) AS ?resourceURI) and arg:hiddenColName=\"resourceURI\". If the hidden column is a resource, it will be converted to a human-readable label and then not work as expected."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:onDoubleClick ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript event handler (like onSelect) that fires when the user double-clicks on a row."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "JavaScript code that shall be executed if the user selects a row in the grid. In this JavaScript code, the variable data points to a JSON object with fields for each column. For example if your SELECT query starts with SELECT ?result then you can access the currently selected value using data['result']."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The SPARQL ResultSet to display. Note that columns should not be called ?id to avoid a conflict inside of the jqGrid API."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:pagerId=\"{= ui:uniqueId() }\" let:tableId=\"{= ui:uniqueId() }\" letrs:cols=\"{#
        SELECT ?colName
        WHERE {
            ?resultSet spr:colIndices ?colIndex .
            BIND (spr:colName(?resultSet, ?colIndex) AS ?colName) .
            FILTER ((!bound(?hiddenColName)) || (?colName != ?hiddenColName)) .
        } }\">
    <table id=\"{= ?tableId }\"/>
    <div id=\"{= ?pagerId }\"/>
    <script>$(\"#{= ?tableId }\").jqGrid({<ui:if ui:condition=\"{= (!bound(?colWidths)) &amp;&amp; swa:hasNoColWidth(?resultSet) }\">
		autowidth: true,
		</ui:if>
		datatype: \"local\",
		data:<swon:RSObjectArray arg:labelFunction=\"{= ui:label }\" arg:resultSet=\"{= ?resultSet }\"/>
        <ui:if ui:condition=\"{= bound(?colWidths) }\">
            <ui:call arg:resultSet=\"{= ?resultSet }\" ui:template=\"{= swon:ForEachResultSetColumnIndex }\">
                <ui:call arg:string=\"{= ?colWidths }\" ui:template=\"{= swa:SplitCommas }\" ui:varName=\"colWidthsRS\">
                    <swon:Values arg:name=\"colNames\">
                        <ui:forEach ui:resultSet=\"{= ?rs }\" ui:separator=\",\">\"{= ui:escapeJSON(spr:colName(?resultSet, ?colIndex)) }\"</ui:forEach>
                    </swon:Values>
                    <swon:Values arg:name=\"colModel\">
                        <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?rs }\" ui:separator=\",\">
                            <swon:Object>
                                <swon:Value arg:name=\"name\" arg:value=\"{= spr:colName(?resultSet, ?colIndex) }\"/>
                                <swon:Value arg:name=\"width\" arg:value=\"{= spr:cell(?colWidthsRS, ?index, 0) }\"/>
                            </swon:Object>
                        </ui:forEach>
                    </swon:Values>
                </ui:call>
            </ui:call>
        </ui:if>
        <ui:else>
            <swon:Values arg:name=\"colNames\">
                <ui:forEach ui:resultSet=\"{= ?cols }\" ui:separator=\",\">\"{= ui:escapeJSON(?colName) }\"</ui:forEach>
            </swon:Values>
            <swon:Values arg:name=\"colModel\">
                <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?cols }\" ui:separator=\",\">
                    <swon:Object>
                        <ui:group let:type=\"{= spr:colType(?resultSet, ?index) }\" let:width=\"{= spr:colWidth(?resultSet, ?index) }\">
                            <ui:if ui:condition=\"{= bound(?width) &amp;&amp; (?width &gt; 0) }\">
                                <swon:Value arg:name=\"width\" arg:value=\"{= ?width }\"/>
                            </ui:if>
                            <ui:if ui:condition=\"{= swa:isNumericDatatype(?type) }\">
                                <swon:Value arg:name=\"align\" arg:value=\"right\"/>
                            </ui:if>
                            <swon:Value arg:name=\"name\" arg:value=\"{= ?colName }\"/>
                        </ui:group>
                    </swon:Object>
                </ui:forEach>
            </swon:Values>
        </ui:else>
        <ui:if ui:condition=\"{= bound(?onSelect) }\">,onSelectRow: function(rowId) {
		var data= swa.getGridDataItem(this,rowId);
		{= ?onSelect }
	}</ui:if>
        <ui:if ui:condition=\"{= bound(?onDoubleClick) }\">,ondblClickRow: function(rowId) {
	var data= swa.getGridDataItem(this,rowId);
		{= ?onDoubleClick }
	}</ui:if>,rowNum: 10,
		rowList:[5,10,20],
		pager: '#{= ?pagerId }',
		viewrecords: true,
		gridview: true,
		sortorder: \"desc\"
}).jqGrid('navGrid', '#{= ?pagerId }', { add: false, edit: false, del: false});<ui:if ui:condition=\"{= bound(?hiddenColName) }\">$(\"#{= ?tableId }\").hideCol('{= ?hiddenColName }');</ui:if>
    </script>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """A tabular component to display the results of an existing SPARQL result set. This component does not do lazy loading but constructs a static data table from all entries in the result set. Use this only for small data sets.

If the result set has been created from a SPIN template (via ui:call) then the grid will look up the spin:column metadata attached to the template to learn about column titles, width and alignment (numeric columns are right-aligned)."""^^xsd:string ;
  rdfs:label "Result Set Grid"^^xsd:string ;
  rdfs:subClassOf swa:GridElements ;
.
swa:ResultSetLinkList
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:class ;
      spl:valueType xsd:string ;
      rdfs:comment "An additional CSS class for the generated div."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional HTML id for the generated div."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The SPARQL ResultSet to display."^^xsd:string ;
    ] ;
  ui:prototype """
<div class=\"swa-result-set-link-list {= ?class }\" id=\"{= ?id }\">
    <ui:call arg:resultSet=\"{= ?resultSet }\" ui:template=\"{= swon:ForEachResultSetRowIndex }\">
        <ui:forEach ui:resultSet=\"{= ?rs }\">
            <div class=\"swa-result-set-link-item\">
                <swa:Link arg:resource=\"{= spr:cell(?resultSet, ?rowIndex, 0) }\"/>
            </div>
        </ui:forEach>
    </ui:call>
</div>
"""^^ui:Literal ;
  rdfs:comment "A list of vertically stacked hyperlinks to the resources from a result set. Each entry is a div with a hyperlink around the most suitable view with matchId=\"label\". Individual instances can therefore be displayed in a customized rendering, as long as they define an SWP view with ui:id=\"label\". By default this is simply the ui:label of each resource (see rdfs:Resource in SWA)."^^xsd:string ;
  rdfs:label "Result set link list"^^xsd:string ;
  rdfs:subClassOf swa:ListElements ;
.
swa:ResultSetObjectsView
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The label to display on the left."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional tool tip to appear over the label."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set of values to display. The first column will be used only."^^xsd:string ;
    ] ;
  ui:prototype """
<table class=\"swa-labeled-objects-table\" let:id=\"{= ui:uniqueId() }\">
    <tr class=\"swa-labeled-objects-tr\">
        <td class=\"swa-labeled-objects-label-td swa-labeled-objects-tabular-label\">
            <div class=\"swa-shifted-label\">
                <label for=\"{= ?id }\" title=\"{= ?toolTip }\">{= ?label }</label>
            </div>
        </td>
        <td class=\"swa-labeled-objects-icons-td\">
            <span class=\"swa-icon\"/>
        </td>
        <td class=\"swa-labeled-objects-body-td\" id=\"{= ?id }\">
            <div>
                <ui:forEach ui:resultSet=\"{#
                        SELECT ?rowIndex
                        WHERE {
                            ?resultSet spr:rowIndices ?rowIndex .
                        } }\">
                    <div class=\"swa-object-row\">
                        <swa:ObjectViewer arg:object=\"{= spr:cell(?resultSet, ?rowIndex, 0) }\"/>
                    </div>
                </ui:forEach>
            </div>
        </td>
    </tr>
</table>
"""^^ui:Literal ;
  rdfs:comment "A widget that looks like swa:Objects but with its objects taken from a result set, not a subject/property combination. The widget displays a label on the left and rows of object views on the right. It uses the same logic for widget selection like swa:Objects, but only for view mode and not editing."^^xsd:string ;
  rdfs:label "Result set objects view"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:RichTextViewer
  rdf:type swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:isLiteral ;
              sp:arg1 [
                  sp:varName "object"^^xsd:string ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type sp:or ;
              sp:arg1 [
                  rdf:type spl:subPropertyOf ;
                  sp:arg1 [
                      sp:varName "predicate"^^xsd:string ;
                    ] ;
                  sp:arg2 skos:note ;
                ] ;
              sp:arg2 [
                  rdf:type sp:eq ;
                  sp:arg1 [
                      rdf:type sp:datatype ;
                      sp:arg1 [
                          sp:varName "object"^^xsd:string ;
                        ] ;
                    ] ;
                  sp:arg2 rdf:HTML ;
                ] ;
            ] ;
        ] ;
      swa:weight 5 ;
    ] ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <ui:parse ui:str=\"{= swa:redirectHRefs(?object) }\"/>
    <swa:LangDisplay arg:lang=\"{= lang(?object) }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer for HTML-based values. Parses the literal into HTML and inserts that into the document. Links will be redirected using the currently registered createLinkFunction."^^xsd:string ;
  rdfs:label "Rich text viewer"^^xsd:string ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:ScriptElements
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Abstract base class for elements that generate JavaScript snippets (usually in <script> tags)."^^xsd:string ;
  rdfs:label "Script elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:SearchForm
  rdf:type swa:FormClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:cache ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to set the form's body to be cached. This should be used if the ontology/classes do not change at runtime."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id that shall be used for the new form. The system will generate a unique new id if left blank."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:headerLabel ;
      spl:valueType xsd:string ;
      rdfs:comment "The label of the header - if provided this will override the default label generation."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:loadImmediately ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true this will execute the search immediately when the widget is created."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:noBorder ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the border around the form. This can be useful if the surrounding container (SplitPane) already has a border."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "The onSelect handler of the generated SearchResultsGrid."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:queryGraph ;
      spl:valueType owl:Ontology ;
      rdfs:comment "An optional graph that contains the schema (needed to determine whether an instance has a class that is the subclass of the resource type)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:restoreSearch ;
      spl:valueType search:Search ;
      rdfs:comment "Creates this search form from a given search:Search object that represents a previous state (\"saved search\"). The widgets themselves can query this value using the context variable \"swaRestoreSearch\"."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:rootType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "If the type is selectable, then use this as root class for the selection drop down."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:rowNumCookie ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional name for a cookie that shall be used to remember the chosen number of rows."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchButtonHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function to handle the Search button click event."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchResultsGeneratedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to fire after search results are generated for the results grid."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:showSearchResultsActions ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to also show a drop down menu with search results actions."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:sortByFirstKeyProperty ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Set to true to always sort by the first selected key property. This is usually used in conjunction with arg:suppressKeyPropertiesSelection=true to support cases in which the key properties are pre-selected."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressHeader ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress the header, e.g. to replace it with a custom header instead."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressKeyPropertiesSelection ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Set to true to hide the check boxes that allow the user to select the result columns. It will then only use the swa:keyProperties attached to the type without enabling the user to modify them."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:typeSelectable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, the form will have a drop down selection in the top where users can switch to a subclass of the resource type."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The subject type to display."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resultsId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of a div that shall contain the results grid when the user hits Search."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:setContext let:fid=\"{= IF(bound(?formId), ?formId, ui:uniqueId()) }\" let:lid=\"{= IF(bound(?formId), CONCAT(?formId, &quot;LID&quot;), ui:uniqueId()) }\" ui:varName=\"mode\" ui:varValue=\"search\">
    <ui:if ui:condition=\"{= (!bound(?suppressHeader)) || (!?suppressHeader) }\">
        <swa:FormHeader arg:label=\"{= COALESCE(?headerLabel, IF((bound(?typeSelectable) &amp;&amp; ?typeSelectable), &quot;Search&quot;, CONCAT(&quot;Search &quot;, ui:label(?resourceType)))) }\"/>
    </ui:if>
    <ui:if ui:condition=\"{= ?typeSelectable }\">
        <ui:loadable ui:loadId=\"{= ?fid }TypeSwitch\">
            <swa:SearchFormTypeSwitch arg:loadId=\"{= ?lid }\" arg:resourceType=\"{= COALESCE(?rootType, ?resourceType) }\" arg:selectedType=\"{= IF(bound(?restoreSearch), spl:object(?restoreSearch, search:rootType), ?resourceType) }\"/>
        </ui:loadable>
    </ui:if>
    <ui:loadable class=\"ui-layout-content\" ui:cache=\"{= ?cache }\" ui:loadId=\"{= ?lid }\">
        <ui:setContext ui:varName=\"resourceType\" ui:varValue=\"{= ?resourceType }\">
            <ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= swa:createNewTabLink }\">
                <ui:setContext ui:varName=\"suppressRDFType\" ui:varValue=\"{= !?typeSelectable }\">
                    <ui:setContext ui:varName=\"swaRestoreSearch\" ui:varValue=\"{= ?restoreSearch }\">
                        <form autocomplete=\"off\" class=\"swa-form {= IF(((!bound(?noBorder)) || (?noBorder = false)), &quot; swa-form-border&quot;, &quot;&quot;) }\" id=\"{= ?fid }\" let:qg=\"{= IF(bound(?queryGraph), ?queryGraph, ui:currentQueryGraph()) }\">
                            <input name=\"type\" type=\"hidden\" value=\"&lt;{= ?resourceType }&gt;\"/>
                            <input name=\"_base\" type=\"hidden\" value=\"{= ui:encodeNode(?qg) }\"/>
                            <ui:if ui:condition=\"{= ?qg != ui:currentQueryGraph() }\">
                                <input name=\"schema\" type=\"hidden\" value=\"{= ui:encodeNode(ui:currentQueryGraph()) }\"/>
                            </ui:if>
                            <ui:if ui:condition=\"{= ?suppressKeyPropertiesSelection }\">
                                <swa:SearchFormKeyPropertiesHiddenFields arg:resourceType=\"{= ?resourceType }\"/>
                            </ui:if>
                            <ui:if ui:condition=\"{= ?sortByFirstKeyProperty }\">
                                <input name=\"_sortByFirstKeyProperty\" type=\"hidden\" value=\"true\"/>
                            </ui:if>
                            <ui:setContext ui:varName=\"suppressKeyPropertiesSelection\" ui:varValue=\"{= ?suppressKeyPropertiesSelection }\">
                                <div class=\"swa-form-body\">
                                    <swa:SearchFormFullTextSection arg:resourceType=\"{= ?resourceType }\"/>
                                    <ui:classView ui:class=\"{= swa:resourceType() }\" ui:matchIds=\"search,form\"/>
                                    <swa:SearchFormDirectInstancesSection arg:resourceType=\"{= ?resourceType }\"/>
                                </div>
                            </ui:setContext>
                        </form>
                    </ui:setContext>
                </ui:setContext>
            </ui:setContext>
        </ui:setContext>
    </ui:loadable>
    <div class=\"swa-form-footer\" let:handler=\"{= COALESCE(?searchButtonHandler, &quot;swa.loadSearchResultsGrid&quot;) }('{= ?fid }', '{= ?resultsId }', &quot;{= ui:escapeJSON(?onSelect) }&quot;, {= IF(bound(?rowNumCookie), CONCAT(&quot;\\&quot;&quot;, ?rowNumCookie, &quot;\\&quot;&quot;), &quot;null&quot;) }{= IF(bound(?searchResultsGeneratedEvent), CONCAT(&quot;, '&quot;, ?searchResultsGeneratedEvent, &quot;'&quot;), ?none) })\">
        <swa:Button arg:id=\"test-search-button\" arg:label=\"Search\" arg:onClick=\"{= ?handler }\"/>
        <swa:Space/>
        <swa:Button arg:label=\"Reset\" arg:onClick=\"swa.reloadSearchForm('{= ?lid }')\"/>
        <ui:if ui:condition=\"{= ?showSearchResultsActions }\">
            <swa:Space/>
            <swa:SearchResultsActionsButton arg:formId=\"{= ?fid }\" arg:toolTip=\"Run operation on results...\"/>
        </ui:if>
        <ui:if ui:condition=\"{= ?loadImmediately }\">
            <script>{= ?handler }</script>
        </ui:if>
        <ui:insertionPoint ui:pointId=\"footer\"/>
    </div>
    <swa:MultiResourceEditDialog arg:loadId=\"multiResourceEditDialog\"/>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment """A component displaying a search form that can be used to drive a result set grid.

This is left here for legacy reasons - any new application should use FormSearchGadget."""^^xsd:string ;
  rdfs:label "Search form"^^xsd:string ;
  rdfs:subClassOf swa:Form ;
.
swa:SearchFormDirectInstancesSection
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class being searched."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:if ui:condition=\"{= EXISTS {
    ?subClass rdfs:subClassOf ?resourceType .
} }\">
    <input name=\"directInstances\" style=\"width: 13px; height: 13px; padding: 0; margin:0; vertical-align: bottom; position: relative; top: -2px; *overflow: hidden\" type=\"checkbox\"/>
    <swa:Space/>
    <span class=\"swa-search-form-direct-instances-label\">Exclude subtypes of {= ui:label(?resourceType) }</span>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "A section showing up at the bottom of the search form, allowing users to activate direct instances only search. The section is empty if the class doesn't have any subclasses."^^xsd:string ;
  rdfs:label "Search form direct instances section"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormFooterPlugin
  rdf:type rdfs:Class ;
  rdfs:comment "A component that can appear in the lower right corner of a search form."^^xsd:string ;
  rdfs:label "Search form footer plugin"^^xsd:string ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:SearchFormFooterPlugins
  rdf:type swa:SearchFormFooterPlugin ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the search form."^^xsd:string ;
    ] ;
  rdfs:label "Search form footer plugins"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormFullTextSection
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:hideGlobalSearch ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only show the search for explicitly enumerated properties."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class being searched."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= swa:hasFullTextSearchProperty(?resourceType) }\">
        <div class=\"swa-objects-group\">
            <table class=\"swa-labeled-objects-table\">
                <tr class=\"swa-labeled-objects-tr\">
                    <td class=\"swa-labeled-objects-tabular-label\" style=\"text-align: left; width: 184px; padding: 0\">
                        <span class=\"swa-sub-title\">Search&nbsp;Text&nbsp;Properties</span>
                    </td>
                    <td let:id=\"{= ui:uniqueId() }\">
                        <input name=\"regex{= ?id }\" type=\"text\"/>
                        <input name=\"facet{= ?id }\" type=\"hidden\" value=\"union {= swa:fullTextSearchPropertiesConcat(?resourceType) }\"/>
                    </td>
                </tr>
            </table>
        </div>
    </ui:if>
    <ui:elseif ui:condition=\"{= (!bound(?hideGlobalSearch)) || (!?hideGlobalSearch) }\">
        <div class=\"swa-objects-group\">
            <table class=\"swa-labeled-objects-table\">
                <tr class=\"swa-labeled-objects-tr\">
                    <td class=\"swa-labeled-objects-tabular-label\" style=\"text-align: left; width: 184px; padding: 0\">
                        <span class=\"swa-sub-title\">Search&nbsp;any&nbsp;Text</span>
                    </td>
                    <td>
                        <input name=\"string\" type=\"text\" value=\"{= swa:restoreSearchString() }\"/>
                    </td>
                </tr>
            </table>
        </div>
    </ui:elseif>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Search form full text section"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormGadget
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:footerPlugin ;
      spl:valueType swa:SearchFormFooterPlugin ;
      rdfs:comment "An SWP element to appear in the lower right corner."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchButtonHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function to handle the click event for the Search button."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchResultsGeneratedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to fire after search results are generated for the results grid."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:typeSelectable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to allow users to switch to the search class using a drop down box."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to so that the form can be reloaded whenever the class changes."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:instanceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to fire if the user has clicked on an instance in the results grid."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class of instances being searched."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resultsId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the matching SearchResultsGridGadget."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:formId=\"{= IF(bound(?formId), ?formId, ui:uniqueId()) }\">
    <swa:WindowTitleSetter arg:title=\"Search {= ui:label(?resourceType) }\"/>
    <swa:SearchForm arg:formId=\"{= ?formId }\" arg:noBorder=\"{= true }\" arg:onSelect=\"{= swa:publishEvent(?instanceSelectedEvent, &quot;resource&quot;) }\" arg:resourceType=\"{= ?resourceType }\" arg:resultsId=\"{= ?resultsId }\" arg:searchButtonHandler=\"{= ?searchButtonHandler }\" arg:searchResultsGeneratedEvent=\"{= ?searchResultsGeneratedEvent }\" arg:showSearchResultsActions=\"{= true }\" arg:suppressHeader=\"{= true }\" arg:typeSelectable=\"{= ?typeSelectable }\">
        <ui:insert ui:into=\"footer\">
            <ui:if ui:condition=\"{= bound(?footerPlugin) }\">
                <swa:Space/>
                <swa:Space/>
                <div style=\"float: right\">
                    <ui:dynamicView arg:formId=\"{= ?formId }\" ui:class=\"{= ?footerPlugin }\"/>
                </div>
            </ui:if>
        </ui:insert>
    </swa:SearchForm>
    <ui:if ui:condition=\"{= bound(?parentUIElementId) }\">
        <swa:SubscribeArgument arg:argumentName=\"resourceType\" arg:event=\"{= ?classSelectedEvent }\" arg:uiElementId=\"{= ?parentUIElementId }\"/>
    </ui:if>
    <ui:else>
        <swa:SubscribeArgument arg:argumentName=\"resourceType\" arg:event=\"{= ?classSelectedEvent }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Deprecated (with TopBraid 4.3): Please migrate to swa:GridSearchResultsGadget and swa:FormSearchGadget."^^xsd:string ;
  rdfs:label "Search form gadget"^^xsd:string ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:SearchFormHiddenFields
  rdf:type ui:NodeClass ;
  ui:prototype """
<ui:group let:object=\"{= ui:contextValue(&quot;contextObject&quot;) }\" let:predicate=\"{= ui:contextValue(&quot;contextPredicate&quot;) }\" let:subject=\"{= ui:contextValue(&quot;contextSubject&quot;) }\">
    <ui:if ui:condition=\"{= bound(?predicate) }\">
        <ui:if ui:condition=\"{= bound(?subject) }\">
            <input name=\"facetContext\" type=\"hidden\" value=\"&lt;{= ?predicate }&gt;\"/>
            <input name=\"valueContext\" type=\"hidden\" value=\"&lt;{= ?subject }&gt;\"/>
        </ui:if>
        <ui:elseif ui:condition=\"{= bound(?object) }\">
            <input name=\"facetContext\" type=\"hidden\" value=\"-&lt;{= ?predicate }&gt;\"/>
            <input name=\"valueContext\" type=\"hidden\" value=\"&lt;{= ?object }&gt;\"/>
        </ui:elseif>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Inserts hidden field that instruct the search engine to use a context object or subject if the corresponding context variable have been bound."^^xsd:string ;
  rdfs:label "Search form hidden fields"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormKeyPropertiesHiddenFields
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to insert the key properties of."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:list=\"{= swa:getKeyProperties(?resourceType) }\">
    <ui:if ui:condition=\"{= bound(?list) }\">
        <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{#
                SELECT ?keyProperty
                WHERE {
                    GRAPH ui:graph {
                        ?list list:member ?keyProperty .
                    } .
                } }\">
            <input class=\"swaKeyPropertyHiddenField\" name=\"keyProperty{= ?index }\" type=\"hidden\" value=\"{= ui:encodeNode(?keyProperty) }\"/>
        </ui:forEach>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Search form key properties hidden fields"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchFormTypeSwitch
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:selectedType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The initially selected type."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The ui:loadId of the body of the form."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The root class for the search form."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:if ui:condition=\"{#
        ASK 
        WHERE {
            ?subClass rdfs:subClassOf ?resourceType .
        } }\">
    <table class=\"swa-labeled-objects-table swa-search-form-type-switch\">
        <tr class=\"swa-labeled-objects-tr\">
            <td class=\"swa-labeled-objects-label-td swa-labeled-objects-tabular-label\" style=\"padding-top: 2px\">
                <swa:PropertyLabel arg:label=\"Search for Type\"/>
            </td>
            <td class=\"swa-labeled-objects-icons-td\">
                <span class=\"swa-icon\"/>
            </td>
            <td class=\"swa-labeled-objects-body-td\" let:id=\"{= ?loadId }-typeSelect\">
                <select autocomplete=\"off\" id=\"{= ?id }\">
                    <ui:forEach ui:resultSet=\"{#
                            SELECT DISTINCT ?label ?class
                            WHERE {
                                ?class (rdfs:subClassOf)* ?resourceType .
                                BIND (ui:label(?class) AS ?label) .
                            }
                            ORDER BY (?label) }\">
                        <option selected=\"{= IF((COALESCE(?selectedType, ?resourceType) = ?class), &quot;selected&quot;, ?none) }\" value=\"{= ?class }\">{= ?label }</option>
                    </ui:forEach>
                </select>
                <script>$('#{= ?id }').change(function() {
						var newType = '&lt;' + $('#{= ?id }').val() + '&gt;';
						swa.load('{= ?loadId }', { resourceType: newType });
					});</script>
            </td>
        </tr>
    </table>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment "If the given resource type has at least one subclass, then this will display a drop down box where the user can select a class. This will reload the ui:loadable (form body) with the selected type. Future versions may also display a button that opens a tree dialog."^^xsd:string ;
  rdfs:label "Search form type switch"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SearchGadgets
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:classSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event that shall control which class is displayed as root class."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event that shall be posted when the search has been updated. This can be used to link this with a results gadget. The data payload of these events will is the URI of a session graph that holds the search:Search object to run - there can only be one such instance in that graph."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to search instances of."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Abstract base class of gadgets that can issue a search. Examples include search form or faceted search. Common to those is that users search over instances of a given class (which later becomes the search:rootType of the search:Search object). When the user executes a search, the search gadgets should publish a search event which any number of SearchResultsGadgets can subscribe to."^^xsd:string ;
  rdfs:label "Search gadgets"^^xsd:string ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:SearchMode
  rdf:type swa:Mode ;
  swa:formClass swa:SearchForm ;
  swa:formObjectPredicateSelectionTemplate swa:SuitableObjectPredicates ;
  swa:isSingleConstant "true"^^xsd:boolean ;
  swa:modeName "search"^^xsd:string ;
  swa:objectWidgetClass swa:ObjectFacet ;
  swa:objectWidgetMiddleColumnClass swa:SearchWidgetMiddleColumn ;
  swa:objectWidgetRowClass swa:ObjectFacetRow ;
  swa:subjectWidgetMiddleColumnClass swa:SubjectSearchWidgetMiddleColumn ;
  swa:subjectWidgetRowClass swa:SubjectFacetRow ;
  rdfs:comment "A mode in which forms are displaying search fields, e.g. a range slider for numeric values and a text field for regex string matching."^^xsd:string ;
  rdfs:label "Search mode"^^xsd:string ;
.
swa:SearchResultsAction
  rdf:type rdfs:Class ;
  rdfs:comment "Class for actions that can be performed on the results of a Search. The onSelect will be executed with the variable formId pointing to the search form. Look at the source code of the pre-defined example actions on how to proceed with the formId."^^xsd:string ;
  rdfs:label "Search results action"^^xsd:string ;
  rdfs:subClassOf swa:Action ;
.
swa:SearchResultsActions
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "group"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "actionName"^^xsd:string ;
          ]
          [
            sp:varName "actionLocalName"^^xsd:string ;
          ]
          [
            sp:varName "onSelect"^^xsd:string ;
          ]
          [
            sp:varName "enabled"^^xsd:string ;
          ]
          [
            sp:varName "group"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
          [
            sp:varName "iconClass"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object swa:SearchResultsAction ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "action"^^xsd:string ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "label"^^xsd:string ;
                    ] ;
                  sp:predicate rdfs:label ;
                  sp:subject [
                      sp:varName "action"^^xsd:string ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "condition"^^xsd:string ;
                    ] ;
                  sp:predicate arg:condition ;
                  sp:subject [
                      sp:varName "action"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type afn:localname ;
                      sp:arg1 [
                          sp:varName "action"^^xsd:string ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "actionLocalName"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type ui:encodeNode ;
                      sp:arg1 [
                          sp:varName "action"^^xsd:string ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "actionName"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spl:object ;
                      sp:arg1 [
                          sp:varName "action"^^xsd:string ;
                        ] ;
                      sp:arg2 arg:onSelect ;
                    ] ;
                  sp:variable [
                      sp:varName "onSelect"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spl:object ;
                      sp:arg1 [
                          sp:varName "action"^^xsd:string ;
                        ] ;
                      sp:arg2 arg:appName ;
                    ] ;
                  sp:variable [
                      sp:varName "actionAppName"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type sp:coalesce ;
                      sp:arg1 [
                          rdf:type spl:object ;
                          sp:arg1 [
                              sp:varName "action"^^xsd:string ;
                            ] ;
                          sp:arg2 arg:group ;
                        ] ;
                      sp:arg2 "" ;
                    ] ;
                  sp:variable [
                      sp:varName "group"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spl:object ;
                      sp:arg1 [
                          sp:varName "action"^^xsd:string ;
                        ] ;
                      sp:arg2 arg:iconClass ;
                    ] ;
                  sp:variable [
                      sp:varName "iconClass"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spin:eval ;
                      sp:arg1 [
                          sp:varName "condition"^^xsd:string ;
                        ] ;
                      sp:arg2 arg:appName ;
                      sp:arg3 [
                          sp:varName "appName"^^xsd:string ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "enabled"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:and ;
                      sp:arg1 [
                          rdf:type sp:bound ;
                          sp:arg1 [
                              sp:varName "enabled"^^xsd:string ;
                            ] ;
                        ] ;
                      sp:arg2 [
                          rdf:type sp:or ;
                          sp:arg1 [
                              rdf:type sp:not ;
                              sp:arg1 [
                                  rdf:type sp:bound ;
                                  sp:arg1 [
                                      sp:varName "actionAppName"^^xsd:string ;
                                    ] ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              rdf:type swa:hasAppName ;
                              sp:arg1 [
                                  sp:varName "appName"^^xsd:string ;
                                ] ;
                              sp:arg2 [
                                  sp:varName "actionAppName"^^xsd:string ;
                                ] ;
                            ] ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The current swaAppName, passed into the eval expression."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:label "Search results actions"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SearchResultsActionsButton
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional tool tip text to appear on the button."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the surrounding search form."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <button class=\"swa-button\" id=\"{= ?id }\" onclick=\"swa.openSearchResultsActionsMenu('{= ?id }', '{= ?formId }', '{= swa:appName() }')\" title=\"{= ?toolTip }\">
        <div class=\"ui-icon ui-icon-gear\"/>
    </button>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A Button displaying a popup menu when pressed, consisting of SearchResultsActions."^^xsd:string ;
  rdfs:label "Search results actions button"^^xsd:string ;
  rdfs:subClassOf swa:MenuElements ;
.
swa:SearchResultsActionsCallback
  rdf:type ui:JSONService ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:appName ;
      spl:valueType xsd:string ;
      rdfs:comment "The value of the swaAppName context variable as provided by the caller."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:call arg:appName=\"{= ?appName }\" ui:template=\"{= swa:SearchResultsActions }\">
    <swon:RSObjectArray arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:label "Search results actions callback"^^xsd:string ;
  rdfs:subClassOf swa:MenuElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:SearchResultsGadgets
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to list to when a search has been triggered. If left blank, then a default event name will be used consistently across all search views."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an event to publish when the user clicks on a result. The data payload of this event is the URI of the resource."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Base class of gadgets that can display the results of a Search. Search may be initiated by a search form or faceted search, and those gadget publish an event pointing to a session graph containing a single search:Search instance. This can be used in conjunction with the magic property search:result to perform the actual search. Subclasses of this may render the results in any way they like, and they should publish the event specified by arg:resourceSelectedEvent when someone clicks on a result."^^xsd:string ;
  rdfs:label "Search results gadgets"^^xsd:string ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:SearchResultsGrid
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "JavaScript code that shall be executed if the user selects a row in the grid. In this JavaScript code, the variable resource contains the URI of the selected resource."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:rowNumCookie ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a cookie that shall be used to remember the selected number of rows (10 by default)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchMemoryModel ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Whether to search the in-memory graph or search external data sources"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:sortByFirstKeyProperty ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Set to true to always sort by the first selected key property. This is usually used in conjunction with arg:suppressKeyPropertiesSelection=true to support cases in which the key properties are pre-selected."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:width ;
      spl:valueType xsd:integer ;
      rdfs:comment "An optional fixed width (in pixels, but without the 'px'). If unset, autowidth will be used."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:keyPropertiesList ;
      spl:valueType xsd:string ;
      rdfs:comment "A space-separated list of encoded key properties."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:params ;
      spl:valueType xsd:string ;
      rdfs:comment "A URL-encoded string of the parameters produced by a SearchForm."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of resources being edited."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:first=\"{= COALESCE(ui:param(&quot;_sortByFirstKeyProperty&quot;, xsd:boolean), ?sortByFirstKeyProperty, false) }\" let:pagerId=\"{= ui:uniqueId() }\" let:tableId=\"{= ui:uniqueId() }\">
    <table id=\"{= ?tableId }\"/>
    <div id=\"{= ?pagerId }\"/>
    <script>$(\"#{= ?tableId }\").jqGrid({url:swa.server+\"getSearchResults?{= ?params }\",<swon:Value arg:name=\"datatype\" arg:value=\"json\"/>,
colNames:[
<ui:if ui:condition=\"{= bound(?keyPropertiesList) }\">
            <ui:if ui:condition=\"{= !?first }\">'Resource'{= IF((STRLEN(?keyPropertiesList) &gt; 0), \",\", ?none) }</ui:if>
            <ui:forEach ui:resultSet=\"{#
                    SELECT ?colName ?inverse
                    WHERE {
                        ?keyPropertiesList swa:keyPropertiesFromList ( ?keyProperty ?inverse ) .
                        BIND (spif:titleCase(ui:label(?keyProperty)) AS ?colName) .
                    } }\" ui:separator=\",\">'{= IF(?inverse, \"[Inverse] \", ?none) }{= ?colName }'</ui:forEach>
        </ui:if>
        <ui:else>
		'Resource'
	</ui:else>],
colModel:[
<ui:if ui:condition=\"{= bound(?keyPropertiesList) }\">
            <ui:if ui:condition=\"{= !?first }\">{ name : 'label' }{= IF((STRLEN(?keyPropertiesList) &gt; 0), \",\", ?none) }</ui:if>
            <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{#
                    SELECT ?keyProperty
                    WHERE {
                        ?keyPropertiesList swa:keyPropertiesFromList ( ?keyProperty ?inverse ) .
                    } }\" ui:separator=\",\">{<swon:Value arg:name=\"name\" arg:value=\"{= afn:localname(?keyProperty) }_{= ?index }\"/>
	            		}
	    			</ui:forEach>
        </ui:if>
        <ui:else>{ name : 'label' }</ui:else>
],
<ui:if ui:condition=\"{= bound(?onSelect) }\">onSelectRow: function(resource) {
		{= ?onSelect }
	},</ui:if>
        <ui:if ui:condition=\"{= bound(?width) }\">width: {= ?width }</ui:if>
        <ui:else>autowidth: true</ui:else>,
height: <ui:if ui:condition=\"{= ui:gadgetContainer() }\">'71%'</ui:if>
        <ui:else>'auto'</ui:else>,
mtype: 'POST',
rowNum: <ui:if ui:condition=\"{= bound(?rowNumCookie) }\">swa.getCookie(\"{= ?rowNumCookie }\", 10)</ui:if>
        <ui:else>10</ui:else>,
rowList:[5,10,15,20,25],<ui:if ui:condition=\"{= bound(?rowNumCookie) }\">loadComplete: function() {
	var currentRowNum = $(\"#{= ?tableId }\").getGridParam('rowNum');
	$.cookie('{= ?rowNumCookie }', currentRowNum);
},</ui:if>pager: '#{= ?pagerId }',
sortorder: 'asc',
gridview: true,
postData: { smm:<ui:if ui:condition=\"{= bound(?searchMemoryModel) }\">{= ?searchMemoryModel }</ui:if>
        <ui:else>swa.searchMemoryModel</ui:else>},
onPaging: function(pgButton) { $(\"#{= ?tableId }\").setGridParam({postData:{smm: true}}); },
viewrecords: true
}).jqGrid('navGrid', '#{= ?pagerId }', { 
	add: false, 
	del: false, 
	edit: false, 
	search: false
});</script>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "Instances of this class are usually automatically created as a result of a user pressing the Search button on a SearchForm. The search button collects the parameters (form field values) and the grid allows users to browse through the matching resources based in a lazy loading manner. SWA users typically just instantiate a SearchForm and let it do the heavy lifting of passing the correct parameters around."^^xsd:string ;
  rdfs:label "Search results grid"^^xsd:string ;
  rdfs:subClassOf swa:GridElements ;
.
swa:SearchResultsGridGadget
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the grid - needed by the search form."^^xsd:string ;
    ] ;
  ui:prototype """
<div class=\"ui-layout-content\" id=\"{= ?id }\"/>
"""^^ui:Literal ;
  rdfs:comment "Deprecated (with TopBraid 4.3): Please migrate to swa:GridSearchResultsGadget and swa:FormSearchGadget."^^xsd:string ;
  rdfs:label "Search results grid gadget"^^xsd:string ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:SearchWidgetMiddleColumn
  rdf:type swa:ObjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\" let:restoreSearch=\"{= ui:contextValue(&quot;swaRestoreSearch&quot;) }\">
    <ui:group let:restoreKeyProperty=\"{= IF(bound(?restoreSearch), search:hasKeyProperty(?predicate, ?restoreSearch), swa:hasKeyProperty(swa:resourceType(), ?predicate)) }\">
        <input checked=\"{= IF(COALESCE(?restoreKeyProperty, swa:hasKeyProperty(swa:resourceType(), ?predicate)), &quot;checked&quot;, ?none) }\" class=\"swa-key-property-input\" style=\"{= IF(ui:contextValue(&quot;suppressKeyPropertiesSelection&quot;), &quot;display:none&quot;, ?none) }\" title=\"Include as search results column\" type=\"checkbox\" value=\"{= ui:encodeNode(?predicate) }\"/>
    </ui:group>
</td>
"""^^ui:Literal ;
  rdfs:comment "The middle column on search forms, containing the check box to include the property as a key property (column in the result set)."^^xsd:string ;
  rdfs:label "Search widget middle column"^^xsd:string ;
  rdfs:subClassOf swa:ObjectWidgetMiddleColumn ;
.
swa:SessionGraphDeleter
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:ownerId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the DOM element that defines the life cycle."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:sessionGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The session graph to delete."^^xsd:string ;
    ] ;
  ui:prototype """
<script>$(\"#{= ?ownerId }\").on(\"remove\", function () { swa.deleteSessionGraph('{= ?sessionGraph }'); });</script>
"""^^ui:Literal ;
  rdfs:comment "A script that can be tied to certain DOM elements so that a session graph is unregistered when the DOM element is destroyed. This is particularly useful if a dialog has created a session graph, and we don't want garbage to float around until the session ends."^^xsd:string ;
  rdfs:label "Session graph deleter"^^xsd:string ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:ShowSearchQueryAction
  rdf:type swa:SearchResultsAction ;
  arg:condition "true"^^xsd:boolean ;
  arg:onSelect "swa.showSearchQuery(formId)"^^xsd:string ;
  rdfs:label "Show SPARQL query..."^^xsd:string ;
.
swa:SortedInstances
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:orderBy (
          [
            sp:varName "label"^^xsd:string ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "instance"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "class"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "type"^^xsd:string ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "instance"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:label ;
                sp:arg1 [
                    sp:varName "instance"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to return the instances of."^^xsd:string ;
    ] ;
  rdfs:comment "Gets all instances of a given class and its subclasses, ordered by their label."^^xsd:string ;
  rdfs:label "Sorted instances"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SortedObjects
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            rdf:type ui:label ;
            sp:arg1 [
                sp:varName "object"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "object"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "subject"^^xsd:string ;
                  ] ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "object"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "subject"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the objects of."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the values of. "^^xsd:string ;
    ] ;
  rdfs:comment "Gets all objects of a given subject/predicate combination, ordering the objects by their ui:labels."^^xsd:string ;
  rdfs:label "Sorted objects"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SortedSubjects
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            rdf:type ui:label ;
            sp:arg1 [
                sp:varName "subject"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "subject"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "object"^^xsd:string ;
                  ] ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "object"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "subject"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:isIRI ;
                sp:arg1 [
                    sp:varName "subject"^^xsd:string ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object to get the values of. "^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the objects of."^^xsd:string ;
    ] ;
  rdfs:comment "Gets all subjects of a given predicate/object combination, ordered by ui:labels."^^xsd:string ;
  rdfs:label "Sorted subjects"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:Space
  rdf:type ui:NodeClass ;
  ui:prototype """
<ui:group>&nbsp;</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A non-breaking space - wrapped into a tag for readability and flexibillity."^^xsd:string ;
  rdfs:label "Space"^^xsd:string ;
  rdfs:subClassOf swa:LayoutElements ;
.
swa:SplitCommas
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value"^^xsd:string ;
          ]
        ) ;
      sp:where (
          (
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "string"^^xsd:string ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "?0"^^xsd:string ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "raw"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "string"^^xsd:string ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1"^^xsd:string ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            sp:object "," ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:trim ;
                sp:arg1 [
                    sp:varName "raw"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "value"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to process."^^xsd:string ;
    ] ;
  rdfs:comment "Turns a comma-separated string into a result set of individual tokens. This template can be used, among others, to fetch a specific item by index."^^xsd:string ;
  rdfs:label "Split commas"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:Subject
  rdf:type ui:NodeClass ;
  ui:prototype """
<swa:LabeledSubjects arg:single=\"{= true }\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "Inserts a widget for a single value of a given (inverse) predicate at the given object. This element should only be used if the property doesn't have a max cardinality of 1 anyway, to overload the default behavior."^^xsd:string ;
  rdfs:label "Subject"^^xsd:string ;
  rdfs:subClassOf swa:AbstractSubject ;
.
swa:SubjectEditWidgetMiddleColumn
  rdf:type swa:SubjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\">
    <div class=\"{= IF(?single, &quot;swa-display-none&quot;, &quot; swa-icon&quot;) } swa-add-button-div\" id=\"error-{= ?predicate }\">
        <a class=\"swa-add-row-button\" href=\"javascript:void(0)\" onclick=\"{= ui:functionCall(&quot;swa.addSubjectEditorRow&quot;, ui:currentQueryGraph(), CONCAT(?uid, &quot;-body&quot;), (?single = true), ?object, ?predicate, COALESCE(swa:appName(), &quot;&quot;), ?editWidget) }\"/>
    </div>
</td>
"""^^ui:Literal ;
  rdfs:label "Subject edit widget middle column"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidgetMiddleColumn ;
.
swa:SubjectEditor
  rdf:type swa:SubjectEditorClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:class=\"{= swa:bestSubjectEditorClass(?object, ?predicate, ?subject) }\">
    <ui:if ui:condition=\"{= bound(?class) }\">
        <ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?class }\"/>
    </ui:if>
    <ui:else>
        <b>ERROR: No SubjectEditor found for {= ui:label(?predicate) } at {= ui:label(swa:resourceType(?object)) }</b>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Subject editor"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidget ;
.
swa:SubjectEditorClass
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass of SubjectEditors."^^xsd:string ;
  rdfs:label "Subject editor class"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidgetClass ;
.
swa:SubjectEditorHiddenFields
  rdf:type swa:ObjectWidgetClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject node."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The unique id of this group."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <input class=\"swa-editor-hidden-field\" name=\"{= fn:concat(&quot;resource-&quot;^^xsd:string, ?uid) }\" type=\"hidden\" value=\"{= ui:encodeNode(COALESCE(?object, &lt;urn:x-app-edit:root&gt;)) }\"/>
    <input class=\"swa-editor-hidden-field\" name=\"{= fn:concat(&quot;path-&quot;^^xsd:string, ?uid) }\" type=\"hidden\" value=\"{= fn:concat(&quot;-&quot;^^xsd:string, ui:encodeNode(?predicate)) }\"/>
    <ui:if ui:condition=\"{= bound(?subject) }\">
        <input class=\"swa-editor-hidden-field\" name=\"{= fn:concat(&quot;old-&quot;^^xsd:string, ?uid) }\" type=\"hidden\" value=\"{= ui:encodeNode(?subject) }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Inserts the hidden fields needed to link the server with a widget. Note that the fields have a marker class swa.editorHiddenField that is used by delete row operations."^^xsd:string ;
  rdfs:label "Subject editor hidden fields"^^xsd:string ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:SubjectEditorRow
  rdf:type ui:SubjectWidgetRowClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <ui:if ui:condition=\"{= ((bound(?subject) &amp;&amp; bound(?object)) &amp;&amp; bound(?predicate)) &amp;&amp; swa:isReadOnlyTriple(?subject, ?predicate, ?object) }\">
        <swa:SubjectViewer ui:args=\"*\"/>
    </ui:if>
    <ui:else>
        <table class=\"swa-object-editor-row-table\" id=\"{= ?uid }\">
            <tr>
                <td class=\"swa-object-row-main-td\">
                    <swa:SubjectEditorHiddenFields ui:args=\"*\"/>
                    <swa:SubjectEditor ui:args=\"*\"/>
                </td>
                <td class=\"swa-object-row-button-td\">
                    <a class=\"swa-icon ui-icon ui-icon-closethick\" href=\"javascript:void(0)\" onclick=\"swa.deleteRow(&quot;{= ?uid }&quot;)\"/>
                </td>
            </tr>
        </table>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment "A row of a SubjectEditor."^^xsd:string ;
  rdfs:label "Subject editor row"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidgetRow ;
.
swa:SubjectElements
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object (usually the resource of the surrounding form)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract base class for elements that operate on subjects of a given predicate/object combination."^^xsd:string ;
  rdfs:label "Subject elements"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SubjectFacet
  rdf:type swa:SubjectFacetClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:class=\"{= swa:bestSubjectFacetClass(?predicate, ?subject) }\">
    <ui:if ui:condition=\"{= bound(?class) }\">
        <ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?class }\"/>
    </ui:if>
    <ui:else>
        <b>ERROR: No SubjectFacet found for {= ui:label(?predicate) } at {= ui:label(swa:resourceType(?object)) }</b>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:label "Subject facet"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidget ;
.
swa:SubjectFacetClass
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass of SubjectWidgets."^^xsd:string ;
  rdfs:label "Subject facet class"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidgetClass ;
.
swa:SubjectFacetRow
  rdf:type ui:SubjectWidgetRowClass ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <table>
        <tr>
            <td class=\"swa-widget-span\" id=\"{= ?uid }\" style=\"vertical-align: top\">
                <ui:loadable ui:loadId=\"{= ?uid }-loadable\">
                    <input name=\"facet{= ?uid }\" type=\"hidden\" value=\"-{= ui:encodeNode(?predicate) }\"/>
                    <ui:group let:subjectVarName=\"{= ui:contextValue(&quot;subjectVarName&quot;) }\">
                        <ui:if ui:condition=\"{= bound(?subjectVarName) }\">
                            <input name=\"subject{= ?uid }\" type=\"hidden\" value=\"{= ?subjectVarName }\"/>
                        </ui:if>
                    </ui:group>
                    <ui:if ui:condition=\"{= bound(?selectedWidget) }\">
                        <ui:dynamicView arg:predicate=\"{= ?predicate }\" arg:uid=\"{= ?uid }\" ui:class=\"{= ?selectedWidget }\"/>
                    </ui:if>
                    <ui:else>
                        <swa:SubjectFacet arg:predicate=\"{= ?predicate }\" arg:uid=\"{= ?uid }\"/>
                    </ui:else>
                </ui:loadable>
            </td>
            <td let:buttonId=\"{= ui:uniqueId() }\" style=\"vertical-align: top\">
                <div class=\"swa-facet-selector\" id=\"{= ?buttonId }\" onclick=\"{= ui:functionCall(&quot;swa.openFacetSelectionMenu&quot;, ?buttonId, ?uid, swa:resourceType(), ?predicate, true) }\" title=\"Alternative filters\"/>
            </td>
        </tr>
    </table>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A row of a SubjectFacet."^^xsd:string ;
  rdfs:label "Subject facet row"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidgetRow ;
.
swa:SubjectFacetWidgets
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "actionName"^^xsd:string ;
          ]
          [
            sp:varName "actionLocalName"^^xsd:string ;
          ]
          [
            sp:varName "onSelect"^^xsd:string ;
          ]
          [
            sp:varName "enabled"^^xsd:string ;
          ]
          [
            sp:varName "group"^^xsd:string ;
          ]
          [
            sp:varName "label"^^xsd:string ;
          ]
          [
            sp:varName "iconClass"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:SubQuery ;
                  sp:query [
                      rdf:type sp:Select ;
                      sp:orderBy (
                          [
                            rdf:type sp:Desc ;
                            sp:expression [
                                sp:varName "weight"^^xsd:string ;
                              ] ;
                          ]
                        ) ;
                      sp:where (
                          [
                            sp:object [
                                sp:varName "label"^^xsd:string ;
                              ] ;
                            sp:predicate swa:subjectFacetMenuName ;
                            sp:subject [
                                sp:varName "widgetClass"^^xsd:string ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "w"^^xsd:string ;
                              ] ;
                            sp:predicate swa:subjectWidgetWeight ;
                            sp:subject [
                                sp:varName "widgetClass"^^xsd:string ;
                              ] ;
                          ]
                          [
                            sp:object [
                                sp:varName "expression"^^xsd:string ;
                              ] ;
                            sp:predicate swa:expression ;
                            sp:subject [
                                sp:varName "w"^^xsd:string ;
                              ] ;
                          ]
                          [
                            rdf:type sp:Bind ;
                            sp:expression [
                                rdf:type sp:coalesce ;
                                sp:arg1 [
                                    rdf:type spl:object ;
                                    sp:arg1 [
                                        sp:varName "w"^^xsd:string ;
                                      ] ;
                                    sp:arg2 swa:weight ;
                                  ] ;
                                sp:arg2 0 ;
                              ] ;
                            sp:variable [
                                sp:varName "weight"^^xsd:string ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type spin:eval ;
                      sp:arg1 [
                          sp:varName "expression"^^xsd:string ;
                        ] ;
                      sp:arg2 arg:predicate ;
                      sp:arg3 [
                          sp:varName "predicate"^^xsd:string ;
                        ] ;
                      sp:arg4 arg:domain ;
                      sp:arg5 [
                          sp:varName "domain"^^xsd:string ;
                        ] ;
                      sp:arg6 arg:resourceType ;
                      sp:arg7 [
                          sp:varName "resourceType"^^xsd:string ;
                        ] ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      sp:varName "widgetClass"^^xsd:string ;
                    ] ;
                  sp:variable [
                      sp:varName "actionName"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type afn:localname ;
                      sp:arg1 [
                          sp:varName "widgetClass"^^xsd:string ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "actionLocalName"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression "true"^^xsd:boolean ;
                  sp:variable [
                      sp:varName "enabled"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type sp:concat ;
                      sp:arg1 "swa.replaceFacet('" ;
                      sp:arg2 [
                          sp:varName "elementId"^^xsd:string ;
                        ] ;
                      sp:arg3 "', '" ;
                      sp:arg4 [
                          rdf:type xsd:string ;
                          sp:arg1 [
                              sp:varName "widgetClass"^^xsd:string ;
                            ] ;
                        ] ;
                      sp:arg5 "', '" ;
                      sp:arg6 [
                          rdf:type xsd:string ;
                          sp:arg1 [
                              sp:varName "resourceType"^^xsd:string ;
                            ] ;
                        ] ;
                      sp:arg7 "', '" ;
                      sp:arg8 [
                          rdf:type xsd:string ;
                          sp:arg1 [
                              sp:varName "predicate"^^xsd:string ;
                            ] ;
                        ] ;
                      sp:arg9 "')" ;
                    ] ;
                  sp:variable [
                      sp:varName "onSelect"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:domain ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The domain of the property."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the surrounding element that shall have its content replaced."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the widget for."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The resource type on the form."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:comment "Gets the suitable facet widgets for a drop down menu."^^xsd:string ;
  rdfs:label "Subject facet widgets"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SubjectFacetWidgetsCallback
  rdf:type ui:JSONService ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:elementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the div holding the current widget."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the widget."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The class on the form."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:call arg:domain=\"{= swa:localDomain(?none, ?predicate) }\" arg:elementId=\"{= ?elementId }\" arg:predicate=\"{= ?predicate }\" arg:resourceType=\"{= ?resourceType }\" ui:args=\"template\" ui:template=\"{= swa:SubjectFacetWidgets }\">
    <swon:RSObjectArray arg:resultSet=\"{= ?rs }\"/>
</ui:call>
"""^^ui:Literal ;
  rdfs:label "Subject facet widgets callback"^^xsd:string ;
  rdfs:subClassOf swa:MenuElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:SubjectPredicateSelectionTemplates
  rdf:type spin:SelectTemplate ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object (the main resource on the form)."^^xsd:string ;
    ] ;
  rdfs:label "Subject predicate selection templates"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:SubjectSearchWidgetMiddleColumn
  rdf:type swa:SubjectWidgetMiddleColumnClass ;
  ui:prototype """
<td class=\"swa-labeled-objects-icons-td\" let:restoreSearch=\"{= ui:contextValue(&quot;swaRestoreSearch&quot;) }\">
    <ui:group let:restoreKeyProperty=\"{= IF(bound(?restoreSearch), search:hasInverseKeyProperty(?predicate, ?restoreSearch), false) }\">
        <input checked=\"{= IF(?restoreKeyProperty, &quot;checked&quot;, ?none) }\" class=\"swa-key-property-input\" style=\"{= IF(ui:contextValue(&quot;suppressKeyPropertiesSelection&quot;), &quot;display:none&quot;, ?none) }\" title=\"Include as search results column\" type=\"checkbox\" value=\"-{= ui:encodeNode(?predicate) }\"/>
    </ui:group>
</td>
"""^^ui:Literal ;
  rdfs:comment "The middle column on search forms, containing the check box to include the property as a key property (column in the result set)."^^xsd:string ;
  rdfs:label "Subject search widget middle column"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidgetMiddleColumn ;
.
swa:SubjectViewer
  rdf:type swa:SubjectViewerClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div class=\"swa-object-widget\" let:class=\"{= swa:bestSubjectViewerClass(?object, ?predicate, ?subject) }\">
    <ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" ui:class=\"{= ?class }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer of subjects. Will be substituted with the most suitable viewer class."^^xsd:string ;
  rdfs:label "Subject viewer"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidget ;
.
swa:SubjectViewerClass
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass of SubjectViewers."^^xsd:string ;
  rdfs:label "Subject viewer class"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidgetClass ;
.
swa:SubjectViewerRow
  rdf:type ui:SubjectWidgetRowClass ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:uid=\"{= ui:uniqueId() }\">
    <div about=\"{= IF(isIRI(?subject), ?subject, ?noBNodes) }\" class=\"swa-widget-row\" href=\"{= IF(isIRI(?object), ?object, ?no) }\" id=\"{= ?uid }\" rel=\"{= IF(isIRI(?object), ui:encodeNode(?predicate), ?no) }\" ui:addNamespace=\"{= ?predicate }\">
        <swa:SubjectViewer arg:uid=\"{= ?uid }\" ui:args=\"*\"/>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A row in a SubjectViewer."^^xsd:string ;
  rdfs:label "Subject viewer row"^^xsd:string ;
  rdfs:subClassOf swa:SubjectWidgetRow ;
.
swa:SubjectWidget
  rdf:type swa:SubjectWidgetClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject being displayed."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid used to identify the triple."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Superclass of widgets for a given subject."^^xsd:string ;
  rdfs:label "Subject widget"^^xsd:string ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:SubjectWidgetClass
  rdf:type rdfs:Class ;
  rdfs:comment "The metaclass of SubjectWidgets."^^xsd:string ;
  rdfs:label "Subject widget class"^^xsd:string ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:SubjectWidgetMiddleColumn
  rdf:type swa:SubjectWidgetMiddleColumnClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:editWidget ;
      spl:valueType swa:ObjectEditorClass ;
      rdfs:comment "The preferred widget if in edit mode."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:searchWidget ;
      spl:valueType swa:ObjectFacetClass ;
      rdfs:comment "The preferred facet widget."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True whether the surrounding widget has at most one value."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:viewWidget ;
      spl:valueType swa:ObjectViewerClass ;
      rdfs:comment "The preferred widget if in view mode."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:uid ;
      spl:valueType xsd:string ;
      rdfs:comment "The uid of the surrounding widget."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Base class of the elements that can show up as middle column between the label and the actual widgets on a form. The selection of the particular middle column element is made through the mode property swa:subjectWidgetMiddleColumnClass."^^xsd:string ;
  rdfs:label "Subject widget middle column"^^xsd:string ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:SubjectWidgetMiddleColumnClass
  rdf:type rdfs:Class ;
  rdfs:comment "Metaclass of the various subject widget middle column types."^^xsd:string ;
  rdfs:label "Subject widget middle column class"^^xsd:string ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:SubjectWidgetRow
  rdf:type ui:SubjectWidgetRowClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to display."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:dynamicView arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\" ui:class=\"{= swa:modeProperty(swa:subjectWidgetRowClass) }\"/>
"""^^ui:Literal ;
  rdfs:comment "A row of a SubjectWidget."^^xsd:string ;
  rdfs:label "Subject widget row"^^xsd:string ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:Subjects
  rdf:type ui:NodeClass ;
  ui:prototype """
<ui:group>
    <swa:LabeledSubjects arg:single=\"{= false }\" ui:args=\"*\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Inserts a widget for a given predicate/object combination, showing the subjects as values. This is typically known as \"Incoming References\"."^^xsd:string ;
  rdfs:label "Subjects"^^xsd:string ;
  rdfs:subClassOf swa:AbstractSubject ;
.
swa:SubjectsBody
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:single ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to allow at most one value."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= bound(?object) }\">
        <ui:call arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" let:limit=\"{= 50 }\" ui:template=\"{= swa:SortedSubjects }\">
            <ui:if ui:condition=\"{= spr:rowCount(?rs) = 0 }\">
                <div class=\"swa-object-row\">
                    <swa:SubjectWidgetRow arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\"/>
                </div>
            </ui:if>
            <ui:else>
                <ui:forEach ui:limit=\"{= ?limit }\" ui:resultSet=\"{= ?rs }\">
                    <div class=\"swa-object-row\">
                        <swa:SubjectWidgetRow arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:subject=\"{= ?subject }\"/>
                    </div>
                </ui:forEach>
                <ui:if ui:condition=\"{= spr:rowCount(?rs) &gt; ?limit }\">
                    <div class=\"swa-overflow\">({= spr:rowCount(?rs) - ?limit } more values not shown)</div>
                </ui:if>
            </ui:else>
        </ui:call>
    </ui:if>
    <ui:else>
        <div class=\"swa-object-row\">
            <swa:SubjectWidgetRow arg:predicate=\"{= ?predicate }\"/>
        </div>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "The body of a subjects widget."^^xsd:string ;
  rdfs:label "Subjects body"^^xsd:string ;
  rdfs:subClassOf swa:SubjectElements ;
.
swa:SubjectsGroup
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function that takes a predicate, subject and subjectType as arguments and returns true for all predicates that should be displayed."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:label ;
      spl:valueType xsd:string ;
      rdfs:comment "The title label."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicates ;
      spl:valueType sp:Select ;
      rdfs:comment "A result set (e.g., SPARQL SELECT query) that delivers the predicates in this group."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group letrs:rs=\"{#
        SELECT ?predicate
        WHERE {
            ( ?predicates 0 ) spr:colCells ?predicate .
            FILTER ((!bound(?filterFunction)) || spif:invoke(?filterFunction, ?predicate, ?subject)) .
            FILTER (!swa:isHiddenProperty(?predicate)) .
        } }\">
    <ui:if ui:condition=\"{= spr:rowCount(?rs) &gt; 0 }\">
        <div class=\"swa-objects-group\">
            <ui:if ui:condition=\"{= bound(?label) }\">
                <div class=\"swa-sub-title\">{= ?label }</div>
            </ui:if>
            <ui:forEach ui:resultSet=\"{= ?rs }\">
                <swa:Subjects arg:object=\"{= ?object }\" arg:predicate=\"{= ?predicate }\" arg:tabular=\"{= true }\"/>
            </ui:forEach>
        </div>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A group of subject widgets."^^xsd:string ;
  rdfs:label "Subjects group"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:Subscribe
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:uiElementId ;
      spl:valueType xsd:string ;
      rdfs:comment "HTML element ID for a containing element"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:code ;
      spl:valueType xsd:string ;
      rdfs:comment "The code to execute when the event fires. Values must be valid JavaScript snippets."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:if ui:condition=\"{= bound(?event) }\">
    <script>swa.registerSubscription(gadgets.Hub.subscribe('{= ?event }', function(event, data) { {= ?code } }), '{= COALESCE(swa:currentWindowId(), ?uiElementId) }', '{= ?ownerId }');</script>
</ui:if>
"""^^ui:Literal ;
  rdfs:comment """Subscribes a random JavaScript snippet to be executed whenever an event fires. Inside that JavaScript, the variable 'data' will point to the event payload.

This element should only be used inside of windows, and it will make sure that the events registrations are unsubscribed whenever the surrounding window gets reloaded or closed. In other scenarios, the ownerId should be provided, to make sure that the unregistering happens."""^^xsd:string ;
  rdfs:label "Subscribe"^^xsd:string ;
  rdfs:subClassOf swa:SubscribeElements ;
.
swa:SubscribeArgument
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:filter ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript expression that shall must evaluate to true to execute the argument change - returning false will bypass any change."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:uiElementId ;
      spl:valueType xsd:string ;
      rdfs:comment "HTML element ID for a containing element"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:argumentName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the argument to set."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:reload=\"swa.loadWithResource('{= COALESCE(swa:currentWindowId(), ?uiElementId) }', '{= ?argumentName }', data);\">
    <ui:if ui:condition=\"{= bound(?filter) }\">
        <swa:Subscribe arg:code=\"if({= ?filter }) { {= ?reload } }\" arg:event=\"{= ?event }\" arg:ownerId=\"{= ?ownerId }\" arg:uiElementId=\"{= ?uiElementId }\"/>
    </ui:if>
    <ui:else>
        <swa:Subscribe arg:code=\"{= ?reload }\" arg:event=\"{= ?event }\" arg:ownerId=\"{= ?ownerId }\" arg:uiElementId=\"{= ?uiElementId }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """Subscribes to an event so that a given argument updates whenever the event is triggered. The new value of the argument is derived from the payload data of the event. The surrounding gadget will be reloaded with the new argument.

Currently only works for resource-typed arguments, if the data object is a URI."""^^xsd:string ;
  rdfs:label "Subscribe argument"^^xsd:string ;
  rdfs:subClassOf swa:SubscribeElements ;
.
swa:SubscribeElements
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:ownerId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of an HTML DOM element that owns the life cycle of this event. If the owner element gets removed from the DOM tree, then the event will be unregistered too."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:event ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Abstract base class of control logic code that subscribes the surrounding swa:Gadget to an event on the SWA event hub."^^xsd:string ;
  rdfs:label "Subscribe elements"^^xsd:string ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:SuitableObjectPredicates
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:orderBy (
          [
            rdf:type ui:label ;
            sp:arg1 [
                sp:varName "predicate"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  (
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:bound ;
                          sp:arg1 [
                              sp:varName "subject"^^xsd:string ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "o"^^xsd:string ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate"^^xsd:string ;
                      ] ;
                    sp:subject [
                        sp:varName "subject"^^xsd:string ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type swa:resourceType ;
                        arg:resource [
                            sp:varName "subject"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "subjectType"^^xsd:string ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "subjectType"^^xsd:string ;
                      ] ;
                    sp:predicate spl:relevantPropertyAtClass ;
                    sp:subject [
                        sp:varName "predicate"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type swa:isNotHiddenProperty ;
                        arg:property [
                            sp:varName "predicate"^^xsd:string ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  rdfs:comment "Finds all \"suitable\" predicates for a given subject and/or subject type, looking at domains but also the existing values."^^xsd:string ;
  rdfs:label "Suitable object predicates for subject"^^xsd:string ;
  rdfs:subClassOf swa:ObjectPredicateSelectionTemplates ;
.
swa:SuitableSubjectPredicates
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:orderBy (
          [
            rdf:type ui:label ;
            sp:arg1 [
                sp:varName "predicate"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  (
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:bound ;
                          sp:arg1 [
                              sp:varName "object"^^xsd:string ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    sp:object [
                        sp:varName "object"^^xsd:string ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate"^^xsd:string ;
                      ] ;
                    sp:subject [
                        sp:varName "subject"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:isIRI ;
                        sp:arg1 [
                            sp:varName "subject"^^xsd:string ;
                          ] ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type swa:resourceType ;
                        arg:resource [
                            sp:varName "object"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "objectType"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "type"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "objectType"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:and ;
                        sp:arg1 [
                            rdf:type sp:ne ;
                            sp:arg1 [
                                sp:varName "type"^^xsd:string ;
                              ] ;
                            sp:arg2 owl:Thing ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:ne ;
                            sp:arg1 [
                                sp:varName "type"^^xsd:string ;
                              ] ;
                            sp:arg2 rdfs:Resource ;
                          ] ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "type"^^xsd:string ;
                      ] ;
                    sp:predicate rdfs:range ;
                    sp:subject [
                        sp:varName "predicate"^^xsd:string ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  rdfs:comment "Finds all \"suitable\" predicates for a given object type, looking at ranges."^^xsd:string ;
  rdfs:label "Suitable subject predicates"^^xsd:string ;
  rdfs:subClassOf swa:SubjectPredicateSelectionTemplates ;
.
swa:SwitchableForm
  rdf:type swa:FormClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:allowHistoryMode ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a \"Show history\" check box show up in view mode. This mode is currently only supported by the teamwork framework, not general SWA."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:allowLogMessage ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to also show a check box in edit mode, where the user can enter a commit message when pressing Save Changes"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:editable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to add an option to allow the user to switch the form to edit mode."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:editing ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to make the form editing by default."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:formId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the form if this is in edit mode."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:matchIds ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional list of matchIds that shall be tried first when selecting the actual view. This allows users to define multiple forms for the same class, while specific ViewForms can pick which one of them they would like to use. If specific, then there should not be any commas at the end, but are allowed between the values."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:showFooter ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, a footer will always show up, even if ?showResourceActions and ?editable are false."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:showResourceActions ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to also display a button to run ResourceActions."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:showURI ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to display the URI of the resource on the right hand side of the header. Even if left to false (default), the URI will be the tool tip text of the header."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:suppressHeader ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress any header."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:viewModeName ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional name of the mode that shall be activated if the form is in view mode. This can be used to replace the default view with a specialized mode, e.g. history mode in EVN."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:extraMatchIds=\"{= IF(bound(?matchIds), CONCAT(?matchIds, &quot;,&quot;), ?none) }\" let:fid=\"{= COALESCE(?formId, ui:uniqueId()) }\" let:headerLabelFunction=\"{= COALESCE(ui:contextValue(&quot;headerLabelFunction&quot;), swa:DefaultHeaderLabelFunction) }\">
    <ui:if ui:condition=\"{= (!bound(?suppressHeader)) || (!?suppressHeader) }\">
        <swa:FormHeader arg:label=\"{= spif:invoke(?headerLabelFunction, ?resource) }\" arg:toolTip=\"{= ?resource }\">
            <ui:if ui:condition=\"{= ?showURI }\">
                <span class=\"swa-form-header-uri\">{= ?resource }</span>
            </ui:if>
        </swa:FormHeader>
    </ui:if>
    <ui:loadable class=\"ui-layout-content\" ui:loadId=\"{= ?fid }-loadable\">
        <ui:if ui:condition=\"{= ?editing }\">
            <ui:setContext ui:varName=\"mode\" ui:varValue=\"edit\">
                <form autocomplete=\"off\" class=\"swa-form\" id=\"{= ?fid }\" resource=\"{= ?resource }\">
                    <ui:if ui:condition=\"{= ?editable }\">
                        <input name=\"_base\" type=\"hidden\" value=\"{= ui:encodeNode(ui:currentQueryGraph()) }\"/>
                    </ui:if>
                    <ui:if ui:condition=\"{= !bound(?resource) }\">
                        <input name=\"resourceType\" type=\"hidden\" value=\"{= swa:resourceType() }\"/>
                    </ui:if>
                    <div class=\"swa-form-body\">
                        <ui:if ui:condition=\"{= bound(?resource) }\">
                            <ui:resourceView ui:matchIds=\"{= ?extraMatchIds }edit,form\" ui:resource=\"{= ?resource }\"/>
                        </ui:if>
                        <ui:else>
                            <ui:classView ui:class=\"{= swa:resourceType() }\" ui:matchIds=\"{= ?extraMatchIds }edit,form\"/>
                        </ui:else>
                    </div>
                </form>
            </ui:setContext>
        </ui:if>
        <ui:else>
            <ui:setContext ui:varName=\"mode\" ui:varValue=\"{= COALESCE(?viewModeName, &quot;view&quot;) }\">
                <form class=\"swa-form\" id=\"{= ?fid }\" resource=\"{= ?resource }\">
                    <div class=\"swa-form-body\">
                        <ui:resourceView ui:matchIds=\"{= ?extraMatchIds }view,form\" ui:resource=\"{= ?resource }\"/>
                    </div>
                </form>
            </ui:setContext>
        </ui:else>
    </ui:loadable>
    <div>
        <ui:insertionPoint ui:pointId=\"extraFooter\"/>
    </div>
    <ui:if let:ei=\"{= COALESCE(?editing, false) }\" ui:condition=\"{= (?editable || ?showResourceActions) || ?showFooter }\">
        <div class=\"swa-form-footer\">
            <ui:if ui:condition=\"{= ?showResourceActions }\">
                <swa:ResourceActionsButton arg:id=\"{= ?fid }-actionsButton\" arg:resource=\"{= ?resource }\" arg:style=\"{= IF(?ei, &quot;visibility: hidden&quot;, ?none) }\" arg:toolTip=\"Actions for {= ui:label(?resource) }\"/>
                <swa:Space/>
            </ui:if>
            <swa:Button arg:disabled=\"{= !?editable }\" arg:iconClass=\"ui-icon ui-icon-wrench\" arg:id=\"{= ?fid }-editButton\" arg:label=\"Edit\" arg:onClick=\"swa.switchToEditForm('{= ?fid }')\" arg:style=\"{= IF(?ei, &quot;visibility: hidden&quot;, ?none) }\"/>
            <span id=\"{= ?fid }-editModeButtonBar\" style=\"{= IF(?ei, ?none, &quot;display: none&quot;) }\">
                <ui:if ui:condition=\"{= ?allowLogMessage }\">
                    <input id=\"logMessageBox\" onclick=\"swa.rememberLogMessageBoxStatus()\" style=\"width: 13px; height: 13px; padding: 0; margin:0; vertical-align: middle; position: relative; top: -1px; *overflow: hidden;\" type=\"checkbox\"/>
                    <script>swa.restoreLogMessageBoxStatus();</script>
                    <swa:Space/>
                    <span class=\"swa-base-font\">Enter log message</span>
                    <swa:Space/>
                    <swa:Space/>
                </ui:if>
                <swa:Button arg:class=\"test-save-button\" arg:iconClass=\"ui-icon ui-icon-check\" arg:id=\"{= ?fid }-saveButton\" arg:label=\"Save Changes\" arg:onClick=\"swa.submitForm('{= ?fid }')\"/>
                <swa:Space/>
                <swa:Button arg:iconClass=\"ui-icon ui-icon-cancel\" arg:id=\"{= ?fid }-cancelButton\" arg:label=\"Cancel\" arg:onClick=\"swa.switchToViewForm('{= ?fid }')\"/>
            </span>
            <div style=\"float: right\">
                <ui:insertionPoint ui:pointId=\"bottomBar\"/>
            </div>
            <ui:if ui:condition=\"{= ?allowHistoryMode }\">
                <div class=\"swa-history-checkbox\" id=\"{= ?fid }-historyModeBoxDiv\" style=\"{= IF(?ei, &quot;visibility: hidden&quot;, ?none) }\">
                    <input id=\"{= ?fid }-historyModeBox\" onclick=\"swa.switchToViewForm('{= ?fid }')\" style=\"width: 13px; height: 13px; padding: 0; margin:0; vertical-align: bottom; position: relative; top: -2px; *overflow: hidden;\" type=\"checkbox\"/>&nbsp;Show&nbsp;History</div>
            </ui:if>
        </div>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A form displaying details of a given resource. The form displays a header on top, with label and type of the resource. If arg:editable is set to true, the form will have a button at the bottom to switch it to edit mode."^^xsd:string ;
  rdfs:label "View form"^^xsd:string ;
  rdfs:subClassOf swa:Form ;
.
swa:SwitchableFormFooterPlugin
  rdf:type rdfs:Class ;
  rdfs:comment "A component that can appear in the lower right corner of a switchable form."^^xsd:string ;
  rdfs:label "Switchable form footer plugin"^^xsd:string ;
  rdfs:subClassOf ui:NodeClass ;
.
swa:SwitchableFormFooterPlugins
  rdf:type swa:SwitchableFormFooterPlugin ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource being displayed."^^xsd:string ;
    ] ;
  rdfs:label "Switchable form footer plugins"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:SwitchableFormGadget
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:allowHistoryMode ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have a \"Show history\" check box show up in view mode. This mode is currently only supported by the teamwork framework, not general SWA."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:allowLogMessage ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to provide an option to enter a log message when saving changes."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:editing ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to start in editing mode."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:footerPlugin ;
      spl:valueType swa:SwitchableFormFooterPlugin ;
      rdfs:comment "An optional component to show up in the lower right corner."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:readOnly ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to disallow switching to edit mode."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:showResourceActions ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to also display a button to run ResourceActions."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:showURI ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to include the URI of the resource in the header."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to so that the window can be reloaded if the resource changes. The event will also be re-published whenever the user follows a hyperlink on the form. The data payload of the event needs to be the URI of a resource."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= swa:createEventLink }\">
    <ui:setContext let:formId=\"{= ui:uniqueId() }\" ui:varName=\"createEventLinkEvent\" ui:varValue=\"{= ?resourceSelectedEvent }\">
        <ui:if ui:condition=\"{= bound(?resource) }\">
            <swa:WindowTitleSetter arg:title=\"{= ui:label(?resource) }{= IF(?showURI, CONCAT(&quot;&nbsp;&nbsp;(&quot;, xsd:string(?resource), &quot;)&quot;), ?none) }\"/>
            <swa:SwitchableForm arg:allowHistoryMode=\"{= ?allowHistoryMode }\" arg:allowLogMessage=\"{= ?allowLogMessage }\" arg:editable=\"{= (!bound(?readOnly)) || (!?readOnly) }\" arg:editing=\"{= ?editing }\" arg:formId=\"{= ?formId }\" arg:resource=\"{= ?resource }\" arg:showFooter=\"{= true }\" arg:showResourceActions=\"{= ?showResourceActions }\" arg:suppressHeader=\"{= true }\">
                <ui:insert ui:into=\"bottomBar\">
                    <ui:if ui:condition=\"{= bound(?footerPlugin) }\">
                        <swa:Space/>
                        <ui:dynamicView arg:resource=\"{= ?resource }\" ui:class=\"{= ?footerPlugin }\"/>
                    </ui:if>
                </ui:insert>
            </swa:SwitchableForm>
        </ui:if>
        <swa:Subscribe arg:code=\"swa.handleChangeForSwitchableFormGadget(data, '{= ?formId }', '{= swa:currentWindowId() }')\" arg:event=\"org.topbraid.swa.change\"/>
        <swa:SubscribeArgument arg:argumentName=\"resource\" arg:event=\"{= ?resourceSelectedEvent }\" arg:filter=\"swa.getFormResourceURI('{= ?formId }') != data\"/>
    </ui:setContext>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "A gadget consisting of a view form that can be switched to edit mode by the user."^^xsd:string ;
  rdfs:label "Switchable form gadget"^^xsd:string ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:TemplateCallDialog
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:callback ;
      spl:valueType xsd:string ;
      rdfs:comment "JavaScript code to execute when the user clicks on a search result. The JS variable resource will contain the URI of the selected resource."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:selectedResource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional pre-selected resource that will be attempted to be filled in as one of the arguments."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "The title of the dialog."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "A unique loadId string."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:templates ;
      spl:valueType spin:Template ;
      rdfs:comment "A SPIN template delivering all selectable templates with variables ?template and ?templateGraph."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:treeDataProvider ;
      spl:valueType swa:TreeDataProvider ;
      rdfs:comment "The TreeDataProvider used to select the available templates."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:oldQueryGraph=\"{= ui:currentQueryGraph() }\" let:resourceLabel=\"{= IF(bound(?selectedResource), ui:label(?selectedResource), ?none) }\" let:valueType=\"{= IF(bound(?selectedResource), spl:object(?selectedResource, rdf:type), ?none) }\">
    <div id=\"div-{= ?loadId }\" style=\"padding: 0\" title=\"{= COALESCE(?title, &quot;Execute Template Query&quot;) }\">
        <div class=\"swa-search-form-type-switch\" style=\"width: 596px\">
            <swa:LabeledElement arg:label=\"Template:\" let:selectId=\"{= ui:uniqueId() }\">
                <select id=\"{= ?selectId }\" onchange=\"sel=$(this).val();if(sel){swa.load('{= ?loadId }-form-loadable', {templateInfo: '&quot;' + sel + '&quot;'});}\" style=\"width:400px\">
                    <option/>
                    <ui:call ui:template=\"{= ?templates }\">
                        <ui:forEach ui:resultSet=\"{= ?rs }\">
                            <ui:setContext ui:queryGraph=\"{= ?templateGraph }\">
                                <option id=\"option-{= ?template }\" value=\"{= ?template } {= ?templateGraph }\">{= ui:label(?template) }</option>
                            </ui:setContext>
                        </ui:forEach>
                    </ui:call>
                </select>
                <swa:Space/>
                <button onclick=\"swa.openTemplateSelectionDialog('{= ?treeDataProvider }', '{= ?selectId }')\" title=\"Select Template Query...\" type=\"button\">...</button>
            </swa:LabeledElement>
        </div>
        <ui:loadable ui:loadId=\"{= ?loadId }-form-loadable\">
            <ui:if let:space=\"{= spif:indexOf(?templateInfo, &quot; &quot;) }\" ui:condition=\"{= bound(?templateInfo) }\">
                <ui:group let:template=\"{= IRI(SUBSTR(?templateInfo, 0, (?space + 1))) }\" let:templateGraph=\"{= IRI(SUBSTR(?templateInfo, (?space + 2))) }\">
                    <ui:setContext ui:queryGraph=\"{= ?templateGraph }\">
                        <ui:setContext ui:queryGraph=\"{= ui:graph }\" ui:varName=\"dataGraph\" ui:varValue=\"{= ?oldQueryGraph }\">
                            <swa:CreateForm arg:formId=\"{= ?loadId }-form\" arg:resourceType=\"{= ?template }\" arg:resourceURI=\"urn:x-swa:Dummy\"/>
                            <ui:if ui:condition=\"{= bound(?selectedResource) }\">
                                <ui:group let:predicate=\"{= swa:matchingArgumentPredicate(?template, ?valueType, ?oldQueryGraph) }\">
                                    <ui:if ui:condition=\"{= bound(?predicate) }\">
                                        <script>swa.selectResourceOnForm('{= ?loadId }-form', '{= ?predicate }', '{= ?selectedResource }', \"{= ui:escapeJSON(?resourceLabel) }\")</script>
                                    </ui:if>
                                </ui:group>
                            </ui:if>
                        </ui:setContext>
                        <div class=\"swa-dialog-button-bar\" style=\"padding: 0px 8px 8px;\">
                            <button onclick=\"swa.executeTemplateCall('{= ?loadId }', '{= ?templateGraph }')\">Execute</button>
                        </div>
                    </ui:setContext>
                </ui:group>
            </ui:if>
        </ui:loadable>
        <ui:loadable class=\"swa-form-body\" ui:loadId=\"{= ?loadId }-results\">
            <ui:if ui:condition=\"{= bound(?template) }\">
                <div class=\"swa-sub-title\">Search Results</div>
                <ui:setContext ui:queryGraph=\"{= ui:unionOfGraphs(?oldQueryGraph, ?templateGraph) }\">
                    <ui:call ui:args=\"template\" ui:template=\"{= ?template }\">
                        <swa:ResultSetGrid arg:hiddenColName=\"id\" arg:onSelect=\"var resource=data['id'];{= ?callback }\" arg:resultSet=\"{#
                                SELECT ?id ?result
                                WHERE {
                                    ?rs spr:rowIndices ?rowIndex .
                                    BIND (spr:cell(?rs, ?rowIndex, 0) AS ?result) .
                                    BIND (xsd:string(?result) AS ?id) .
                                } }\"/>
                    </ui:call>
                </ui:setContext>
            </ui:if>
        </ui:loadable>
    </div>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """A dialog consisting of three parts:
- a combo box to select the template on top
- a form to enter arguments for the selected template
- a result set grid at the bottom.
When the user click the execute button, the template will executed with those arguments, and the results displayed in the grid. This is a non-modal dialog and users can use it to navigate another application through a callback mechanism.

Optionally, the dialog's arguments can be pre-filled with a given value. For example an application such as EVN may have a currently selected resource. If the selected resource has the same type as one of the arguments, then the form will have that pre-selected."""^^xsd:string ;
  rdfs:label "Template call dialog"^^xsd:string ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:TemplateHomeGraph
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "graph"^^xsd:string ;
          ]
        ) ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "?0"^^xsd:string ;
                ] ;
              sp:predicate <http://www.topbraid.org/tops#files> ;
              sp:subject [
                  sp:varName "file"^^xsd:string ;
                ] ;
            ]
            [
              sp:object "/" ;
              sp:predicate rdf:first ;
              sp:subject [
                  sp:varName "?0"^^xsd:string ;
                ] ;
            ]
            [
              sp:object [
                  sp:varName "?1"^^xsd:string ;
                ] ;
              sp:predicate rdf:rest ;
              sp:subject [
                  sp:varName "?0"^^xsd:string ;
                ] ;
            ]
            [
              sp:object "true"^^xsd:boolean ;
              sp:predicate rdf:first ;
              sp:subject [
                  sp:varName "?1"^^xsd:string ;
                ] ;
            ]
            [
              sp:object () ;
              sp:predicate rdf:rest ;
              sp:subject [
                  sp:varName "?1"^^xsd:string ;
                ] ;
            ]
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:gt ;
                  sp:arg1 [
                      rdf:type spif:indexOf ;
                      sp:arg1 [
                          sp:varName "file"^^xsd:string ;
                        ] ;
                      sp:arg2 ".spin." ;
                    ] ;
                  sp:arg2 0 ;
                ] ;
            ]
            [
              rdf:type sp:Bind ;
              sp:expression [
                  rdf:type smf:baseURI ;
                  sp:arg1 [
                      sp:varName "file"^^xsd:string ;
                    ] ;
                ] ;
              sp:variable [
                  sp:varName "graph"^^xsd:string ;
                ] ;
            ]
          )
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:exists ;
                      sp:elements (
                          [
                            sp:object [
                                sp:varName "anyBody"^^xsd:string ;
                              ] ;
                            sp:predicate spin:body ;
                            sp:subject [
                                sp:varName "template"^^xsd:string ;
                              ] ;
                          ]
                        ) ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "graph"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:template ;
      spl:valueType spin:Template ;
      rdfs:comment "The template to get the graph of."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Given a globally registered SPIN template, this function finds the graph (.spin. file) that it has been declared in."^^xsd:string ;
  rdfs:label "Template home graph"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:TemplateSelectionDialog
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The load id of the dialog."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:selectId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the select element to update when OK is clicked."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:treeDataProvider ;
      spl:valueType swa:TreeDataProvider ;
    ] ;
  ui:prototype """
<div id=\"div-{= ?loadId }\" title=\"Select Template Query\">
    <script>var selectedTemplate = null;</script>
    <div style=\"border: 1px grey solid; width: 680px; height: 300px; overflow: auto\">
        <swa:Tree arg:dataProvider=\"{= ?treeDataProvider }\" arg:id=\"templateTree\" arg:onSelect=\"selectedTemplate=null;swa.loadWithResource('templateDetails', 'template', resource)\"/>
    </div>
    <ui:loadable style=\"padding-top: 8px; width: 680px; height: 100px; overflow: auto\" ui:loadId=\"templateDetails\">
        <ui:if ui:condition=\"{= bound(?template) }\">
            <ui:group let:graph=\"{= swa:TemplateHomeGraph(?template) }\">
                <ui:if ui:condition=\"{= bound(?graph) }\">
                    <ui:setContext ui:queryGraph=\"{= ?graph }\">
                        <div>{= spl:object(?template, rdfs:comment) }</div>
                    </ui:setContext>
                    <script>selectedTemplate='{= ?template }';</script>
                </ui:if>
            </ui:group>
        </ui:if>
    </ui:loadable>
    <div class=\"swa-dialog-button-bar\">
        <button onclick=\" swa.closeDialog('{= ?loadId }');if(selectedTemplate) { swa.updateSelectedTemplate(selectedTemplate, '{= ?selectId }') }\">OK</button>
        <swa:Space/>
        <button onclick=\"swa.closeDialog('{= ?loadId }')\">Cancel</button>
    </div>
</div>
"""^^ui:Literal ;
  rdfs:label "Template selection dialog"^^xsd:string ;
  rdfs:subClassOf swa:DialogElements ;
.
swa:TextAreaEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type sp:isLiteral ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type sp:gt ;
              sp:arg1 [
                  rdf:type spif:indexOf ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                  sp:arg2 """
""" ;
                ] ;
              sp:arg2 0 ;
            ] ;
        ] ;
      swa:weight 2 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <swa:ObjectEditorHiddenDatatypeField arg:datatype=\"{= xsd:string }\" arg:uid=\"{= ?uid }\"/>
    <textarea class=\"swa-text-area {= swa:testClass(?predicate) }\" name=\"new-{= ?uid }\" rows=\"4\">{= ?object }</textarea>
    <swa:LangSelector arg:initialValue=\"{= lang(?object) }\" arg:uid=\"{= ?uid }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A multi-line text area to enter string literals. This is the default editor for string literals that contain a line break."^^xsd:string ;
  rdfs:label "Text area editor"^^xsd:string ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:TextFieldEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:isLiteral ;
          sp:arg1 [
              sp:varName "object"^^xsd:string ;
            ] ;
        ] ;
      swa:weight 1 ;
    ] ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:or ;
          sp:arg1 [
              rdf:type sp:eq ;
              sp:arg1 [
                  sp:varName "range"^^xsd:string ;
                ] ;
              sp:arg2 rdfs:Literal ;
            ] ;
          sp:arg2 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type spl:instanceOf ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                  sp:arg2 rdfs:Datatype ;
                ] ;
            ] ;
        ] ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<swa:AbstractTextFieldEditor arg:inputType=\"text\" ui:args=\"*\"/>
"""^^ui:Literal ;
  rdfs:comment "A single-line text editor for literals. This is the default widget for all literals, with a weight of 0."^^xsd:string ;
  rdfs:label "Text field editor"^^xsd:string ;
  rdfs:subClassOf swa:AbstractTextFieldEditor ;
.
swa:TitledForm
  rdf:type ui:NodeClass ;
  ui:prototype """
<div class=\"swa-titled-form\">
    <div class=\"swa-title\">{= ui:label(?resource) }</div>
    <ui:resourceView ui:matchIds=\"form\" ui:resource=\"{= ?resource }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A wrapper that displays a title (the resource's name) and then the most suitable resource view with match id \"form\"."^^xsd:string ;
  rdfs:label "Titled form"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
  rdfs:subClassOf ui:ResourceViews ;
.
swa:Tree
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "false"^^xsd:boolean ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:draggable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true then the tree acts as drag source, i.e. users can drag resources from the tree to other elements that act as drag targets."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:defaultValue "tree"^^xsd:string ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the HTML element to generate for the tree."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:cache ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Set to true if the tree shall cache its requests. This should only be done for read-only static data."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function that is passed into the tree provider so that it can hide certain nodes (such as system classes) from the tree. The function must take a resource as its only argument and return true if the resource shall appear in the tree."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:onDoubleClick ;
      spl:valueType xsd:string ;
      rdfs:comment "A JS expression that shall be evaluated if the user has double-clicked on a tree node. The variable 'resource' will contain the URI of the resource that has been clicked on."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:onLoaded ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional JavaScript snippet that is to be executed after the tree has loaded its roots."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:onSelect ;
      spl:valueType xsd:string ;
      rdfs:comment "JavaScript code that shall be called if a node has been selected in the tree. In this code, the variable 'resource' points to the URI of the selected resource. The variable 'node' holds the selected low-level tree node."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "A root node that can overload the default root of the data provider. For example, swa:ClassTreeDataProvider starts at rdfs:Resource by default - set arg:root to owl:Thing to start there instead."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:dataProvider ;
      spl:valueType swa:TreeDataProvider ;
      rdfs:comment "The TreeDataProvider that is used in the callbacks to fetch the root and child nodes."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:createLink arg:filterFunction=\"{= ?filterFunction }\" arg:root=\"{= ?root }\" ui:cache=\"{= ?cache }\" ui:format=\"json\" ui:sendQueryGraph=\"{= true }\" ui:snippet=\"true\" ui:view=\"{= ?dataProvider }\">
    <div id=\"{= ?id }\" treedataprovider=\"{= ?dataProvider }\" treeroot=\"{= ?root }\"/>
    <script type=\"text/javascript\">function {= ?id }TreeInitHandler() {
		swa.initTree(\"{= ?id }\", \"{= ?link }\",<ui:if ui:condition=\"{= bound(?onLoaded) }\">\"{= ?onLoaded }\"</ui:if>
        <ui:else>false</ui:else>, <ui:if ui:condition=\"{= bound(?onSelect) }\">\"{= ?onSelect }\"</ui:if>
        <ui:else>false</ui:else>, <ui:if ui:condition=\"{= bound(?onDoubleClick) }\">\"{= ?onDoubleClick }\"</ui:if>
        <ui:else>false</ui:else>, {= COALESCE(?draggable, false) });
  };
  $().ready(function() {
{= ?id }TreeInitHandler();
	});</script>
</ui:createLink>
"""^^ui:Literal ;
  rdfs:comment "Inserts a jsTree component into the current page. The jsTree object will get the provided id."^^xsd:string ;
  rdfs:label "Tree"^^xsd:string ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeAutoCompletePanel
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:treeId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the tree (specified using arg:id in the associated swa:Tree)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class of nodes in the tree."^^xsd:string ;
    ] ;
  ui:prototype """
<div class=\"swa-form-footer\">
    <swa:AutoComplete arg:class=\"swa-tree-autocomplete\" arg:id=\"{= ui:uniqueId() }\" arg:onSelect=\"swa.selectTreeNode(&quot;{= ?treeId }&quot;, resource, &quot;{= ui:currentQueryGraph() }&quot;)\" arg:type=\"{= ?type }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A component that can be placed under an swa:Tree to provide an auto-complete field for the nodes in the tree."^^xsd:string ;
  rdfs:label "Tree auto complete panel"^^xsd:string ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeChildrenTemplates
  rdf:type spin:SelectTemplate ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:filterFunction ;
      spl:valueType spin:Function ;
      rdfs:comment "An optional filter function that returns true for those resources that shall be visible. The query should evaluate this function if it exists."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:parent ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The parent node to get the children of."^^xsd:string ;
    ] ;
  rdfs:comment "Superclass of SPIN templates used by the Tree component to get the children of a given parent resource. The body of the query needs to assume that ?parent is pre-bound to the parent resource. Should deliver the following variables: ?node (the child resource of ?parent), ?label (the display label of ?node), ?leaf (false if this node has children), ?icon (an optional icon CSS style), and ?movable (true if this node can be dragged under a different parent). Since the tree is being lazy-loaded the ?leaf attribute influences only whether an expansion (+) button will be displayed. Only when the user clicks on that expansion button, the next round of children will be loaded."^^xsd:string ;
  rdfs:label "Tree children templates"^^xsd:string ;
  rdfs:subClassOf swa:TreeTemplates ;
.
swa:TreeDataProvider
  rdf:type ui:JSONService ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:changeHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function that shall be executed if the tree is part of an editable application in which SWA change objects are passed around via the event hub. The function takes two parameters: the change data and the tree id. See swa:ClassTreeDataProvider for an example."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:treeRootsTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "A subclass of swa:TreeRootsTemplates that delivers the roots of the tree. Will be bypassed if the tree itself defined an arg:rootResource."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:treeChildrenTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "The subclass of swa:TreeChildrenTemplates that delivers the children of a given parent node."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:treePathTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "This SPIN template is called with the variable ?node pre-bound to a node in the tree and ?root possibly pointing to a root resource. The template must return a single result variable containing a path from a root to that node. See spif:shortestObjectsPath for a default implementation. The path must be a space-separated string concatenation of URIs."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:param(&quot;id&quot;) }\">
    <ui:if ui:condition=\"{= (?id = &quot;1&quot;) || (!bound(?id)) }\">
        <ui:call arg:root=\"{= ui:param(&quot;root&quot;, rdfs:Resource) }\" ui:template=\"{= ?treeRootsTemplate }\">
            <swa:TreeDataProviderHelper arg:parentId=\"{= ?id }\" ui:resultSet=\"{= ?rs }\"/>
        </ui:call>
    </ui:if>
    <ui:else>
        <ui:call arg:filterFunction=\"{= ui:param(&quot;filterFunction&quot;, rdfs:Resource) }\" arg:parent=\"{= ui:decodeNode(swa:removeUniqueId(?id)) }\" ui:template=\"{= ?treeChildrenTemplate }\">
            <swa:TreeDataProviderHelper arg:parentId=\"{= ?id }\" ui:resultSet=\"{= ?rs }\"/>
        </ui:call>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """Instances of this class are used as server callbacks to drive an swa:Tree.

A TreeDataProvider is backed by a couple of SELECT queries - one to get the roots, and one to get the children of a given node. Optionally, a root resource can be supplied to overload the default root(s).

Another operation that trees should support is finding an expansion path from a root to a given node - this is needed to support navigating to a tree node from auto-complete fields and similar components. To support this, each TreeDataProvider should point to a SPIN template that delivers a path. This typically uses the spif:shortestObjectsPath function.

If the content of the tree is editable, then the TreeDataProvider should implement a JavaScript function to react on SWA change objects. See the tree gadgets bundled with SWA for examples on how to do that."""^^xsd:string ;
  rdfs:label "Tree data provider"^^xsd:string ;
  rdfs:subClassOf swa:TreeElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:TreeDataProviderHelper
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:parentId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the parent node."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate ui:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The query to execute."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<swon:Array>
    <ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?resultSet }\">
        <ui:if ui:condition=\"{= ?index &lt; 500 }\">
            <ui:if ui:condition=\"{= ?index &gt; 0 }\">,</ui:if>
            <swon:Object>
                <swon:Value arg:name=\"data\">
                    <swon:Object>
                        <swon:Value arg:name=\"title\" arg:value=\"{= ui:escapeJSON(COALESCE(?label, ui:label(?label))) }\"/>
                        <ui:if ui:condition=\"{= bound(?icon) }\">
                            <swon:Value arg:name=\"icon\" arg:value=\"{= ?icon }\"/>
                        </ui:if>
                    </swon:Object>
                </swon:Value>
                <swon:Value arg:name=\"attr\">
                    <swon:Object>
                        <swon:Value arg:name=\"id\" arg:value=\"&lt;{= ?node }&gt;::{= ?parentId }\"/>
                        <swon:Value arg:name=\"resource\" arg:value=\"{= IRI(?node) }\"/>
                        <swon:Value arg:name=\"movable\" arg:value=\"{= COALESCE(?movable, true) }\"/>
                    </swon:Object>
                </swon:Value>
                <ui:if ui:condition=\"{= ?leaf }\">,\"children\":[]</ui:if>
                <ui:else>
                    <swon:Value arg:name=\"state\" arg:value=\"closed\"/>
                </ui:else>
            </swon:Object>
        </ui:if>
    </ui:forEach>
</swon:Array>
"""^^ui:Literal ;
  rdfs:comment "A helper element of TreeDataProvider. Produces JSON from a SELECT query."^^xsd:string ;
  rdfs:label "Tree data provider helper"^^xsd:string ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeDataProviderHelperWithCounts
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:parentId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the parent node."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate ui:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The query to execute."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
	[
<ui:forEach ui:indexVar=\"index\" ui:resultSet=\"{= ?resultSet }\">
        <ui:if ui:condition=\"{= ?index &lt; 500 }\">
            <ui:if ui:condition=\"{= ?index &gt; 0 }\">,</ui:if>{
			\"data\" : {<ui:if ui:condition=\"{= ?count &gt; 0 }\">\"title\" : \"{= ui:escapeJSON(COALESCE(?countLabel, ui:label(?countLabel))) }\"</ui:if>
            <ui:else>\"title\" : \"{= ui:escapeJSON(COALESCE(?label, ui:label(?label))) }\"</ui:else>
            <ui:if ui:condition=\"{= bound(?icon) }\">,
					\"icon\" : \"{= ?icon }\"</ui:if>},
			\"attr\" : {
				\"id\": \"&lt;{= ?node }&gt;::{= ?parentId }\",
				\"resource\" : \"{= IRI(?node) }\", 
				\"movable\" : {= COALESCE(?movable, \"true\") }
			},<ui:if ui:condition=\"{= ?leaf }\">
				\"children\" : []
			</ui:if>
            <ui:else>
				\"state\" : \"closed\"
			</ui:else>
		}</ui:if>
    </ui:forEach>
	]
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A helper element of TreeDataProvider. Produces JSON from a SELECT query."^^xsd:string ;
  rdfs:label "Tree data provider helper with counts"^^xsd:string ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeDataProviderWithCounts
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:changeHandler ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a JavaScript function that shall be executed if the tree is part of an editable application in which SWA change objects are passed around via the event hub. The function takes two parameters: the change data and the tree id. See swa:ClassTreeDataProvider for an example."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:treeRootsTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "A subclass of swa:TreeRootsTemplates that delivers the roots of the tree. Will be bypassed if the tree itself defined an arg:rootResource."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:treeChildrenTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "The subclass of swa:TreeChildrenTemplates that delivers the children of a given parent node."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:treePathTemplate ;
      spl:valueType spin:Template ;
      rdfs:comment "This SPIN template is called with the variable ?node pre-bound to a node in the tree and ?root possibly pointing to a root resource. The template must return a single result variable containing a path from a root to that node. See spif:shortestObjectsPath for a default implementation. The path must be a space-separated string concatenation of URIs."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:param(&quot;id&quot;) }\">
    <ui:if ui:condition=\"{= (?id = &quot;1&quot;) || (!bound(?id)) }\">
        <ui:call arg:root=\"{= ui:param(&quot;root&quot;, rdfs:Resource) }\" ui:template=\"{= ?treeRootsTemplate }\">
            <swa:TreeDataProviderHelperWithCounts arg:parentId=\"{= ?id }\" ui:resultSet=\"{= ?rs }\"/>
        </ui:call>
    </ui:if>
    <ui:else>
        <ui:call arg:filterFunction=\"{= ui:param(&quot;filterFunction&quot;, rdfs:Resource) }\" arg:parent=\"{= ui:decodeNode(swa:removeUniqueId(?id)) }\" ui:template=\"{= ?treeChildrenTemplate }\">
            <swa:TreeDataProviderHelperWithCounts arg:parentId=\"{= ?id }\" ui:resultSet=\"{= ?rs }\"/>
        </ui:call>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:JSON ;
  rdfs:comment """Instances of this class are used as server callbacks to drive an swa:Tree.

A TreeDataProvider is backed by two SELECT queries - one to get the roots, and one to get the children of a given node. Optionally, a root resource can be supplied to overload the default root(s).

Another operation that trees must should is finding an expansion path from a root to a given node - this is needed to support navigating to a tree node from auto-complete fields and similar components. To support this, each TreeDataProvider should point to a SPIN template that delivers a path. This typically uses the spif:shortestObjectsPath function.

If the content of the tree is editable, then the TreeDataProvider should implement a JavaScript function to react on SWA change objects."""^^xsd:string ;
  rdfs:label "Tree data provider with counts"^^xsd:string ;
  rdfs:subClassOf swa:TreeElements ;
.
swa:TreeElements
  rdf:type ui:NodeClass ;
  ui:abstract "true"^^xsd:boolean ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Abstract superclass grouping together the tree-related SWA elements."^^xsd:string ;
  rdfs:label "Tree elements"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:TreeGadgets
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:treeId ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) id of the tree, in case someone needs to access it programmatically."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to fire if the selected class has changed, but for gadgets that display instances."^^xsd:string ;
    ] ;
  ui:abstract "true"^^xsd:boolean ;
  rdfs:comment "Abstract base class of Gadgets displaying a Tree."^^xsd:string ;
  rdfs:label "Tree gadgets"^^xsd:string ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:TreePathTemplates
  rdf:type spin:SelectTemplate ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional root resource to stop traversal at."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to start traversal at."^^xsd:string ;
    ] ;
  rdfs:comment "An abstract superclass for SPIN templates used by TreeDataProviders to find a path from a node to a root."^^xsd:string ;
  rdfs:label "Tree path templates"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:TreeRootsTemplates
  rdf:type spin:SelectTemplate ;
  spin:abstract "true"^^xsd:boolean ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to return as single root - this is bound by the tree if the tree has a dedicated arg:root. Otherwise the node is created by the WHERE clause."^^xsd:string ;
    ] ;
  rdfs:comment "Abstract superclass for queries that can deliver the roots of a tree. See TreeChildrenTemplates for a description of result variables, and ClassTreeRoots for an example implementation."^^xsd:string ;
  rdfs:label "Tree roots templates"^^xsd:string ;
  rdfs:subClassOf swa:TreeTemplates ;
.
swa:TreeShortestPathCallback
  rdf:type ui:JSONService ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The root resource to stop at."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:dataProvider ;
      spl:valueType swa:TreeDataProvider ;
      rdfs:comment "The TreeDataProvider that contains the pathExpression needed to walk to the root."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node resource to start traversal at."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:template=\"{#
        SELECT ?template
        WHERE {
            GRAPH ui:graph {
                ?dataProvider arg:treePathTemplate ?template .
            } .
        } }\">
    <ui:call arg:node=\"{= ?node }\" arg:root=\"{= ?root }\" ui:template=\"{= ?template }\">
        <ui:if ui:condition=\"{= spr:rowCount(?rs) &gt; 0 }\">
            <ui:group let:path=\"{= spr:cell(?rs, 0, 0) }\">
                <ui:if ui:condition=\"{= isLiteral(?path) }\">
                    <swon:RSArray arg:resultSet='{#
                            SELECT ?value
                            WHERE {
                                ?value spif:split ( ?path \" \" ) .
                            } }'/>
                </ui:if>
            </ui:group>
        </ui:if>
    </ui:call>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "An element building a JSON array with URIs based on spif:shortestObjectsPath. Called using swp?_viewClass=swa:TreeShortestPathCallback&_format=json&subject=...&dataProvider=..."^^xsd:string ;
  rdfs:label "Tree shortest path callback"^^xsd:string ;
  rdfs:subClassOf swa:TreeElements ;
  rdfs:subClassOf ui:JSONServices ;
.
swa:TreeTemplates
  rdf:type spin:SelectTemplate ;
  spin:abstract "true"^^xsd:boolean ;
  rdfs:comment """Base class for SELECT templates that are used to populate trees. There are two kinds of queries:
a) to find all root nodes
b) to find the children of a given parent node.

All SELECT queries in subclass of this must return the following result variables:
SELECT ?node ?label ?leaf ?icon
- ?node: the resource behind the node, e.g. an owl:Class or skos:Concept
- ?label (optional): the label for the resource - if not used, the system will call ui:label(?node)
- ?leaf: true means no children, i.e. the node cannot be expanded
- ?icon (optional): CSS class for the icon"""^^xsd:string ;
  rdfs:label "Tree templates"^^xsd:string ;
  rdfs:subClassOf spin:SelectTemplates ;
.
swa:URIField
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the (new) resource. This is only used if resourceURI is blank, to generate a suitable URI."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:resourceURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI of the resource, as initial value for the input field. Can be left blank in which case the value will be derived from the resourceType."^^xsd:string ;
    ] ;
  ui:prototype """
<swa:LabeledElement arg:label=\"Identifier:\">
    <input class=\"swa-uri-field\" id=\"uri-input\" style=\"width: 440px\" type=\"text\" value=\"{= COALESCE(?resourceURI, swa:newResource(?resourceType)) }\"/>
</swa:LabeledElement>
"""^^ui:Literal ;
  rdfs:comment "An input field used on CreateForms to enter the URI of the new resource."^^xsd:string ;
  rdfs:label "URI field"^^xsd:string ;
  rdfs:subClassOf swa:FormElements ;
.
swa:URIResourceEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:and ;
                  sp:arg1 [
                      rdf:type sp:bound ;
                      sp:arg1 [
                          sp:varName "range"^^xsd:string ;
                        ] ;
                    ] ;
                  sp:arg2 [
                      rdf:type sp:not ;
                      sp:arg1 [
                          rdf:type spl:instanceOf ;
                          sp:arg1 [
                              sp:varName "range"^^xsd:string ;
                            ] ;
                          sp:arg2 rdfs:Datatype ;
                        ] ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type sp:ne ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                  sp:arg2 rdfs:Literal ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type sp:or ;
              sp:arg1 [
                  rdf:type sp:not ;
                  sp:arg1 [
                      rdf:type sp:bound ;
                      sp:arg1 [
                          sp:varName "object"^^xsd:string ;
                        ] ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type sp:isIRI ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                ] ;
            ] ;
        ] ;
    ] ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:isIRI ;
          sp:arg1 [
              sp:varName "object"^^xsd:string ;
            ] ;
        ] ;
      swa:weight 2 ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:setContext let:range=\"{= swa:localRange(?predicate, ?subject) }\" ui:queryGraph=\"{= swa:dataGraph() }\">
    <swa:AutoComplete arg:allowURIs=\"{= true }\" arg:class=\"swa-text-field {= swa:testClass(?predicate) }\" arg:id=\"new-{= ?uid }\" arg:initialValue=\"{= ?object }\" arg:type=\"{= ?range }\" arg:withSelectMenu=\"{= true }\"/>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "The default Editor for resources, consisting of a combo-box with auto-complete."^^xsd:string ;
  rdfs:label "Resource editor"^^xsd:string ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:URIResourceFacet
  rdf:type swa:ObjectFacetClass ;
  swa:facetSearchType search:ObjectFacetValue ;
  swa:objectFacetMenuName "equals"^^xsd:string ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "range"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type sp:not ;
                  sp:arg1 [
                      rdf:type swa:isDatatypeRange ;
                      arg:range [
                          sp:varName "range"^^xsd:string ;
                        ] ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type swa:hasMatchingRestoreFacetValue ;
              arg:facetClass swa:URIResourceFacet ;
              arg:property [
                  sp:varName "predicate"^^xsd:string ;
                ] ;
            ] ;
        ] ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group let:restore=\"{= swa:restoreFacetValue(?predicate) }\" let:type=\"{= swa:localRangeAtClass(swa:resourceType(), ?predicate) }\">
    <swa:AutoComplete arg:class=\"{= swa:testClass(?predicate) }\" arg:id=\"value{= ?uid }\" arg:initialValue=\"{= IF(bound(?restore), spl:object(?restore, search:object), ?none) }\" arg:type=\"{= IF((bound(?type) &amp;&amp; isBlank(?type)), rdfs:Resource, ?type) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "A facet for URI resources, displaying an AutoComplete."^^xsd:string ;
  rdfs:label "URI resource facet"^^xsd:string ;
  rdfs:subClassOf swa:ObjectFacet ;
.
swa:URIResourceSubjectViewer
  rdf:type swa:SubjectViewerClass ;
  swa:subjectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:isIRI ;
          sp:arg1 [
              sp:varName "subject"^^xsd:string ;
            ] ;
        ] ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div class=\"swa-shifted-label\">
    <swa:Link arg:resource=\"{= ?subject }\"/>
</div>
"""^^ui:Literal ;
  rdfs:comment "A viewer for URI resources, displaying a hyperlink to that resource."^^xsd:string ;
  rdfs:label "URI resource subject viewer"^^xsd:string ;
  rdfs:subClassOf swa:SubjectViewer ;
.
swa:URIResourceTextFieldEditor
  rdf:type swa:ObjectEditorClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:and ;
          sp:arg1 [
              rdf:type sp:and ;
              sp:arg1 [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                ] ;
              sp:arg2 [
                  rdf:type sp:isIRI ;
                  sp:arg1 [
                      sp:varName "object"^^xsd:string ;
                    ] ;
                ] ;
            ] ;
          sp:arg2 [
              rdf:type sp:notExists ;
              sp:elements (
                  [
                    sp:object [
                        sp:varName "o"^^xsd:string ;
                      ] ;
                    sp:predicate [
                        sp:varName "p"^^xsd:string ;
                      ] ;
                    sp:subject [
                        sp:varName "object"^^xsd:string ;
                      ] ;
                  ]
                ) ;
            ] ;
        ] ;
      swa:weight 3 ;
    ] ;
  ui:prototype """
<ui:group let:id=\"{= ui:uniqueId() }\">
    <input class=\"swa-text-field {= swa:testClass(?predicate) }\" id=\"{= ?id }\" onkeyup=\"$('#new-{= ?uid }').val('&lt;' + $('#{= ?id }').val() + '&gt;')\" type=\"text\" value=\"{= ?object }\"/>
    <input id=\"new-{= ?uid }\" name=\"new-{= ?uid }\" type=\"hidden\" value=\"{= ui:encodeNode(?object) }\"/>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment """A text field for entering arbitrary URIs, with the result being a <...> encoded resource, not a literal.

This is the default editor for URI resources that have no other object triple, i.e. untyped resources such as links to dbpedia.

You may want to add other weight expressions to activate this widget for selected predicates."""^^xsd:string ;
  rdfs:label "URI resource text field editor"^^xsd:string ;
  rdfs:subClassOf swa:ObjectEditor ;
.
swa:URIResourceViewer
  rdf:type swa:ObjectViewerClass ;
  swa:objectWidgetWeight [
      rdf:type swa:WeightedExpression ;
      swa:expression [
          rdf:type sp:isIRI ;
          sp:arg1 [
              sp:varName "object"^^xsd:string ;
            ] ;
        ] ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div class=\"swa-shifted-label\" title=\"{= ?object }\">
    <swa:Link arg:resource=\"{= ?object }\"/>
</div>
"""^^ui:Literal ;
  rdfs:label "URI resource viewer"^^xsd:string ;
  rdfs:subClassOf swa:ObjectViewer ;
.
swa:UsedObjectPredicates
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:orderBy (
          [
            rdf:type ui:label ;
            sp:arg1 [
                sp:varName "predicate"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "o"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "subject"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Gets all predicates where the given subject actually has at least one value for."^^xsd:string ;
  rdfs:label "Used object predicates"^^xsd:string ;
  rdfs:subClassOf swa:ObjectPredicateSelectionTemplates ;
.
swa:UsedSubjectPredicates
  rdf:type spin:SelectTemplate ;
  spin:body [
      rdf:type sp:Select ;
      sp:distinct "true"^^xsd:boolean ;
      sp:orderBy (
          [
            rdf:type ui:label ;
            sp:arg1 [
                sp:varName "predicate"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:varName "predicate"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "subject"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:isIRI ;
                sp:arg1 [
                    sp:varName "subject"^^xsd:string ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Gets all predicates where the given object has at least one value."^^xsd:string ;
  rdfs:label "Used subject predicates"^^xsd:string ;
  rdfs:subClassOf swa:SubjectPredicateSelectionTemplates ;
.
swa:ViewForm
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:setContext ui:varName=\"mode\" ui:varValue=\"view\">
    <form class=\"swa-form ui-layout-content\">
        <div class=\"swa-form-body\">
            <ui:resourceView ui:matchIds=\"view,form\" ui:resource=\"{= ?resource }\"/>
        </div>
    </form>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "A read-only form that can be inserted into an swa:Window to display the details of a given resource."^^xsd:string ;
  rdfs:label "View form"^^xsd:string ;
  rdfs:subClassOf swa:Form ;
.
swa:ViewFormGadget
  rdf:type swa:Gadget ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceSelectedEvent ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event to subscribe to so that the window can be reloaded if the resource changes. The event will also be re-published whenever the user follows a hyperlink on the form. The data payload of the event needs to be the URI of a resource."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:setContext ui:varName=\"createLinkFunction\" ui:varValue=\"{= swa:createEventOrNewTabLink }\">
    <ui:setContext ui:varName=\"createEventLinkEvent\" ui:varValue=\"{= ?resourceSelectedEvent }\">
        <ui:if ui:condition=\"{= bound(?resource) }\">
            <swa:WindowTitleSetter arg:title=\"{= ui:label(?resource) }\"/>
            <swa:ViewForm arg:resource=\"{= ?resource }\"/>
        </ui:if>
        <ui:if ui:condition=\"{= bound(?parentUIElementId) }\">
            <swa:SubscribeArgument arg:argumentName=\"resource\" arg:event=\"{= ?resourceSelectedEvent }\" arg:uiElementId=\"{= ?parentUIElementId }\"/>
        </ui:if>
        <ui:else>
            <swa:SubscribeArgument arg:argumentName=\"resource\" arg:event=\"{= ?resourceSelectedEvent }\"/>
        </ui:else>
    </ui:setContext>
</ui:setContext>
"""^^ui:Literal ;
  rdfs:comment "A gadget consisting of a viewable form for a given resource. The resource can either be specified statically, or by subscribing to an event."^^xsd:string ;
  rdfs:label "View form gadget"^^xsd:string ;
  rdfs:subClassOf swa:Gadgets ;
.
swa:ViewMode
  rdf:type swa:Mode ;
  swa:formClass swa:SwitchableForm ;
  swa:formObjectPredicateSelectionTemplate swa:UsedObjectPredicates ;
  swa:formSubjectPredicateSelectionTemplate swa:UsedSubjectPredicates ;
  swa:isSingleConstant "false"^^xsd:boolean ;
  swa:modeName "view"^^xsd:string ;
  swa:objectWidgetClass swa:ObjectViewer ;
  swa:objectWidgetRowClass swa:ObjectViewerRow ;
  swa:subjectWidgetRowClass swa:SubjectViewerRow ;
  rdfs:label "View mode"^^xsd:string ;
.
swa:WeightedExpression
  rdf:type spin:Template ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate swa:weight ;
      spl:valueType xsd:integer ;
      rdfs:comment "The weight of the widget if the expression is true."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate swa:expression ;
      spl:valueType xsd:boolean ;
      rdfs:comment "A boolean expression that delivers true to accept the associated widget type for the given input variables."^^xsd:string ;
    ] ;
  spin:labelTemplate "Select {?expression} with weight {?weight}"^^xsd:string ;
  rdfs:comment "Class of objects that are used by the SWA engine to select the most suitable widget for a given context. A weighted expression has a weight that is used to discriminate between multiple matching alternatives - the widget with the highest weight will be picked. The expression is evaluated with certain variables pre-bound, depending on the type of witget that is used."^^xsd:string ;
  rdfs:label "Weighted expression"^^xsd:string ;
.
swa:WidgetInitializer
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:script ;
      spl:valueType xsd:string ;
      rdfs:comment "The script that initializes this widget."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= ui:contextValue(&quot;widgetPrototype&quot;) }\">
        <span class=\"swa-widget-initializer\" content=\"{= ?script }\"/>
    </ui:if>
    <ui:else>
        <script>{= ?script }</script>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Used by EditWidgets to encapsulate initialization code - JavaScript snippets that need to be executed if a new instance (new row) of this type is created."^^xsd:string ;
  rdfs:label "Widget initializer"^^xsd:string ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:WidgetLabel
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to display"^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<swa:Label arg:node=\"{= ui:label(?predicate) }: \"/>
"""^^ui:Literal ;
  rdfs:label "Widget label"^^xsd:string ;
  rdfs:subClassOf swa:Elements ;
.
swa:Window
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:closable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to include a close button into the header. NOT IMPLEMENTED YET."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:maximizable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to include a maximize button into the header. NOT IMPLEMENTED YET."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:minimizable ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to include a minimize button into the header. NOT IMPLEMENTED YET."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:id ;
      spl:valueType xsd:string ;
      rdfs:comment "The (HTML and ui:loadable) id to use for this Window. Must be a string constant - no variables or other expressions allowed!"^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:layoutPanel ;
      spl:valueType xsd:string ;
      rdfs:comment "The position within the surrounding BorderLayout: one of \"east\", \"north\", \"west\", \"south\" or \"center\"."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "The label in the header."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group>
    <div class=\"swa-window swa-window-border ui-layout-{= ?layoutPanel }\" id=\"{= ?id }\">
        <div class=\"swa-header\">
            <div class=\"swa-window-header-label swa-header-label\" id=\"{= ?id }-window-title\">{= ?title }</div>
            <div style=\"float: right\">
                <ui:if ui:condition=\"{= ?closable }\">
                    <swa:WindowHeaderButton arg:function=\"swa.closeWindow\" arg:iconClass=\"swa-window-header-button-close\" arg:toolTip=\"Close\"/>
                </ui:if>
                <ui:if ui:condition=\"{= ?maximizable }\">
                    <swa:WindowHeaderButton arg:function=\"swa.maximizeWindow\" arg:iconClass=\"swa-window-header-button-maximize\" arg:toolTip=\"Maximize\"/>
                </ui:if>
                <ui:if ui:condition=\"{= ?minimizable }\">
                    <swa:WindowHeaderButton arg:function=\"swa.minimizeWindow\" arg:iconClass=\"swa-window-header-button-minimize\" arg:toolTip=\"Minimize\"/>
                </ui:if>
                <ui:insertionPoint ui:pointId=\"buttons\"/>
            </div>
            <div style=\"clear: both\"/>
        </div>
        <ui:insertionPoint ui:pointId=\"1\"/>
        <ui:insertionPoint ui:pointId=\"2\"/>
        <ui:insertionPoint ui:pointId=\"3\"/>
        <ui:insertionPoint ui:pointId=\"4\"/>
        <ui:insertionPoint ui:pointId=\"5\"/>
    </div>
</ui:group>
"""^^ui:Literal ;
  ui:responseType ui:HTML ;
  rdfs:comment """A rectangular area with a title bar and optional buttons to close, minimize and maximize. Instances of swa:Window can be inserted into a BorderLayout.

Each swa:Window has a number of insertion points, that can be used to define the body and to insert additional buttons into the upper right corner. By default, children of the swa:Window tag are inserted under the header. The main area of the window should have the HTML class \"ui-layout-content\" so that the layout engine will give it the maximum available space and place scroll bars properly. Other children can be placed as secondary header or footer areas. To insert additional buttons, use <ui:insert ui:into=\"buttons><swa:WindowHeaderButton ... /></ui:insert>.

The content of a Window can be reloaded through an Ajax call, using the JavaScript functions swa:load or swa:loadWithResource."""^^xsd:string ;
  rdfs:label "Window"^^xsd:string ;
  rdfs:subClassOf swa:ApplicationElements ;
.
swa:WindowHeaderButton
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:toolTip ;
      spl:valueType xsd:string ;
      rdfs:comment "The tool tip text to show up above the button."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:function ;
      spl:valueType xsd:string ;
      rdfs:comment "The JS function to call, e.g. \"swa.closeWindow\"."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:iconClass ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the icon class."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  ui:prototype """
<div class=\"swa-window-header-button {= ?iconClass }\" onclick=\"{= ui:functionCall(?function, swa:currentWindowId()) }\" title=\"{= ?toolTip }\"/>
"""^^ui:Literal ;
  rdfs:label "Window header button"^^xsd:string ;
  rdfs:subClassOf swa:ApplicationElements ;
.
swa:WindowTitleSetter
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:title ;
      spl:valueType xsd:string ;
      rdfs:comment "The new title."^^xsd:string ;
    ] ;
  ui:prototype """
<script>{= ui:functionCall(\"swa.setWindowTitle\", swa:currentWindowId(), ?title) }</script>
"""^^ui:Literal ;
  rdfs:comment "Generates a script tag that will modify the title of the surrounding window."^^xsd:string ;
  rdfs:label "Window title setter"^^xsd:string ;
  rdfs:subClassOf swa:ScriptElements ;
.
swa:abbreviatedText
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:le ;
                        sp:arg1 [
                            rdf:type fn:string-length ;
                            sp:arg1 [
                                sp:varName "input"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            sp:varName "maxLength"^^xsd:string ;
                          ] ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        sp:varName "input"^^xsd:string ;
                      ] ;
                    sp:variable [
                        sp:varName "result"^^xsd:string ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:coalesce ;
                        sp:arg1 [
                            rdf:type spif:lastIndexOf ;
                            sp:arg1 [
                                sp:varName "input"^^xsd:string ;
                              ] ;
                            sp:arg2 " " ;
                            sp:arg3 [
                                sp:varName "maxLength"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            sp:varName "maxLength"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "lastSpace"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type sp:concat ;
                        sp:arg1 [
                            rdf:type fn:substring ;
                            sp:arg1 [
                                sp:varName "input"^^xsd:string ;
                              ] ;
                            sp:arg2 0 ;
                            sp:arg3 [
                                rdf:type sp:add ;
                                sp:arg1 [
                                    sp:varName "lastSpace"^^xsd:string ;
                                  ] ;
                                sp:arg2 1 ;
                              ] ;
                          ] ;
                        sp:arg2 "..." ;
                      ] ;
                    sp:variable [
                        sp:varName "result"^^xsd:string ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:input ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:maxLength ;
      spl:valueType xsd:integer ;
      rdfs:comment "The maximum length of the string."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a string and makes sure it is shorter than the given length - using ... if necessary. The algorithm will cut the string off at a suitable location, a space character."^^xsd:string ;
  rdfs:label "abbreviated text"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestObjectEditorClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            rdf:type swa:bestObjectWidgetClass ;
            arg:object [
                sp:varName "object"^^xsd:string ;
              ] ;
            arg:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            arg:range [
                sp:varName "range"^^xsd:string ;
              ] ;
            arg:resourceType [
                sp:varName "subjectType"^^xsd:string ;
              ] ;
            arg:type swa:ObjectEditorClass ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:resourceType ;
                arg:subject [
                    sp:varName "subject"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "subjectType"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:bound ;
                    sp:arg1 [
                        sp:varName "predicate"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type swa:localRange ;
                    arg:predicate [
                        sp:varName "predicate"^^xsd:string ;
                      ] ;
                    arg:subject [
                        sp:varName "subject"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "none"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "range"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:object ;
      rdfs:comment "The node of the existing value."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType swa:ObjectEditorClass ;
  rdfs:comment "Find the best suitable ObjectEditor for a given node, predicate, subject, subjectType combination. May return nothing, e.g. for blank nodes."^^xsd:string ;
  rdfs:label "node editor class"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestObjectFacetClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type swa:bestObjectWidgetClass ;
                arg:object [
                    sp:varName "none"^^xsd:string ;
                  ] ;
                arg:predicate [
                    sp:varName "predicate"^^xsd:string ;
                  ] ;
                arg:range [
                    rdf:type swa:localRangeAtClass ;
                    arg:class [
                        rdf:type swa:resourceType ;
                      ] ;
                    arg:property [
                        sp:varName "predicate"^^xsd:string ;
                      ] ;
                  ] ;
                arg:resourceType [
                    rdf:type swa:resourceType ;
                  ] ;
                arg:type swa:ObjectFacetClass ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType swa:ObjectEditorClass ;
  rdfs:comment "Find the best suitable ObjectFacet for a given predicate and resourceType combination. May return nothing, e.g. for blank nodes."^^xsd:string ;
  rdfs:label "best object facet class"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestObjectViewerClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            rdf:type swa:bestObjectWidgetClass ;
            arg:object [
                sp:varName "object"^^xsd:string ;
              ] ;
            arg:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            arg:range [
                sp:varName "range"^^xsd:string ;
              ] ;
            arg:resourceType [
                sp:varName "subjectType"^^xsd:string ;
              ] ;
            arg:type swa:ObjectViewerClass ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:resourceType ;
                arg:subject [
                    sp:varName "subject"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "subjectType"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "predicate"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "subject"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type swa:localRange ;
                    arg:predicate [
                        sp:varName "predicate"^^xsd:string ;
                      ] ;
                    arg:subject [
                        sp:varName "subject"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "none"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "range"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:object ;
      rdfs:comment "The node to get the widget type for."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType swa:ObjectWidgetClass ;
  rdfs:comment "Walks through all ObjectWidgets of a given type (?type) that declare a weight and returns the widget class that has the highest weight for a given node, predicate and subject."^^xsd:string ;
  rdfs:label "best object viewer"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestObjectWidgetClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "widgetClass"^^xsd:string ;
          ]
        ) ;
      sp:where (
          (
            [
              rdf:type sp:NamedGraph ;
              sp:elements (
                  [
                    rdf:type sp:SubQuery ;
                    sp:query [
                        rdf:type sp:Select ;
                        sp:orderBy (
                            [
                              rdf:type sp:Desc ;
                              sp:expression [
                                  sp:varName "weight"^^xsd:string ;
                                ] ;
                            ]
                          ) ;
                        sp:where (
                            [
                              sp:object [
                                  sp:varName "type"^^xsd:string ;
                                ] ;
                              sp:predicate rdf:type ;
                              sp:subject [
                                  sp:varName "widgetClass"^^xsd:string ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "w"^^xsd:string ;
                                ] ;
                              sp:predicate swa:objectWidgetWeight ;
                              sp:subject [
                                  sp:varName "widgetClass"^^xsd:string ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "expression"^^xsd:string ;
                                ] ;
                              sp:predicate swa:expression ;
                              sp:subject [
                                  sp:varName "w"^^xsd:string ;
                                ] ;
                            ]
                            [
                              rdf:type sp:Bind ;
                              sp:expression [
                                  rdf:type sp:coalesce ;
                                  sp:arg1 [
                                      rdf:type spl:object ;
                                      sp:arg1 [
                                          sp:varName "w"^^xsd:string ;
                                        ] ;
                                      sp:arg2 swa:weight ;
                                    ] ;
                                  sp:arg2 0 ;
                                ] ;
                              sp:variable [
                                  sp:varName "weight"^^xsd:string ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type spin:eval ;
                        sp:arg1 [
                            sp:varName "expression"^^xsd:string ;
                          ] ;
                        sp:arg2 arg:object ;
                        sp:arg3 [
                            sp:varName "object"^^xsd:string ;
                          ] ;
                        sp:arg4 arg:predicate ;
                        sp:arg5 [
                            sp:varName "predicate"^^xsd:string ;
                          ] ;
                        sp:arg6 arg:range ;
                        sp:arg7 [
                            sp:varName "range"^^xsd:string ;
                          ] ;
                        sp:arg8 arg:resourceType ;
                        sp:arg9 [
                            sp:varName "resourceType"^^xsd:string ;
                          ] ;
                      ] ;
                  ]
                ) ;
              sp:graphNameNode ui:graph ;
            ]
          )
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The range of the predicate at the subjectType."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:object ;
      rdfs:comment "The object to get the widget type for."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The subject type."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type that the widget class must have, e.g. swa:NodeEditorClass"^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType swa:ObjectWidgetClass ;
  rdfs:comment "Walks through all ObjectWidget classes of a given type (?type) that declare an objectWidgetWeight and returns the ObjectWidget class that has the highest weight for a given node (?node), predicate (?predicate), resource type (?resourceType) and local range (?range). All arguments are optional, but not all will be empty. If the resourceType and predicate are known, then also the ?range will be bound."^^xsd:string ;
  rdfs:label "best object widget class"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestSubjectEditorClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            rdf:type swa:bestSubjectWidgetClass ;
            arg:objectType [
                rdf:type swa:resourceType ;
                arg:resource [
                    sp:varName "object"^^xsd:string ;
                  ] ;
              ] ;
            arg:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            arg:subject [
                sp:varName "subject"^^xsd:string ;
              ] ;
            arg:type swa:SubjectEditorClass ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:objectType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of the main resource on the form."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType swa:SubjectEditorClass ;
  rdfs:comment "Find the best suitable SubjectEditor for a given object/predicate. May return nothing, e.g. for blank nodes."^^xsd:string ;
  rdfs:label "subject editor class"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestSubjectFacetClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type swa:bestSubjectWidgetClass ;
                arg:objectType [
                    rdf:type swa:resourceType ;
                    arg:resource [
                        sp:varName "object"^^xsd:string ;
                      ] ;
                  ] ;
                arg:predicate [
                    sp:varName "predicate"^^xsd:string ;
                  ] ;
                arg:subject [
                    sp:varName "none"^^xsd:string ;
                  ] ;
                arg:type swa:SubjectFacetClass ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType swa:SubjectEditorClass ;
  rdfs:comment "Find the best suitable SubjectFacet for a given predicate, object combination. May return nothing, e.g. for blank nodes."^^xsd:string ;
  rdfs:label "best node facet class"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestSubjectViewerClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            rdf:type swa:bestSubjectWidgetClass ;
            arg:objectType [
                sp:varName "objectType"^^xsd:string ;
              ] ;
            arg:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            arg:subject [
                sp:varName "subject"^^xsd:string ;
              ] ;
            arg:type swa:SubjectViewerClass ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:resourceType ;
                arg:resource [
                    sp:varName "object"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectType"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The node to get the widget type for."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the editor."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType swa:SubjectWidgetClass ;
  rdfs:comment "Walks through all SubjectWidgets of a given type (?type) that declare a subjectWidgetWeight and returns the widget class that has the highest weight for a given object, predicate and subject."^^xsd:string ;
  rdfs:label "best subject viewer"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:bestSubjectWidgetClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "widgetClass"^^xsd:string ;
          ]
        ) ;
      sp:where (
          (
            [
              rdf:type sp:NamedGraph ;
              sp:elements (
                  [
                    rdf:type sp:SubQuery ;
                    sp:query [
                        rdf:type sp:Select ;
                        sp:orderBy (
                            [
                              rdf:type sp:Desc ;
                              sp:expression [
                                  sp:varName "weight"^^xsd:string ;
                                ] ;
                            ]
                          ) ;
                        sp:where (
                            [
                              sp:object [
                                  sp:varName "type"^^xsd:string ;
                                ] ;
                              sp:predicate rdf:type ;
                              sp:subject [
                                  sp:varName "widgetClass"^^xsd:string ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "w"^^xsd:string ;
                                ] ;
                              sp:predicate swa:subjectWidgetWeight ;
                              sp:subject [
                                  sp:varName "widgetClass"^^xsd:string ;
                                ] ;
                            ]
                            [
                              sp:object [
                                  sp:varName "expression"^^xsd:string ;
                                ] ;
                              sp:predicate swa:expression ;
                              sp:subject [
                                  sp:varName "w"^^xsd:string ;
                                ] ;
                            ]
                            [
                              rdf:type sp:Bind ;
                              sp:expression [
                                  rdf:type sp:coalesce ;
                                  sp:arg1 [
                                      rdf:type spl:object ;
                                      sp:arg1 [
                                          sp:varName "w"^^xsd:string ;
                                        ] ;
                                      sp:arg2 swa:weight ;
                                    ] ;
                                  sp:arg2 0 ;
                                ] ;
                              sp:variable [
                                  sp:varName "weight"^^xsd:string ;
                                ] ;
                            ]
                          ) ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type spin:eval ;
                        sp:arg1 [
                            sp:varName "expression"^^xsd:string ;
                          ] ;
                        sp:arg2 arg:objectType ;
                        sp:arg3 [
                            sp:varName "objectType"^^xsd:string ;
                          ] ;
                        sp:arg4 arg:predicate ;
                        sp:arg5 [
                            sp:varName "predicate"^^xsd:string ;
                          ] ;
                        sp:arg6 arg:subject ;
                        sp:arg7 [
                            sp:varName "subject"^^xsd:string ;
                          ] ;
                      ] ;
                  ]
                ) ;
              sp:graphNameNode ui:graph ;
            ]
          )
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject value."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:objectType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The object to get the widget type for."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type that the widget class must have, e.g. swa:NodeEditorClass"^^xsd:string ;
    ] ;
  spin:returnType swa:SubjectWidgetClass ;
  rdfs:comment "Walks through all SubjectWidget classes of a given type (?type) that declare a subjectWidgetWeight and returns the widget class that has the highest weight for a given node (?subject), predicate (?predicate), object type (?objectType). All arguments are optional, but not all will be empty. If the objectType and predicate are known, then also the ?range will be bound."^^xsd:string ;
  rdfs:label "best subject widget class"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:blankNodeProperty
  rdf:type rdf:Property ;
  rdfs:comment "If set to true for a property, then SWA will assume that the values of this property are blank nodes and the life cycle of those nodes depends on the subject. SWA will edit them with swa:NestedObjectEditors."^^xsd:string ;
  rdfs:domain rdf:Property ;
  rdfs:label "blank node property"^^xsd:string ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:bnodeId
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:encodeNode ;
                sp:arg1 [
                    sp:varName "bnode"^^xsd:string ;
                  ] ;
                sp:arg2 "true"^^xsd:boolean ;
              ] ;
            sp:variable [
                sp:varName "label"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type afn:substr ;
                sp:arg1 [
                    sp:varName "label"^^xsd:string ;
                  ] ;
                sp:arg2 1 ;
                sp:arg3 [
                    rdf:type sp:sub ;
                    sp:arg1 [
                        rdf:type fn:string-length ;
                        sp:arg1 [
                            sp:varName "label"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg2 1 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:bnode ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the id of."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the internal ID of a bnode, starting with @."^^xsd:string ;
  rdfs:label "bnode id"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:classHasSubClassOrDirectRelevantProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "class"^^xsd:string ;
                      ] ;
                    sp:predicate rdfs:subClassOf ;
                    sp:subject [
                        sp:varName "anySubClass"^^xsd:string ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "anyProperty"^^xsd:string ;
                      ] ;
                    sp:predicate swa:directRelevantClassOfProperty ;
                    sp:subject [
                        sp:varName "class"^^xsd:string ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to check."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "A helper method needed by the Class-Property tree because a Jena bug prevents the use of a magic property within a BIND."^^xsd:string ;
  rdfs:label "class has sub class or direct relevant property"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:containsCurrentModeName
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:modeProperty ;
                arg:predicate swa:modeName ;
              ] ;
            sp:variable [
                sp:varName "currentModeName"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0"^^xsd:string ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "modeName"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "modeNames"^^xsd:string ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1"^^xsd:string ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            sp:object "," ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    sp:varName "currentModeName"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "modeName"^^xsd:string ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:modeNames ;
      spl:valueType xsd:string ;
      rdfs:comment "A comma-separated list of name of the modes to match against."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given string of comma-separate mode names contains the name of the current mode. For example, swa:containsCurrentMode(\"search,edit\") will return true if the current mode is \"edit\"."^^xsd:string ;
  rdfs:label "contains current mode name"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:contextValueIsTrue
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:contextValue ;
                sp:arg1 [
                    sp:varName "varName"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "value"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                sp:varName "value"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:varName ;
      spl:valueType xsd:string ;
      rdfs:comment "The variable name."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given context value has the value \"true\"."^^xsd:string ;
  rdfs:label "context value is true"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:createDefaultLink
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "link"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:currentQueryGraph ;
              ] ;
            sp:variable [
                sp:varName "baseURI"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type fn:concat ;
                sp:arg1 "swa.navigateTo('" ;
                sp:arg2 [
                    rdf:type xsd:string ;
                    sp:arg1 [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg3 "', '" ;
                sp:arg4 [
                    rdf:type xsd:string ;
                    sp:arg1 [
                        sp:varName "baseURI"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg5 "')" ;
              ] ;
            sp:variable [
                sp:varName "link"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "The default CreateLinkFunction - it simply navigates to the resource with a call of the SWP servlet."^^xsd:string ;
  rdfs:label "create default link"^^xsd:string ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:createEventLink
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          (
            [
              rdf:type sp:Bind ;
              sp:expression [
                  rdf:type ui:contextValue ;
                  sp:arg1 "createEventLinkEvent" ;
                ] ;
              sp:variable [
                  sp:varName "event"^^xsd:string ;
                ] ;
            ]
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "event"^^xsd:string ;
                    ] ;
                ] ;
            ]
          )
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:publishEvent ;
                arg:data [
                    rdf:type sp:concat ;
                    sp:arg1 "\"" ;
                    sp:arg2 [
                        rdf:type xsd:string ;
                        sp:arg1 [
                            sp:varName "resource"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg3 "\"" ;
                  ] ;
                sp:arg1 [
                    sp:varName "event"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "A CreateLinkFunction that publishes the selected resource with an event. The name of the event must be specified in as the context variable \"createEventLinkEvent\"."^^xsd:string ;
  rdfs:label "create event link"^^xsd:string ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:createEventOrNewTabLink
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:exists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "anyO"^^xsd:string ;
                            ] ;
                          sp:predicate [
                              sp:varName "anyP"^^xsd:string ;
                            ] ;
                          sp:subject [
                              sp:varName "resource"^^xsd:string ;
                            ] ;
                        ]
                      ) ;
                  ] ;
                sp:arg2 [
                    rdf:type swa:createEventLink ;
                    arg:resource [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg3 [
                    rdf:type swa:createNewTabLink ;
                    arg:resource [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Depending on whether the given resource has any properties, it will either publish an event to navigate to the resource or open a new browser tab with the given URL for external resources."^^xsd:string ;
  rdfs:label "create event or new tab link"^^xsd:string ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:createLink
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "link"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:contextValue ;
                sp:arg1 "createLinkFunction" ;
              ] ;
            sp:variable [
                sp:varName "createLinkFunction"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:bound ;
                    sp:arg1 [
                        sp:varName "createLinkFunction"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type spif:invoke ;
                    sp:arg1 [
                        sp:varName "createLinkFunction"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                    sp:arg3 [
                        sp:varName "uid"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg3 [
                    rdf:type swa:createDefaultLink ;
                    arg:resource [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "link"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Creates a line of JavaScript code that can be inserted into an HTML document to produce a hyper link. The implementation of this function is very flexible and can be replaced depending on the context. The function checks if the context variable \"createLinkFunction\" points to another SPIN function. If so, then it calls that SPIN function with the given resource and uid arguments. Otherwise, it falls back to the built-in swa:createDefaultLink function that calls swa.navigateTo. If you want to replace the default behavior, create your own subclass of swa:CreateLinkFunctions, and then use ui:setContext to activate this link function for the contained elements."^^xsd:string ;
  rdfs:label "create link"^^xsd:string ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:createLoadSearchFormCall
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type fn:concat ;
                sp:arg1 "swa.loadSearchForm('" ;
                sp:arg10 [
                    rdf:type ui:currentQueryGraph ;
                  ] ;
                sp:arg11 "'" ;
                sp:arg12 [
                    sp:varName "nb"^^xsd:string ;
                  ] ;
                sp:arg13 ")" ;
                sp:arg2 [
                    sp:varName "oldElementId"^^xsd:string ;
                  ] ;
                sp:arg3 "', '" ;
                sp:arg4 [
                    sp:varName "resultsId"^^xsd:string ;
                  ] ;
                sp:arg5 "', " ;
                sp:arg6 [
                    sp:varName "resourceTypeCode"^^xsd:string ;
                  ] ;
                sp:arg7 ", '" ;
                sp:arg8 [
                    sp:varName "queryGraph"^^xsd:string ;
                  ] ;
                sp:arg9 "', '" ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    sp:varName "noBorder"^^xsd:string ;
                  ] ;
                sp:arg2 ", true" ;
                sp:arg3 [
                    sp:varName "none"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "nb"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:queryGraph ;
      spl:valueType owl:Ontology ;
      rdfs:comment "The schema graph."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:noBorder ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to set the noBorder flag."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:oldElementId ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the element to replace."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resourceTypeCode ;
      spl:valueType xsd:string ;
      rdfs:comment "A JavaScript expression that produces the URI of the resource type. When used in a Tree, this would be 'resource', while in other cases it might be a static URI string."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resultsId ;
      spl:valueType xsd:string ;
      rdfs:comment "The results id."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:label "create load search form call"^^xsd:string ;
  rdfs:subClassOf swa:CreateCallFunctions ;
.
swa:createNewTabLink
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "window.open('" ;
                sp:arg2 [
                    rdf:type xsd:string ;
                    sp:arg1 [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg3 "', '_blank')" ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Creates a link that opens the resource in a new tab or window."^^xsd:string ;
  rdfs:label "create new tab link"^^xsd:string ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:createNoLink
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "nothing"^^xsd:string ;
          ]
        ) ;
      sp:where () ;
    ] ;
  rdfs:comment "A dummy function that returns nothing, suppressing any links."^^xsd:string ;
  rdfs:label "create no link"^^xsd:string ;
  rdfs:subClassOf swa:CreateLinkFunctions ;
.
swa:currentWindowId
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "id"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                (
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type ui:nearestViewWithType ;
                        sp:arg1 swa:Window ;
                      ] ;
                    sp:variable [
                        sp:varName "window"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "window"^^xsd:string ;
                          ] ;
                      ] ;
                  ]
                )
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spl:object ;
                      sp:arg1 [
                          sp:varName "window"^^xsd:string ;
                        ] ;
                      sp:arg2 arg:id ;
                    ] ;
                  sp:variable [
                      sp:varName "id"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "If called within an swa:Window, this gets the id of the surrounding window."^^xsd:string ;
  rdfs:label "current window id"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:customLanguages
  rdf:type rdf:Property ;
  rdfs:comment "Can be used to override the default languages in a TBL installation. Value format is the same as swa:defaultLanguages."^^xsd:string ;
  rdfs:domain swa:LangSelector ;
  rdfs:label "custom languages"^^xsd:string ;
  rdfs:range xsd:string ;
.
swa:defaultLanguages
  rdf:type rdf:Property ;
  rdfs:comment "Contains the list of default languages to be used in the lang selector."^^xsd:string ;
  rdfs:label "default languages"^^xsd:string ;
  rdfs:range xsd:string ;
.
swa:delete
  rdf:type rdf:Property ;
  rdfs:label "delete"^^xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:description
  rdf:type rdf:Property ;
  rdfs:comment "Serves as super-property of properties containing a description or summary of the subject resource."^^xsd:string ;
  rdfs:label "description"^^xsd:string ;
  rdfs:range xsd:string ;
.
swa:expression
  rdf:type rdf:Property ;
  rdfs:domain swa:WeightedExpression ;
  rdfs:label "expression"^^xsd:string ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:facetSearchType
  rdf:type rdf:Property ;
  rdfs:comment "The sub-type(s) of search:FacetValue that this facet class is suitable for. For example swa:AnyObjectFacet is responsible for search:AnyFacetValue."^^xsd:string ;
  rdfs:domain swa:ObjectFacetClass ;
  rdfs:label "facet search type"^^xsd:string ;
  rdfs:range rdfs:Class ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:filterSubclassesOfRoot
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "root"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "node"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The root of the class tree."^^xsd:string ;
    ] ;
  rdfs:label "filter subclasses of root"^^xsd:string ;
  rdfs:subClassOf swa:FilterFunctions ;
.
swa:filterSystemResources
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:isIRI ;
                sp:arg1 [
                    sp:varName "node"^^xsd:string ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type afn:namespace ;
                sp:arg1 [
                    sp:varName "node"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "ns"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:and ;
                sp:arg1 [
                    rdf:type sp:and ;
                    sp:arg1 [
                        rdf:type sp:and ;
                        sp:arg1 [
                            rdf:type sp:ne ;
                            sp:arg1 [
                                sp:varName "ns"^^xsd:string ;
                              ] ;
                            sp:arg2 "http://www.w3.org/2000/01/rdf-schema#" ;
                          ] ;
                        sp:arg2 [
                            rdf:type sp:ne ;
                            sp:arg1 [
                                sp:varName "ns"^^xsd:string ;
                              ] ;
                            sp:arg2 "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:ne ;
                        sp:arg1 [
                            sp:varName "ns"^^xsd:string ;
                          ] ;
                        sp:arg2 "http://www.w3.org/2002/07/owl#" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:ne ;
                    sp:arg1 [
                        sp:varName "ns"^^xsd:string ;
                      ] ;
                    sp:arg2 "http://www.w3.org/2001/XMLSchema#" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Filters out any resources from the RDF, RDFS, OWL or XSD namespaces."^^xsd:string ;
  rdfs:label "filter system resources"^^xsd:string ;
  rdfs:subClassOf swa:FilterFunctions ;
.
swa:formClass
  rdf:type rdf:Property ;
  rdfs:comment "Links a mode with a form class."^^xsd:string ;
  rdfs:domain swa:Mode ;
  rdfs:label "form class"^^xsd:string ;
  rdfs:range swa:FormClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:formObjectPredicateSelectionTemplate
  rdf:type rdf:Property ;
  rdfs:comment "The SPIN template that delivers the predicates that shall be displayed on a (default) form in this mode. For example, in editing mode this will include all suitable predicates, while in viewing mode this may only include the used predicates for the given subject."^^xsd:string ;
  rdfs:domain swa:Mode ;
  rdfs:label "form object predicate selection template"^^xsd:string ;
  rdfs:range spin:Template ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:formSubjectPredicateSelectionTemplate
  rdf:type rdf:Property ;
  rdfs:comment "The SPIN template that delivers the predicates that shall be displayed on a (default) form in this mode. For example, in editing mode this will include all suitable predicates, while in viewing mode this may only include the used predicates for the given subject."^^xsd:string ;
  rdfs:domain swa:Mode ;
  rdfs:label "form subject predicate selection template"^^xsd:string ;
  rdfs:range spin:Template ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:fullTextSearchPropertiesConcat
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:orderBy (
          [
            sp:varName "property"^^xsd:string ;
          ]
        ) ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:GroupConcat ;
                sp:expression [
                    sp:varName "str"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "type"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "subClass"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "property"^^xsd:string ;
                    ] ;
                  sp:predicate swa:fullTextSearchProperty ;
                  sp:subject [
                      sp:varName "type"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "<" ;
                sp:arg2 [
                    rdf:type xsd:string ;
                    sp:arg1 [
                        sp:varName "property"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg3 "> " ;
              ] ;
            sp:variable [
                sp:varName "str"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:label "full text search properties concat"^^xsd:string ;
  rdfs:subClassOf swa:FullTextSearchFunctions ;
.
swa:fullTextSearchProperty
  rdf:type rdf:Property ;
  rdfs:comment "Links a class with one or more properties that shall be searched in full text mode. If the class shown on a SearchForm (or one of its superclasses) define at least one fullTextSearchProperty then a special full text search section will appear on top of the search form. When sent off to the server, this will be regex'ed by the search engine across all the mentioned properties. Usually, the values of this property are (datatype) properties with xsd:string or rdf:HTML as their range."^^xsd:string ;
  rdfs:domain rdfs:Class ;
  rdfs:label "full text search properties"^^xsd:string ;
  rdfs:range rdf:Property ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:getDescription
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object swa:description ;
                  sp:path [
                      rdf:type sp:ModPath ;
                      sp:modMax -2 ;
                      sp:modMin 0 ;
                      sp:subPath rdfs:subPropertyOf ;
                    ] ;
                  sp:subject [
                      sp:varName "property"^^xsd:string ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "result"^^xsd:string ;
                    ] ;
                  sp:predicate [
                      sp:varName "property"^^xsd:string ;
                    ] ;
                  sp:subject [
                      sp:varName "resource"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the image for."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the \"deescription\" for a given resource. This will try to find a value for one of the sub-properties of swa:description."^^xsd:string ;
  rdfs:label "get description"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:getGadgetFromLabel
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "gadget"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object swa:Gadget ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "gadget"^^xsd:string ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "gadgetLabel"^^xsd:string ;
                    ] ;
                  sp:predicate rdfs:label ;
                  sp:subject [
                      sp:varName "gadget"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:gadgetLabel ;
      spl:valueType xsd:string ;
      rdfs:comment "rdfs:label for gadget"^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType swa:Gadget ;
  rdfs:label "Gadget from Label"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:getKeyProperties
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "keyProperties"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spif:walkObjects ;
                      sp:arg1 [
                          sp:varName "class"^^xsd:string ;
                        ] ;
                      sp:arg2 rdfs:subClassOf ;
                      sp:arg3 swa:keyPropertiesFunctor ;
                    ] ;
                  sp:variable [
                      sp:varName "keyProperties"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to start traversal at."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdf:List ;
  rdfs:comment "Gets the key properties of a given class, by walking up the superclasses until it finds a class with declared swa:keyProperties."^^xsd:string ;
  rdfs:label "get key properties"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:getThumbnail
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object swa:thumbnail ;
                  sp:path [
                      rdf:type sp:ModPath ;
                      sp:modMax -2 ;
                      sp:modMin 0 ;
                      sp:subPath rdfs:subPropertyOf ;
                    ] ;
                  sp:subject [
                      sp:varName "property"^^xsd:string ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "image"^^xsd:string ;
                    ] ;
                  sp:predicate [
                      sp:varName "property"^^xsd:string ;
                    ] ;
                  sp:subject [
                      sp:varName "resource"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:not ;
                      sp:arg1 [
                          rdf:type sp:isBlank ;
                          sp:arg1 [
                              sp:varName "image"^^xsd:string ;
                            ] ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:isIRI ;
                    sp:arg1 [
                        sp:varName "image"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "image"^^xsd:string ;
                  ] ;
                sp:arg3 [
                    rdf:type sp:iri ;
                    sp:arg1 [
                        sp:varName "image"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the image for."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the \"summary image\" for a given resource. This will try to find a value for one of the sub-properties of swa:thumbnail."^^xsd:string ;
  rdfs:label "get thumbnail"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasFullTextSearchProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "type"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "subClass"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "any"^^xsd:string ;
                    ] ;
                  sp:predicate swa:fullTextSearchProperty ;
                  sp:subject [
                      sp:varName "type"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given class or its superclasses have declared any values of swa:fullTextSearchProperty."^^xsd:string ;
  rdfs:label "has full text search property"^^xsd:string ;
  rdfs:subClassOf swa:FullTextSearchFunctions ;
.
swa:hasKeyProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          (
            [
              rdf:type sp:Bind ;
              sp:expression [
                  rdf:type swa:getKeyProperties ;
                  arg:class [
                      sp:varName "class"^^xsd:string ;
                    ] ;
                ] ;
              sp:variable [
                  sp:varName "k"^^xsd:string ;
                ] ;
            ]
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "k"^^xsd:string ;
                    ] ;
                ] ;
            ]
          )
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "property"^^xsd:string ;
                    ] ;
                  sp:predicate list:member ;
                  sp:subject [
                      sp:varName "k"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to check."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given property is a key property of a given class."^^xsd:string ;
  rdfs:label "has key property"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasMatchingInverseRestoreFacetValue
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:restoreInverseFacetValue ;
                arg:property [
                    sp:varName "property"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "facetValue"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "facetValue"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:exists ;
                    sp:elements (
                        (
                          [
                            sp:object [
                                sp:varName "facetValueType"^^xsd:string ;
                              ] ;
                            sp:predicate rdf:type ;
                            sp:subject [
                                sp:varName "facetValue"^^xsd:string ;
                              ] ;
                          ]
                        )
                        [
                          rdf:type sp:NamedGraph ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "facetValueType"^^xsd:string ;
                                  ] ;
                                sp:predicate swa:facetSearchType ;
                                sp:subject [
                                    sp:varName "facetClass"^^xsd:string ;
                                  ] ;
                              ]
                            ) ;
                          sp:graphNameNode ui:graph ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:facetClass ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The facet class, e.g. swa:AnyObjectFacet."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check for."^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if the swa:facetSearchType declared for a given facet type (?facetClass) is compatible with the search:FacetValue of the current search that is being restored. Will return true if no Search is being restored."^^xsd:string ;
  rdfs:label "has matching inverse restore facet value"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasMatchingRestoreFacetValue
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:restoreFacetValue ;
                arg:property [
                    sp:varName "property"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "facetValue"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:not ;
                    sp:arg1 [
                        rdf:type sp:bound ;
                        sp:arg1 [
                            sp:varName "facetValue"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:exists ;
                    sp:elements (
                        (
                          [
                            sp:object [
                                sp:varName "facetValueType"^^xsd:string ;
                              ] ;
                            sp:predicate rdf:type ;
                            sp:subject [
                                sp:varName "facetValue"^^xsd:string ;
                              ] ;
                          ]
                        )
                        [
                          rdf:type sp:NamedGraph ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "facetValueType"^^xsd:string ;
                                  ] ;
                                sp:predicate swa:facetSearchType ;
                                sp:subject [
                                    sp:varName "facetClass"^^xsd:string ;
                                  ] ;
                              ]
                            ) ;
                          sp:graphNameNode ui:graph ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:facetClass ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The facet class, e.g. swa:AnyObjectFacet."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check for."^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if the swa:facetSearchType declared for a given facet type (?facetClass) is compatible with the search:FacetValue of the current search that is being restored. Will return true if no Search is being restored."^^xsd:string ;
  rdfs:label "has matching restore facet value"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasNoColWidth
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "index"^^xsd:string ;
              ] ;
            sp:predicate spr:colIndices ;
            sp:subject [
                sp:varName "resultSet"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spr:colWidth ;
                sp:arg1 [
                    sp:varName "resultSet"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "index"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "width"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:not ;
                sp:arg1 [
                    rdf:type sp:bound ;
                    sp:arg1 [
                        sp:varName "width"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set to test."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:label "has no col width"^^xsd:string ;
  rdfs:subClassOf spr:Functions ;
.
swa:hasOtherArgument
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "superClass"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "con"^^xsd:string ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "superClass"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "con"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:notExists ;
                sp:elements (
                    [
                      sp:object arg:resource ;
                      sp:predicate spl:predicate ;
                      sp:subject [
                          sp:varName "con"^^xsd:string ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spl:class ;
      spl:valueType spin:Module ;
      rdfs:comment "The module class to check."^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given module class (?module) has at least one declared spl:Argument other than arg:resource."^^xsd:string ;
  rdfs:label "has other argument"^^xsd:string ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
swa:hasReadOnlyTriple
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                    sp:predicate [
                        sp:varName "p"^^xsd:string ;
                      ] ;
                    sp:subject [
                        sp:varName "s"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type swa:isReadOnlyTriple ;
                        sp:arg1 [
                            sp:varName "s"^^xsd:string ;
                          ] ;
                        sp:arg2 [
                            sp:varName "p"^^xsd:string ;
                          ] ;
                        sp:arg3 [
                            sp:varName "resource"^^xsd:string ;
                          ] ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "o"^^xsd:string ;
                      ] ;
                    sp:predicate [
                        sp:varName "p"^^xsd:string ;
                      ] ;
                    sp:subject [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:Filter ;
                    sp:expression [
                        rdf:type swa:isReadOnlyTriple ;
                        sp:arg1 [
                            sp:varName "resource"^^xsd:string ;
                          ] ;
                        sp:arg2 [
                            sp:varName "p"^^xsd:string ;
                          ] ;
                        sp:arg3 [
                            sp:varName "o"^^xsd:string ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a resource is used in at least one triple as subject or object, and this triple is read-only. This can be used to determine whether a resource can be (completely) deleted."^^xsd:string ;
  rdfs:label "has read-only triple"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:hasReadOnlyTripleInCurrentQueryGraph
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          (
            [
              rdf:type sp:Bind ;
              sp:expression [
                  rdf:type ui:currentQueryGraph ;
                ] ;
              sp:variable [
                  sp:varName "g"^^xsd:string ;
                ] ;
            ]
          )
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type swa:hasReadOnlyTriple ;
                      arg:resource [
                          sp:varName "resource"^^xsd:string ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode [
                sp:varName "g"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to check."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a resource is used in at least one triple as subject or object, and this triple is read-only. This can be used to determine whether a resource can be (completely) deleted. In contrast to its sibling function, this function here runs on the ui:currentQueryGraph(), not the default graph."^^xsd:string ;
  rdfs:label "has read-only triple in current query graph"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:hiddenProperty
  rdf:type rdf:Property ;
  rdfs:comment """Can be used to mark a property \"hidden\" so that it does not show up on forms unless explicitly enumerated. Possible values are:
- true: the property is always hidden
- \"if no object exists\": the property is hidden unless it has values
- false or none: not specified
By default, most system properties that have owl:Thing or rdfs:Resource are marked as hidden unless they have values. Some of those system properties are always hidden, so check for any triples assigned to them in the SWA file."""^^xsd:string ;
  rdfs:domain rdf:Property ;
  rdfs:label "hidden property"^^xsd:string ;
  rdfs:range [
      rdf:type rdfs:Datatype ;
      owl:oneOf (
          "true"^^xsd:boolean
          "if no object exists"^^xsd:string
        ) ;
    ] ;
.
swa:isBlankNodeProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object "true"^^xsd:boolean ;
                  sp:predicate swa:blankNodeProperty ;
                  sp:subject [
                      sp:varName "property"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to check."^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property has been marked to have blank nodes via swa:blankNodeProperty=true in the ui:graph."^^xsd:string ;
  rdfs:label "is blank node property"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:isEditMode
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    rdf:type swa:mode ;
                  ] ;
                sp:arg2 swa:EditMode ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the SWP engine is currently in edit mode, i.e. has the swa:mode set to swa:EditMode."^^xsd:string ;
  rdfs:label "is edit mode"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:isHiddenProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:text """ASK {
	GRAPH ui:unionGraph {
		?property swa:hiddenProperty true .
	}
}"""^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property to check."^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property has been marked as \"hidden\". To count as hidden, a property needs to have an annotation swa:hiddenProperty true in a globally registered .ui. graph or the current query graph."^^xsd:string ;
  rdfs:label "is hidden property"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:isHiddenPropertyAtSubject
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Union ;
                  sp:elements (
                      (
                        [
                          sp:object "true"^^xsd:boolean ;
                          sp:predicate swa:hiddenProperty ;
                          sp:subject [
                              sp:varName "property"^^xsd:string ;
                            ] ;
                        ]
                      )
                      (
                        [
                          sp:object "if no object exists" ;
                          sp:predicate swa:hiddenProperty ;
                          sp:subject [
                              sp:varName "property"^^xsd:string ;
                            ] ;
                        ]
                        [
                          rdf:type sp:Filter ;
                          sp:expression [
                              rdf:type sp:notExists ;
                              sp:elements (
                                  [
                                    sp:object [
                                        sp:varName "any"^^xsd:string ;
                                      ] ;
                                    sp:predicate [
                                        sp:varName "property"^^xsd:string ;
                                      ] ;
                                    sp:subject [
                                        sp:varName "subject"^^xsd:string ;
                                      ] ;
                                  ]
                                ) ;
                            ] ;
                        ]
                      )
                    ) ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property to check."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to check the status at."^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property has been marked as \"hidden\" for a given subject. To count as hidden, a property needs to have an annotation swa:hiddenProperty true in a globally registered .ui. graph or the current query graph. If the value of swa:hiddenProperty is \"if no object exists\" then the property will be treated as hidden if it has no values for the given subject."^^xsd:string ;
  rdfs:label "is hidden property at subject"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:isNotHiddenProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type spl:object ;
                      sp:arg1 [
                          sp:varName "property"^^xsd:string ;
                        ] ;
                      sp:arg2 swa:hiddenProperty ;
                    ] ;
                  sp:variable [
                      sp:varName "value"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:or ;
                      sp:arg1 [
                          rdf:type sp:not ;
                          sp:arg1 [
                              rdf:type sp:bound ;
                              sp:arg1 [
                                  sp:varName "value"^^xsd:string ;
                                ] ;
                            ] ;
                        ] ;
                      sp:arg2 [
                          rdf:type sp:not ;
                          sp:arg1 [
                              sp:varName "value"^^xsd:string ;
                            ] ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:unionGraph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The property to check."^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property has not been marked as \"hidden\". To count as hidden, a property needs to have an annotation swa:hiddenProperty true or \"if no object exists\" in a globally registered .ui. graph or the current query graph."^^xsd:string ;
  rdfs:label "is not hidden property"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:isSearchMode
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    rdf:type swa:mode ;
                  ] ;
                sp:arg2 swa:SearchMode ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the SWP engine is currently in search mode, i.e. has the swa:mode set to swa:SearchMode."^^xsd:string ;
  rdfs:label "is search mode"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:isSingleConstant
  rdf:type rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "is single constant"^^xsd:string ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:isSingleFunction
  rdf:type rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "is single function"^^xsd:string ;
  rdfs:range spin:Function ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:isViewMode
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    rdf:type swa:mode ;
                  ] ;
                sp:arg2 swa:ViewMode ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the SWP engine is currently in view mode, i.e. has the swa:mode set to swa:ViewMode."^^xsd:string ;
  rdfs:label "is view mode"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:keep
  rdf:type rdf:Property ;
  rdfs:label "keep"^^xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:keyProperties
  rdf:type rdf:Property ;
  rdfs:comment "Links a class with an rdf:List of properties that deliver the values that shall be displayed as columns if the user searches for instances of the class, or its sub-classes."^^xsd:string ;
  rdfs:domain rdfs:Class ;
  rdfs:label "key properties"^^xsd:string ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:keyPropertiesFromList
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
          [
            sp:varName "inverse"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "?0"^^xsd:string ;
              ] ;
            sp:predicate spif:split ;
            sp:subject [
                sp:varName "str"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg1 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1"^^xsd:string ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            sp:object " " ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type fn:starts-with ;
                sp:arg1 [
                    sp:varName "str"^^xsd:string ;
                  ] ;
                sp:arg2 "-" ;
              ] ;
            sp:variable [
                sp:varName "inverse"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:decodeNode ;
                sp:arg1 [
                    rdf:type sp:if ;
                    sp:arg1 [
                        sp:varName "inverse"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        rdf:type fn:substring ;
                        sp:arg1 [
                            sp:varName "str"^^xsd:string ;
                          ] ;
                        sp:arg2 2 ;
                      ] ;
                    sp:arg3 [
                        sp:varName "str"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The space-separated list of encoded key properties."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdf:Property ;
  rdfs:label "key properties from list"^^xsd:string ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:keyPropertiesFunctor
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "keyProperties"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "keyProperties"^^xsd:string ;
              ] ;
            sp:predicate swa:keyProperties ;
            sp:subject [
                sp:varName "class"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdf:List ;
  rdfs:label "key properties functor"^^xsd:string ;
  rdfs:subClassOf swa:ClassFunctorFunctions ;
.
swa:langImage
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type fn:concat ;
                sp:arg1 "lib/swa/css/images/flags/" ;
                sp:arg2 [
                    sp:varName "countryCode"^^xsd:string ;
                  ] ;
                sp:arg3 ".gif" ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type swa:countryCodeForLang ;
                arg:lang [
                    sp:varName "lang"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "countryCode"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "countryCode"^^xsd:string ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:lang ;
      spl:valueType xsd:string ;
      rdfs:comment "The language tag to get the image for."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the URL to an image for a given language tag (either 2 or 5 letter encoding)."^^xsd:string ;
  rdfs:label "lang image"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:mode
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:bound ;
                    sp:arg1 [
                        sp:varName "modeName"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:if ;
                    sp:arg1 [
                        rdf:type sp:eq ;
                        sp:arg1 "view" ;
                        sp:arg2 [
                            sp:varName "modeName"^^xsd:string ;
                          ] ;
                      ] ;
                    sp:arg2 swa:ViewMode ;
                    sp:arg3 [
                        rdf:type sp:if ;
                        sp:arg1 [
                            rdf:type sp:eq ;
                            sp:arg1 "edit" ;
                            sp:arg2 [
                                sp:varName "modeName"^^xsd:string ;
                              ] ;
                          ] ;
                        sp:arg2 swa:EditMode ;
                        sp:arg3 [
                            rdf:type swa:modeByName ;
                            arg:modeName [
                                sp:varName "modeName"^^xsd:string ;
                              ] ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg3 swa:ViewMode ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type ui:contextValue ;
                sp:arg1 "mode" ;
              ] ;
            sp:variable [
                sp:varName "modeName"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType swa:Mode ;
  rdfs:comment "Gets the current swa:Mode from the context variable \"mode\", defaulting to swa:ViewMode if nothing else has been specified."^^xsd:string ;
  rdfs:label "mode"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:modeByName
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "mode"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:bound ;
                      sp:arg1 [
                          sp:varName "modeName"^^xsd:string ;
                        ] ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "modeName"^^xsd:string ;
                    ] ;
                  sp:predicate swa:modeName ;
                  sp:subject [
                      sp:varName "mode"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:modeName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the mode to get."^^xsd:string ;
    ] ;
  spin:returnType swa:Mode ;
  rdfs:comment "Gets the swa:Mode with a given name."^^xsd:string ;
  rdfs:label "mode by name"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:modeLabel
  rdf:type rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "mode label"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:modeName
  rdf:type rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "mode name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:modeProperty
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:Bind ;
                  sp:expression [
                      rdf:type swa:mode ;
                    ] ;
                  sp:variable [
                      sp:varName "mode"^^xsd:string ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "result"^^xsd:string ;
                    ] ;
                  sp:predicate [
                      sp:varName "predicate"^^xsd:string ;
                    ] ;
                  sp:subject [
                      sp:varName "mode"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the object of."^^xsd:string ;
    ] ;
  rdfs:comment "Gets a property associated with the current mode."^^xsd:string ;
  rdfs:label "mode property"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:objectFacetMenuName
  rdf:type rdf:Property ;
  rdfs:comment "Links a facet with a display name for drop down menus."^^xsd:string ;
  rdfs:domain swa:ObjectFacetClass ;
  rdfs:label "object facet menu name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:objectHasSubjectFromEnum
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:predicate swa:predicatesOfSubjects ;
            sp:subject [
                sp:varName "view"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "object"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "any"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:object ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object to check."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:view ;
      spl:valueType swa:ObjectsEnum ;
      rdfs:comment "The view (usually instance of swa:ObjectsEnum)."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given object has at least one subject for any of the swa:Subjects under the given root element."^^xsd:string ;
  rdfs:label "object has subject from enum"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:objectWidgetClass
  rdf:type rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "object widget class"^^xsd:string ;
  rdfs:range swa:ObjectWidgetClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:objectWidgetMiddleColumnClass
  rdf:type rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "object widget middle column class"^^xsd:string ;
  rdfs:range swa:ObjectWidgetMiddleColumnClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:objectWidgetRowClass
  rdf:type rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "object widget row class"^^xsd:string ;
  rdfs:range swa:ObjectWidgetRowClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:objectWidgetWeight
  rdf:type rdf:Property ;
  rdfs:comment """An expression that computes the suitability of an ObjectWidget for a given object (?object) at a given predicate (?predicate) and type class (?subjectType) and range (?range). The larger the number the better. Returning unbound or false means not suitable, and returning true means a weight of 1.

This expression is called if a node and a predicate/subject type combination is present."""^^xsd:string ;
  rdfs:domain swa:ObjectWidgetClass ;
  rdfs:label "object widget weight"^^xsd:string ;
  rdfs:range swa:WeightedExpression ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:objectsBodyClass
  rdf:type rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "objects body class"^^xsd:string ;
  rdfs:range swa:ObjectWidgetClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:predicatesOfObjects
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "predicate"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "view"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:ModPath ;
                      sp:modMax -2 ;
                      sp:modMin 0 ;
                      sp:subPath ui:child ;
                    ] ;
                  sp:subject spin:_arg1 ;
                ]
                [
                  sp:object [
                      sp:varName "predicate"^^xsd:string ;
                    ] ;
                  sp:predicate arg:predicate ;
                  sp:subject [
                      sp:varName "view"^^xsd:string ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "type"^^xsd:string ;
                    ] ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "view"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:or ;
                      sp:arg1 [
                          rdf:type sp:eq ;
                          sp:arg1 [
                              sp:varName "type"^^xsd:string ;
                            ] ;
                          sp:arg2 swa:Object ;
                        ] ;
                      sp:arg2 [
                          rdf:type sp:eq ;
                          sp:arg1 [
                              sp:varName "type"^^xsd:string ;
                            ] ;
                          sp:arg2 swa:Objects ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType ui:Element ;
      rdfs:comment "The root view."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets all arg:predicates associated with swa:Object or swa:Objects underneath a given root view."^^xsd:string ;
  rdfs:label "predicates of objects"^^xsd:string ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:predicatesOfSubjects
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "predicate"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  rdf:type sp:TriplePath ;
                  sp:object [
                      sp:varName "view"^^xsd:string ;
                    ] ;
                  sp:path [
                      rdf:type sp:ModPath ;
                      sp:modMax -2 ;
                      sp:modMin 0 ;
                      sp:subPath ui:child ;
                    ] ;
                  sp:subject spin:_arg1 ;
                ]
                [
                  sp:object [
                      sp:varName "predicate"^^xsd:string ;
                    ] ;
                  sp:predicate arg:predicate ;
                  sp:subject [
                      sp:varName "view"^^xsd:string ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "type"^^xsd:string ;
                    ] ;
                  sp:predicate rdf:type ;
                  sp:subject [
                      sp:varName "view"^^xsd:string ;
                    ] ;
                ]
                [
                  rdf:type sp:Filter ;
                  sp:expression [
                      rdf:type sp:or ;
                      sp:arg1 [
                          rdf:type sp:eq ;
                          sp:arg1 [
                              sp:varName "type"^^xsd:string ;
                            ] ;
                          sp:arg2 swa:Subject ;
                        ] ;
                      sp:arg2 [
                          rdf:type sp:eq ;
                          sp:arg1 [
                              sp:varName "type"^^xsd:string ;
                            ] ;
                          sp:arg2 swa:Subjects ;
                        ] ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType ui:Element ;
      rdfs:comment "The root view."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets all arg:predicates associated with swa:Subject or swa:Subjects underneath a given root view."^^xsd:string ;
  rdfs:label "predicates of subjects"^^xsd:string ;
  rdfs:subClassOf spin:MagicProperties ;
.
swa:publishEvent
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 spin:_arg1 ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "gadgets.Hub.publish('" ;
                sp:arg2 spin:_arg1 ;
                sp:arg3 "', " ;
                sp:arg4 [
                    sp:varName "data"^^xsd:string ;
                  ] ;
                sp:arg5 ");" ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The event (sometimes called topic) that is being published. Should be formed according to http://www.openajax.org/member/wiki/OpenAjax_Hub_2.0_Specification_Topic_Names with names such as org.example.myapplication.myEvent. If left blank, the function returns nothing."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:data ;
      spl:valueType xsd:string ;
      rdfs:comment "A valid JavaScript expression that is passed around as data payload into the event bus."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Creates a JavaScript expression that publishes an event to the event hub used by SWA."^^xsd:string ;
  rdfs:label "publish event"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:randomInstance
  rdf:type ui:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The class to get an instance of."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  ui:prototype """
<ui:group letrs:rs=\"{#
        SELECT DISTINCT ?instance
        WHERE {
            ?type (rdfs:subClassOf)* ?class .
            ?instance a ?type .
        } }\">
    <ui:if ui:condition=\"{= !spr:isEmpty(?rs) }\">
        <ui:return ui:result=\"{= spr:cell(?rs, spif:cast(fn:floor((RAND() * spr:rowCount(?rs))), xsd:integer), 0) }\"/>
    </ui:if>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Selects a random instance of a given class or its subclasses. Can be used to generate random triples."^^xsd:string ;
  rdfs:label "random instance"^^xsd:string ;
  rdfs:subClassOf ui:Functions ;
.
swa:randomInteger
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:cast ;
                arg:datatype xsd:integer ;
                sp:arg1 [
                    rdf:type fn:floor ;
                    sp:arg1 [
                        rdf:type sp:mul ;
                        sp:arg1 [
                            rdf:type sp:rand ;
                          ] ;
                        sp:arg2 [
                            sp:varName "max"^^xsd:string ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:max ;
      spl:valueType xsd:integer ;
      rdfs:comment "The max value."^^xsd:string ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Returns a random integer between 0 and the provided argument."^^xsd:string ;
  rdfs:label "random integer"^^xsd:string ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
swa:randomNode
  rdf:type ui:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:range ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The range of the property to create a node for."^^xsd:string ;
    ] ;
  ui:prototype """
<ui:group>
    <ui:if ui:condition=\"{= swa:isDatatypeRange(?range) }\">
        <ui:if ui:condition=\"{= xsd:boolean = ?range }\">
            <ui:return ui:result=\"{= RAND() &lt; 0.5 }\"/>
        </ui:if>
        <ui:elseif ui:condition=\"{= swa:isNumericDatatype(?range) }\">
            <ui:return ui:result=\"{= spif:cast(swa:randomInteger(1000), ?range) }\"/>
        </ui:elseif>
        <ui:elseif ui:condition=\"{= xsd:date = ?range }\">
            <ui:return ui:result=\"{= xsd:date(CONCAT(xsd:string((1900 + swa:randomInteger(200))), &quot;-0&quot;, xsd:string((swa:randomInteger(9) + 1)), &quot;-&quot;, xsd:string((swa:randomInteger(18) + 11)))) }\"/>
        </ui:elseif>
        <ui:elseif ui:condition=\"{= xsd:dateTime = ?range }\">
            <ui:return ui:result=\"{= xsd:dateTime(CONCAT(xsd:string(swa:randomNode(xsd:date)), &quot;T&quot;, xsd:string((10 + swa:randomInteger(14))), &quot;:&quot;, xsd:string((10 + swa:randomInteger(50))), &quot;:&quot;, xsd:string((10 + swa:randomInteger(50))))) }\"/>
        </ui:elseif>
        <ui:else>
            <ui:return ui:result=\"{= spif:cast(CONCAT(&quot;Value &quot;, xsd:string(RAND())), ?range) }\"/>
        </ui:else>
    </ui:if>
    <ui:else>
        <ui:return ui:result=\"{= swa:randomInstance(?range) }\"/>
    </ui:else>
</ui:group>
"""^^ui:Literal ;
  rdfs:comment "Returns a random node that matches a given range. Can be used to generate random triples."^^xsd:string ;
  rdfs:label "random node"^^xsd:string ;
  rdfs:subClassOf ui:Functions ;
.
swa:removeUniqueId
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:indexOf ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 "::" ;
              ] ;
            sp:variable [
                sp:varName "index"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type fn:substring ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 1 ;
                sp:arg3 [
                    sp:varName "index"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to convert."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a string and removes everything after the :: (including the :: itself). This is needed to de-code tree node ids."^^xsd:string ;
  rdfs:label "remove unique id"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:resourceIcon
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "type"^^xsd:string ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "resource"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:walkObjects ;
                sp:arg1 [
                    sp:varName "type"^^xsd:string ;
                  ] ;
                sp:arg2 rdfs:subClassOf ;
                sp:arg3 swa:typeIconFunctor ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the icon of."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the most suitable icon for a given resource (instance). It takes the \"first\" rdf:type of the instance and then walks up the hierarchy of classes until it finds a class that has swa:typeIcon attached to it."^^xsd:string ;
  rdfs:label "resource icon"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:restoreFacetValue
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "facetValue"^^xsd:string ;
          ]
        ) ;
      sp:where (
          (
            (
              [
                rdf:type sp:Bind ;
                sp:expression [
                    rdf:type ui:contextValue ;
                    sp:arg1 "swaRestoreSearch" ;
                  ] ;
                sp:variable [
                    sp:varName "search"^^xsd:string ;
                  ] ;
              ]
            )
            [
              rdf:type sp:Bind ;
              sp:expression [
                  rdf:type sp:coalesce ;
                  sp:arg1 [
                      rdf:type ui:contextValue ;
                      sp:arg1 "subjectVarName" ;
                    ] ;
                  sp:arg2 "result" ;
                ] ;
              sp:variable [
                  sp:varName "subjectVarName"^^xsd:string ;
                ] ;
            ]
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "search"^^xsd:string ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "property"^^xsd:string ;
              ] ;
            sp:predicate search:property ;
            sp:subject [
                sp:varName "facet"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subjectVarName"^^xsd:string ;
              ] ;
            sp:predicate search:subjectVarName ;
            sp:subject [
                sp:varName "facet"^^xsd:string ;
              ] ;
          ]
          [
            sp:object search:PropertyFacet ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "facet"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "facetValue"^^xsd:string ;
                      ] ;
                    sp:predicate search:facetValue ;
                    sp:subject [
                        sp:varName "facet"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "facet"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:SeqPath ;
                        sp:path1 search:facet ;
                        sp:path2 [
                            rdf:type sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 0 ;
                            sp:subPath [
                                rdf:type sp:SeqPath ;
                                sp:path1 search:facetValue ;
                                sp:path2 search:facet ;
                              ] ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "search"^^xsd:string ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "facetValue"^^xsd:string ;
                      ] ;
                    sp:predicate search:facetValue ;
                    sp:subject [
                        sp:varName "search"^^xsd:string ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "facet"^^xsd:string ;
                      ] ;
                    sp:predicate search:facet ;
                    sp:subject [
                        sp:varName "facetValue"^^xsd:string ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the FacetValue of."^^xsd:string ;
    ] ;
  spin:returnType search:FacetValue ;
  rdfs:comment """Tries to find a Search to restore using the context value \"swaRestoreSearch\", and then it's facet value for a given property.

Note this also handles legacy Search instances where search:facet and search:facetValue had different domains (see the lower union branch)."""^^xsd:string ;
  rdfs:label "restore facet value"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:restoreInverseFacetValue
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "facetValue"^^xsd:string ;
          ]
        ) ;
      sp:where (
          (
            (
              [
                rdf:type sp:Bind ;
                sp:expression [
                    rdf:type ui:contextValue ;
                    sp:arg1 "swaRestoreSearch" ;
                  ] ;
                sp:variable [
                    sp:varName "search"^^xsd:string ;
                  ] ;
              ]
            )
            [
              rdf:type sp:Bind ;
              sp:expression [
                  rdf:type sp:coalesce ;
                  sp:arg1 [
                      rdf:type ui:contextValue ;
                      sp:arg1 "subjectVarName" ;
                    ] ;
                  sp:arg2 "result" ;
                ] ;
              sp:variable [
                  sp:varName "subjectVarName"^^xsd:string ;
                ] ;
            ]
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "search"^^xsd:string ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "property"^^xsd:string ;
              ] ;
            sp:predicate search:property ;
            sp:subject [
                sp:varName "facet"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "subjectVarName"^^xsd:string ;
              ] ;
            sp:predicate search:subjectVarName ;
            sp:subject [
                sp:varName "facet"^^xsd:string ;
              ] ;
          ]
          [
            sp:object search:InversePropertyFacet ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "facet"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "facetValue"^^xsd:string ;
                      ] ;
                    sp:predicate search:facetValue ;
                    sp:subject [
                        sp:varName "facet"^^xsd:string ;
                      ] ;
                  ]
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "facet"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:SeqPath ;
                        sp:path1 search:facet ;
                        sp:path2 [
                            rdf:type sp:ModPath ;
                            sp:modMax -2 ;
                            sp:modMin 0 ;
                            sp:subPath [
                                rdf:type sp:SeqPath ;
                                sp:path1 search:facetValue ;
                                sp:path2 search:facet ;
                              ] ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "search"^^xsd:string ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "facetValue"^^xsd:string ;
                      ] ;
                    sp:predicate search:facetValue ;
                    sp:subject [
                        sp:varName "search"^^xsd:string ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "facet"^^xsd:string ;
                      ] ;
                    sp:predicate search:facet ;
                    sp:subject [
                        sp:varName "facetValue"^^xsd:string ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the FacetValue of."^^xsd:string ;
    ] ;
  spin:returnType search:FacetValue ;
  rdfs:comment "Tries to find a Search to restore using the context value \"swaRestoreSearch\", and then its facet value for a given inverse property."^^xsd:string ;
  rdfs:label "restore inverse facet value"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:restoreSearch
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Union ;
            sp:elements (
                (
                  (
                    (
                      [
                        rdf:type sp:Bind ;
                        sp:expression [
                            rdf:type ui:contextValue ;
                            sp:arg1 "swaRestoreSearch" ;
                          ] ;
                        sp:variable [
                            sp:varName "rootSearch"^^xsd:string ;
                          ] ;
                      ]
                      [
                        rdf:type sp:Bind ;
                        sp:expression [
                            rdf:type sp:coalesce ;
                            sp:arg1 [
                                rdf:type ui:contextValue ;
                                sp:arg1 "subjectVarName" ;
                              ] ;
                            sp:arg2 "result" ;
                          ] ;
                        sp:variable [
                            sp:varName "subjectVarName"^^xsd:string ;
                          ] ;
                      ]
                    )
                    [
                      rdf:type sp:Filter ;
                      sp:expression [
                          rdf:type sp:and ;
                          sp:arg1 [
                              rdf:type sp:bound ;
                              sp:arg1 [
                                  sp:varName "rootSearch"^^xsd:string ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              rdf:type sp:bound ;
                              sp:arg1 [
                                  sp:varName "subjectVarName"^^xsd:string ;
                                ] ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    rdf:type sp:TriplePath ;
                    sp:object [
                        sp:varName "result"^^xsd:string ;
                      ] ;
                    sp:path [
                        rdf:type sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath [
                            rdf:type sp:SeqPath ;
                            sp:path1 search:facet ;
                            sp:path2 search:facetValue ;
                          ] ;
                      ] ;
                    sp:subject [
                        sp:varName "rootSearch"^^xsd:string ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "subjectVarName"^^xsd:string ;
                      ] ;
                    sp:predicate search:nestedSubjectVarName ;
                    sp:subject [
                        sp:varName "result"^^xsd:string ;
                      ] ;
                  ]
                )
                (
                  [
                    rdf:type sp:Bind ;
                    sp:expression [
                        rdf:type ui:contextValue ;
                        sp:arg1 "swaRestoreSearch" ;
                      ] ;
                    sp:variable [
                        sp:varName "result"^^xsd:string ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType search:Search ;
  rdfs:comment "Tries to find a Search to restore using the context value \"swaRestoreSearch\" and the current \"subjectVarName\". Defaults to the current root search."^^xsd:string ;
  rdfs:label "restore search"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:restoreSearchString
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "string"^^xsd:string ;
          ]
        ) ;
      sp:where (
          (
            (
              [
                rdf:type sp:Bind ;
                sp:expression [
                    rdf:type ui:contextValue ;
                    sp:arg1 "swaRestoreSearch" ;
                  ] ;
                sp:variable [
                    sp:varName "search"^^xsd:string ;
                  ] ;
              ]
            )
            [
              rdf:type sp:Filter ;
              sp:expression [
                  rdf:type sp:bound ;
                  sp:arg1 [
                      sp:varName "search"^^xsd:string ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "string"^^xsd:string ;
              ] ;
            sp:predicate search:string ;
            sp:subject [
                sp:varName "search"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Tries to find a Search to restore using the context value \"swaRestoreSearch\", and then it's string value (full text search)."^^xsd:string ;
  rdfs:label "restore facet value"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:searchCompletedEvent
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    sp:varName "event"^^xsd:string ;
                  ] ;
                sp:arg2 "org.topbraid.swa.searchCompleted" ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:event ;
      spl:valueType xsd:string ;
      rdfs:comment "The event name or null to fall back to the default one."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the name of a search completion event, falling back to a default one (org.topbraid.swa.searchCompleted) if the one provided is unbound."^^xsd:string ;
  rdfs:label "search event"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:searchEvent
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:coalesce ;
                sp:arg1 [
                    sp:varName "event"^^xsd:string ;
                  ] ;
                sp:arg2 "org.topbraid.swa.search" ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:event ;
      spl:valueType xsd:string ;
      rdfs:comment "The event name or null to fall back to the default one."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the name of a search event, falling back to a default one (org.topbraid.swa.search) if the one provided is unbound."^^xsd:string ;
  rdfs:label "search event"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:shortestClassPropertyTreePath
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "property"^^xsd:string ;
              ] ;
            sp:predicate swa:directRelevantClassOfProperty ;
            sp:subject [
                sp:varName "class"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:shortestObjectsPath ;
                sp:arg1 [
                    sp:varName "class"^^xsd:string ;
                  ] ;
                sp:arg2 rdfs:subClassOf ;
                sp:arg3 [
                    sp:varName "root"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "path"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 [
                    sp:varName "path"^^xsd:string ;
                  ] ;
                sp:arg2 " " ;
                sp:arg3 [
                    rdf:type xsd:string ;
                    sp:arg1 [
                        sp:varName "property"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:root ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The (optional) root of the tree."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to start at."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "A helper function used to find the shortest path from a property to a root class. The property needs to be connected to a class in the tree via rdfs:domain."^^xsd:string ;
  rdfs:label "shortest class property tree path"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:specialAddButtonFunction
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "functionName"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "functionName"^^xsd:string ;
                    ] ;
                  sp:predicate swa:specialAddButtonFunctionName ;
                  sp:subject [
                      sp:varName "predicate"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate being edited."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject being edited."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Used by SWA edit widgets to determine whether the add button shall be redirected to a different JavaScript function call than the default behavior."^^xsd:string ;
  rdfs:label "special add button function"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:specialAddButtonFunctionName
  rdf:type rdf:Property ;
  rdfs:comment "Can be used to specify that values of the associated property shall be added with the given JavaScript function. Used by the SPIN function swa:specialAddButtonFunction."^^xsd:string ;
  rdfs:domain rdf:Property ;
  rdfs:label "special add button function name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:subjectFacetMenuName
  rdf:type rdf:Property ;
  rdfs:comment "Links a facet with a display name for drop down menus."^^xsd:string ;
  rdfs:domain swa:SubjectFacetClass ;
  rdfs:label "subject facet menu name"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:subjectHasObjectFromEnum
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:predicate swa:predicatesOfObjects ;
            sp:subject [
                sp:varName "view"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "any"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "subject"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:subject ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to check."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:view ;
      spl:valueType swa:ObjectsEnum ;
      rdfs:comment "The view (usually instance of swa:ObjectsEnum)."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given subject has at least one object for any of the swa:Objects under the given root element."^^xsd:string ;
  rdfs:label "subject has object from enum"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:subjectWidgetMiddleColumnClass
  rdf:type rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "subject widget middle column class"^^xsd:string ;
  rdfs:range swa:SubjectWidgetMiddleColumnClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:subjectWidgetRowClass
  rdf:type rdf:Property ;
  rdfs:domain swa:Mode ;
  rdfs:label "object widget row class"^^xsd:string ;
  rdfs:range swa:ObjectWidgetRowClass ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:subjectWidgetWeight
  rdf:type rdf:Property ;
  rdfs:domain swa:SubjectWidgetClass ;
  rdfs:label "subject widget weight"^^xsd:string ;
  rdfs:range swa:WeightedExpression ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:systemProperty
  rdf:type rdf:Property ;
  rdfs:label "system property"^^xsd:string ;
.
swa:testClass
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "name"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 "test-" ;
                sp:arg2 [
                    rdf:type afn:localname ;
                    sp:arg1 [
                        sp:varName "resource"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "name"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI resource to encode."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "Generates a CSS class name that can be attached to input fields etc to make it easier for test cases to identify them."^^xsd:string ;
  rdfs:label "test class"^^xsd:string ;
  rdfs:subClassOf swa:Functions ;
.
swa:thumbnail
  rdf:type rdf:Property ;
  rdfs:comment "Links a resource with a thumbnail image that shall be used in summary views. Also serves as super-property of frequently used properties."^^xsd:string ;
  rdfs:label "thumbnail"^^xsd:string ;
  rdfs:range rdfs:Resource ;
.
swa:typeIcon
  rdf:type rdf:Property ;
  rdfs:comment "Can be attached to classes (e.g. owl:ObjectProperty) to point to the CSS style of an icon representing instances of that class."^^xsd:string ;
  rdfs:domain rdfs:Class ;
  rdfs:label "type icon"^^xsd:string ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:typeIconFunctor
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "result"^^xsd:string ;
                    ] ;
                  sp:predicate swa:typeIcon ;
                  sp:subject [
                      sp:varName "class"^^xsd:string ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:graph ;
          ]
        ) ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:string ;
  rdfs:comment "A functor that can be used to find the most specialized icon for a class and its superclasses."^^xsd:string ;
  rdfs:label "type icon functor"^^xsd:string ;
  rdfs:subClassOf swa:ClassFunctorFunctions ;
.
swa:updateSecureStorage
  rdf:type ui:NodeClass ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate arg:value ;
      spl:valueType xsd:string ;
      rdfs:comment "The value to store for the key."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:key ;
      spl:valueType xsd:string ;
      rdfs:comment "The key."^^xsd:string ;
    ] ;
  ui:private "true"^^xsd:boolean ;
  rdfs:comment "Updates a key/value pair in TopBraid's secure storage."^^xsd:string ;
  rdfs:label "update secure storage"^^xsd:string ;
  rdfs:subClassOf ui:ControlElement ;
.
swa:used
  rdf:type rdf:Property ;
  rdfs:comment "Internal system property used by some algorithm(s) to mark that certain properties have been used on a form."^^xsd:string ;
  rdfs:label "used"^^xsd:string ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:visited
  rdf:type rdf:Property ;
  rdfs:comment "Used by swa:ResourceDestructor to remember which resources it has alread \"seen\"."^^xsd:string ;
  rdfs:label "visited"^^xsd:string ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf swa:systemProperty ;
.
swa:weight
  rdf:type rdf:Property ;
  rdfs:domain swa:WeightedExpression ;
  rdfs:label "weight"^^xsd:string ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf swa:systemProperty ;
.
html:searchGraph
  rdf:type html:Attribute ;
  rdfs:label "search graph"^^xsd:string ;
  rdfs:subPropertyOf html:attributes ;
.
html:treedataprovider
  rdf:type html:Attribute ;
  rdfs:label "tree data provider"^^xsd:string ;
  rdfs:subPropertyOf html:attributes ;
.
html:treeroot
  rdf:type html:Attribute ;
  rdfs:label "tree root"^^xsd:string ;
  rdfs:subPropertyOf html:attributes ;
.
ui:Element
  ui:instanceView """
<swa:ArgumentsFormBody arg:resource=\"{= ?this }\" ui:id=\"form\"/>
"""^^ui:Literal ;
.
ui:SubjectWidgetRowClass
  rdf:type rdfs:Class ;
  rdfs:label "Subject widget row class"^^xsd:string ;
  rdfs:subClassOf ui:NodeClass ;
.
ui:view
  swa:hiddenProperty "if no object exists"^^xsd:string ;
.
rdf:Property
  swa:typeIcon "swa-icon-property"^^xsd:string ;
  ui:instanceView """
<swa:PropertyFormBody arg:resource=\"{= ?this }\" ui:id=\"form\" ui:priority=\"{= -9 }\"/>
"""^^ui:Literal ;
.
rdf:value
  swa:hiddenProperty "if no object exists"^^xsd:string ;
.
rdfs:Class
  swa:typeIcon "swa-icon-class"^^xsd:string ;
  ui:instanceView """
<swa:ClassDestructor arg:resource=\"{= ?this }\" ui:id=\"destructor\"/>
"""^^ui:Literal ;
  ui:instanceView """
<swa:ClassFormBody arg:resource=\"{= ?this }\" ui:id=\"form\" ui:priority=\"{= -9 }\"/>
"""^^ui:Literal ;
.
rdfs:Resource
  search:facetedSearch search:DefaultSearch ;
  swa:typeIcon "swa-icon-resource"^^xsd:string ;
  ui:instanceView """
<swa:DefaultDestructor arg:resource=\"{= ?this }\" ui:id=\"destructor\"/>
"""^^ui:Literal ;
  ui:instanceView """
<swa:ResourceFormBody arg:resource=\"{= ?this }\" ui:id=\"form\" ui:priority=\"{= -9 }\"/>
"""^^ui:Literal ;
  ui:instanceView """
<swa:ResourceSummary arg:resource=\"{= ?this }\" ui:id=\"summary\" ui:priority=\"{= -10 }\"/>
"""^^ui:Literal ;
  ui:instanceView """
<swa:TitledForm arg:resource=\"{= ?this }\" ui:priority=\"{= -9 }\"/>
"""^^ui:Literal ;
  ui:instanceView """
<ui:group ui:id=\"label\" ui:priority=\"{= -5 }\">{= ui:label(?this) }</ui:group>
"""^^ui:Literal ;
.
rdfs:comment
  swa:hiddenProperty "if no object exists"^^xsd:string ;
  rdfs:subPropertyOf swa:description ;
.
rdfs:isDefinedBy
  swa:hiddenProperty "if no object exists"^^xsd:string ;
.
rdfs:label
  swa:hiddenProperty "if no object exists"^^xsd:string ;
.
rdfs:member
  swa:hiddenProperty "true"^^xsd:boolean ;
.
rdfs:seeAlso
  swa:hiddenProperty "if no object exists"^^xsd:string ;
.
owl:AnnotationProperty
  swa:typeIcon "swa-icon-annotation-property"^^xsd:string ;
.
owl:DatatypeProperty
  swa:typeIcon "swa-icon-datatype-property"^^xsd:string ;
.
owl:ObjectProperty
  swa:typeIcon "swa-icon-object-property"^^xsd:string ;
.
owl:annotatedProperty
  swa:hiddenProperty "true"^^xsd:boolean ;
.
owl:annotatedSource
  swa:hiddenProperty "true"^^xsd:boolean ;
.
owl:annotatedTarget
  swa:hiddenProperty "true"^^xsd:boolean ;
.
owl:bottomDataProperty
  swa:hiddenProperty "true"^^xsd:boolean ;
.
owl:bottomObjectProperty
  swa:hiddenProperty "true"^^xsd:boolean ;
.
owl:deprecated
  swa:hiddenProperty "if no object exists"^^xsd:string ;
.
owl:differentFrom
  swa:hiddenProperty "if no object exists"^^xsd:string ;
.
owl:members
  swa:hiddenProperty "true"^^xsd:boolean ;
.
owl:sameAs
  swa:hiddenProperty "if no object exists"^^xsd:string ;
.
owl:topDataProperty
  swa:hiddenProperty "true"^^xsd:boolean ;
.
owl:topObjectProperty
  swa:hiddenProperty "true"^^xsd:boolean ;
.
owl:versionInfo
  swa:hiddenProperty "if no object exists"^^xsd:string ;
.
skos:definition
  rdfs:subPropertyOf swa:description ;
.
<http://xmlns.com/foaf/0.1/depiction>
  rdf:type rdf:Property ;
  rdfs:label "depiction"^^xsd:string ;
  rdfs:subPropertyOf swa:thumbnail ;
.
